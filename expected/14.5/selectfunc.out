--Testcase 1:
SET datestyle=ISO;
--Testcase 2:
SET timezone='Japan';
\set ECHO none
--Testcase 3:
CREATE EXTENSION mysql_fdw;
--Testcase 4:
CREATE SERVER server1 FOREIGN DATA WRAPPER mysql_fdw
  OPTIONS (host :MYSQL_HOST, port :MYSQL_PORT);
--Testcase 5:
CREATE USER MAPPING FOR CURRENT_USER SERVER server1
  OPTIONS (username :MYSQL_USER_NAME, password :MYSQL_PASS);
--IMPORT FOREIGN SCHEMA public FROM SERVER server1 INTO public OPTIONS(import_time_text 'false');
--Testcase 6:
CREATE FOREIGN TABLE s3(id int, tag1 text, value1 float, value2 int, value3 float, value4 int, str1 text, str2 text) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 's3');
--Testcase 7:
CREATE FOREIGN TABLE s4(id int, c1 time without time zone) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 's4');
-- s3 (value1 as float8, value2 as bigint)
--Testcase 8:
\d s3;
                        Foreign table "public.s3"
 Column |       Type       | Collation | Nullable | Default | FDW options 
--------+------------------+-----------+----------+---------+-------------
 id     | integer          |           |          |         | 
 tag1   | text             |           |          |         | 
 value1 | double precision |           |          |         | 
 value2 | integer          |           |          |         | 
 value3 | double precision |           |          |         | 
 value4 | integer          |           |          |         | 
 str1   | text             |           |          |         | 
 str2   | text             |           |          |         | 
Server: server1
FDW options: (dbname 'mysql_fdw_regress', table_name 's3')

--Testcase 9:
SELECT * FROM s3;
 id | tag1 | value1 | value2 | value3 | value4 |   str1    |   str2    
----+------+--------+--------+--------+--------+-----------+-----------
  0 | a    |    0.1 |    100 |   -0.1 |   -100 | ---XYZ--- |    XYZ   
  1 | a    |    0.2 |    100 |   -0.2 |   -100 | ---XYZ--- |    XYZ   
  2 | a    |    0.3 |    100 |   -0.3 |   -100 | ---XYZ--- |    XYZ   
  3 | b    |    1.1 |    200 |   -1.1 |   -200 | ---XYZ--- |    XYZ   
  4 | b    |    2.2 |    200 |   -2.2 |   -200 | ---XYZ--- |    XYZ   
  5 | b    |    3.3 |    200 |   -3.3 |   -200 | ---XYZ--- |    XYZ   
(6 rows)

-- select float8() (not pushdown, remove float8, explain)
--Testcase 10:
EXPLAIN VERBOSE
SELECT float8(value1), float8(value2), float8(value3), float8(value4) FROM s3;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..169.71 rows=1706 width=32)
   Output: value1, float8(value2), value3, float8(value4)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select float8() (not pushdown, remove float8, result)
--Testcase 11:
SELECT float8(value1), float8(value2), float8(value3), float8(value4) FROM s3;
 float8 | float8 | float8 | float8 
--------+--------+--------+--------
    0.1 |    100 |   -0.1 |   -100
    0.2 |    100 |   -0.2 |   -100
    0.3 |    100 |   -0.3 |   -100
    1.1 |    200 |   -1.1 |   -200
    2.2 |    200 |   -2.2 |   -200
    3.3 |    200 |   -3.3 |   -200
(6 rows)

-- select abs (builtin function, explain)
--Testcase 12:
EXPLAIN VERBOSE
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..178.24 rows=1706 width=24)
   Output: abs(value1), abs(value2), abs(value3), abs(value4)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select abs (buitin function, result)
--Testcase 13:
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3;
 abs | abs | abs | abs 
-----+-----+-----+-----
 0.1 | 100 | 0.1 | 100
 0.2 | 100 | 0.2 | 100
 0.3 | 100 | 0.3 | 100
 1.1 | 200 | 1.1 | 200
 2.2 | 200 | 2.2 | 200
 3.3 | 200 | 3.3 | 200
(6 rows)

-- select abs (builtin function, not pushdown constraints, explain)
--Testcase 14:
EXPLAIN VERBOSE
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 WHERE to_hex(value2) != '64';
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.50 rows=1697 width=24)
   Output: abs(value1), abs(value2), abs(value3), abs(value4)
   Filter: (to_hex(s3.value2) <> '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select abs (builtin function, not pushdown constraints, result)
--Testcase 15:
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 WHERE to_hex(value2) != '64';
 abs | abs | abs | abs 
-----+-----+-----+-----
 1.1 | 200 | 1.1 | 200
 2.2 | 200 | 2.2 | 200
 3.3 | 200 | 3.3 | 200
(3 rows)

-- select abs (builtin function, pushdown constraints, explain)
--Testcase 16:
EXPLAIN VERBOSE
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 WHERE value2 != 200;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..182.23 rows=1697 width=24)
   Output: abs(value1), abs(value2), abs(value3), abs(value4)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select abs (builtin function, pushdown constraints, result)
--Testcase 17:
SELECT abs(value1), abs(value2), abs(value3), abs(value4) FROM s3 WHERE value2 != 200;
 abs | abs | abs | abs 
-----+-----+-----+-----
 0.1 | 100 | 0.1 | 100
 0.2 | 100 | 0.2 | 100
 0.3 | 100 | 0.3 | 100
(3 rows)

-- select log (builtin function, numeric cast, explain)
-- log_<base>(v) : postgresql (base, v), mysql (base, v)
--Testcase 18:
EXPLAIN VERBOSE
SELECT value1, log(value1::numeric, value2::numeric) FROM s3 WHERE value1 != 1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..200.70 rows=2264 width=40)
   Output: value1, log((value1)::numeric, (value2)::numeric)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value1` <> 1))
(4 rows)

-- select log (builtin function, numeric cast, result)
--Testcase 19:
SELECT value1, log(value1::numeric, value2::numeric) FROM s3 WHERE value1 != 1;
 value1 |         log         
--------+---------------------
    0.1 | -2.0000000000000000
    0.2 | -2.8613531161467861
    0.3 | -3.8249785787863969
    1.1 |  55.590256753535330
    2.2 |  6.7198527566540755
    3.3 |  4.4377398922117404
(6 rows)

-- select log (builtin function,  float8, explain)
--Testcase 20:
EXPLAIN VERBOSE
SELECT value1, log(value1::numeric, 0.1) FROM s3 WHERE value1 != 1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..205.68 rows=2547 width=40)
   Output: value1, log((value1)::numeric, 0.1)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value1` <> 1))
(4 rows)

-- select log (builtin function, float8, result)
--Testcase 21:
SELECT value1, log(value1::numeric, 0.1) FROM s3 WHERE value1 != 1;
 value1 |         log         
--------+---------------------
    0.1 |  1.0000000000000000
    0.2 |  1.4306765580733931
    0.3 |  1.9124892893931984
    1.1 | -24.158857928096806
    2.2 | -2.9203673004336506
    3.3 | -1.9285884584617046
(6 rows)

-- select log (builtin function, bigint, explain)
--Testcase 22:
EXPLAIN VERBOSE
SELECT value1, log(value2::numeric, 3) FROM s3 WHERE value1 != 1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.04 rows=2264 width=40)
   Output: value1, log((value2)::numeric, '3'::numeric)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value1` <> 1))
(4 rows)

-- select log (builtin function, bigint, result)
--Testcase 23:
SELECT value1, log(value2::numeric, 3) FROM s3 WHERE value1 != 1;
 value1 |        log         
--------+--------------------
    0.1 | 0.2385606273598312
    0.2 | 0.2385606273598312
    0.3 | 0.2385606273598312
    1.1 | 0.2073511669203535
    2.2 | 0.2073511669203535
    3.3 | 0.2073511669203535
(6 rows)

-- select log (builtin function, mix type, explain)
--Testcase 24:
EXPLAIN VERBOSE
SELECT value1, log(value1::numeric, value2::numeric) FROM s3 WHERE value1 != 1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..200.70 rows=2264 width=40)
   Output: value1, log((value1)::numeric, (value2)::numeric)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value1` <> 1))
(4 rows)

-- select log (builtin function,  mix type, result)
--Testcase 25:
SELECT value1, log(value1::numeric, value2::numeric) FROM s3 WHERE value1 != 1;
 value1 |         log         
--------+---------------------
    0.1 | -2.0000000000000000
    0.2 | -2.8613531161467861
    0.3 | -3.8249785787863969
    1.1 |  55.590256753535330
    2.2 |  6.7198527566540755
    3.3 |  4.4377398922117404
(6 rows)

-- select log(v) -- built in function
-- log(v): postgreSQL base 10 logarithm
--Testcase 26:
EXPLAIN VERBOSE
SELECT log(value2) FROM s3 WHERE value1 != 1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..219.31 rows=2910 width=8)
   Output: log((value2)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value1` <> 1))
(4 rows)

--Testcase 27:
SELECT log(value2) FROM s3 WHERE value1 != 1;
        log         
--------------------
                  2
                  2
                  2
 2.3010299956639813
 2.3010299956639813
 2.3010299956639813
(6 rows)

-- select log (builtin function, explain)
--Testcase 28:
EXPLAIN VERBOSE
SELECT log(value1), log(value2), log(0.5) FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.31 rows=2275 width=48)
   Output: log(value1), log((value2)::double precision), '-0.3010299956639812'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log (builtin function, result)
--Testcase 29:
SELECT log(value1), log(value2), log(0.5) FROM s3;
         log         |        log         |         log         
---------------------+--------------------+---------------------
                  -1 |                  2 | -0.3010299956639812
 -0.6989700043360187 |                  2 | -0.3010299956639812
 -0.5228787452803376 |                  2 | -0.3010299956639812
 0.04139268515822507 | 2.3010299956639813 | -0.3010299956639812
  0.3424226808222063 | 2.3010299956639813 | -0.3010299956639812
  0.5185139398778874 | 2.3010299956639813 | -0.3010299956639812
(6 rows)

-- select log (builtin function, not pushdown constraints, explain)
--Testcase 30:
EXPLAIN VERBOSE
SELECT log(value1), log(value2), log(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..144.43 rows=11 width=48)
   Output: log(value1), log((value2)::double precision), '-0.3010299956639812'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select log (builtin function, not pushdown constraints, result)
--Testcase 31:
SELECT log(value1), log(value2), log(0.5) FROM s3 WHERE to_hex(value2) = '64';
         log         | log |         log         
---------------------+-----+---------------------
                  -1 |   2 | -0.3010299956639812
 -0.6989700043360187 |   2 | -0.3010299956639812
 -0.5228787452803376 |   2 | -0.3010299956639812
(3 rows)

-- select log (builtin function, pushdown constraints, explain)
--Testcase 32:
EXPLAIN VERBOSE
SELECT log(value1), log(value2), log(0.5) FROM s3 WHERE value2 != 200;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..200.70 rows=2264 width=48)
   Output: log(value1), log((value2)::double precision), '-0.3010299956639812'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select log (builtin function, pushdown constraints, result)
--Testcase 33:
SELECT log(value1), log(value2), log(0.5) FROM s3 WHERE value2 != 200;
         log         | log |         log         
---------------------+-----+---------------------
                  -1 |   2 | -0.3010299956639812
 -0.6989700043360187 |   2 | -0.3010299956639812
 -0.5228787452803376 |   2 | -0.3010299956639812
(3 rows)

-- select log (builtin function, log in constraints, explain)
--Testcase 34:
EXPLAIN VERBOSE
SELECT log(value1), log(value2), log(0.5) FROM s3 WHERE log(value1) != 1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..206.38 rows=2264 width=48)
   Output: log(value1), log((value2)::double precision), '-0.3010299956639812'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((log10(`value1`) <> 1))
(4 rows)

-- select log (builtin function, log in constraints, result)
--Testcase 35:
SELECT log(value1), log(value2), log(0.5) FROM s3 WHERE log(value1) != 1;
         log         |        log         |         log         
---------------------+--------------------+---------------------
                  -1 |                  2 | -0.3010299956639812
 -0.6989700043360187 |                  2 | -0.3010299956639812
 -0.5228787452803376 |                  2 | -0.3010299956639812
 0.04139268515822507 | 2.3010299956639813 | -0.3010299956639812
  0.3424226808222063 | 2.3010299956639813 | -0.3010299956639812
  0.5185139398778874 | 2.3010299956639813 | -0.3010299956639812
(6 rows)

-- select log (builtin function, log in constraints, explain)
--Testcase 36:
EXPLAIN VERBOSE
SELECT log(value1), log(value2), log(0.5) FROM s3 WHERE log(5) > value1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..159.28 rows=758 width=48)
   Output: log(value1), log((value2)::double precision), '-0.3010299956639812'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((0.6989700043360189 > `value1`))
(4 rows)

-- select log (builtin function, log in constraints, result)
--Testcase 37:
SELECT log(value1), log(value2), log(0.5) FROM s3 WHERE log(5) > value1;
         log         | log |         log         
---------------------+-----+---------------------
                  -1 |   2 | -0.3010299956639812
 -0.6989700043360187 |   2 | -0.3010299956639812
 -0.5228787452803376 |   2 | -0.3010299956639812
(3 rows)

-- select log as nest function with agg (pushdown, explain)
--Testcase 38:
EXPLAIN VERBOSE
SELECT sum(value3),log(sum(value2)) FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (log((sum(value2))::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), log10(sum(`value2`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select log as nest function with agg (pushdown, result)
--Testcase 39:
SELECT sum(value3),log(sum(value2)) FROM s3;
        sum         |        log         
--------------------+--------------------
 -7.200000040233135 | 2.9542425094393248
(1 row)

-- select log as nest with log2 (pushdown, explain)
--Testcase 40:
EXPLAIN VERBOSE
SELECT value1, log(log2(value1)),log(log2(1/value1)) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, log(log2(value1)), log(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log as nest with log2 (pushdown, result)
--Testcase 41:
SELECT value1, log(log2(value1)),log(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log with non pushdown func and explicit constant (explain)
--Testcase 42:
EXPLAIN VERBOSE
SELECT log(value2), pi(), 4.1 FROM s3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2925 width=48)
   Output: log((value2)::double precision), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log with non pushdown func and explicit constant (result)
--Testcase 43:
SELECT log(value2), pi(), 4.1 FROM s3;
        log         |        pi         | ?column? 
--------------------+-------------------+----------
                  2 | 3.141592653589793 |      4.1
                  2 | 3.141592653589793 |      4.1
                  2 | 3.141592653589793 |      4.1
 2.3010299956639813 | 3.141592653589793 |      4.1
 2.3010299956639813 | 3.141592653589793 |      4.1
 2.3010299956639813 | 3.141592653589793 |      4.1
(6 rows)

-- select log with order by (explain)
--Testcase 44:
EXPLAIN VERBOSE
SELECT value3, log(1-value3) FROM s3 ORDER BY log(1-value3);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value3, log(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY log10((1 - `value3`)) IS NULL ASC, log10((1 - `value3`)) ASC
(4 rows)

-- select log with order by (result)
--Testcase 45:
SELECT value3, log(1-value3) FROM s3 ORDER BY log(1-value3);
 value3 |         log         
--------+---------------------
   -0.1 | 0.04139268515822507
   -0.2 | 0.07918124604762482
   -0.3 | 0.11394335230683678
   -1.1 |  0.3222192947339193
   -2.2 |   0.505149978319906
   -3.3 |  0.6334684555795865
(6 rows)

-- select log with order by index (result)
--Testcase 46:
SELECT value3, log(1-value3) FROM s3 ORDER BY 2,1;
 value3 |         log         
--------+---------------------
   -0.1 | 0.04139268515822507
   -0.2 | 0.07918124604762482
   -0.3 | 0.11394335230683678
   -1.1 |  0.3222192947339193
   -2.2 |   0.505149978319906
   -3.3 |  0.6334684555795865
(6 rows)

-- select log with order by index (result)
--Testcase 47:
SELECT value3, log(1-value3) FROM s3 ORDER BY 1,2;
 value3 |         log         
--------+---------------------
   -3.3 |  0.6334684555795865
   -2.2 |   0.505149978319906
   -1.1 |  0.3222192947339193
   -0.3 | 0.11394335230683678
   -0.2 | 0.07918124604762482
   -0.1 | 0.04139268515822507
(6 rows)

-- select log with group by (explain)
--Testcase 48:
EXPLAIN VERBOSE
SELECT count(value1), log(1-value3) FROM s3 GROUP BY log(1-value3);
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (log(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), log10((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select log with group by (result)
--Testcase 49:
SELECT count(value1), log(1-value3) FROM s3 GROUP BY log(1-value3);
 count |         log         
-------+---------------------
     1 |  0.0413926857465425
     1 | 0.07918124712620683
     1 | 0.11394335628929342
     1 | 0.32221929966457985
     1 |   0.505149984791398
     1 |  0.6334684507635924
(6 rows)

-- select log with group by index (result)
--Testcase 50:
SELECT value1, log(1-value3) FROM s3 GROUP BY 2,1;
 value1 |         log         
--------+---------------------
    0.1 |  0.0413926857465425
    0.2 | 0.07918124712620683
    0.3 | 0.11394335628929342
    1.1 | 0.32221929966457985
    2.2 |   0.505149984791398
    3.3 |  0.6334684507635924
(6 rows)

-- select log with group by index (result)
--Testcase 51:
SELECT value1, log(1-value3) FROM s3 GROUP BY 1,2;
 value1 |         log         
--------+---------------------
    0.1 |  0.0413926857465425
    0.2 | 0.07918124712620683
    0.3 | 0.11394335628929342
    1.1 | 0.32221929966457985
    2.2 |   0.505149984791398
    3.3 |  0.6334684507635924
(6 rows)

-- select log with group by having (explain)
--Testcase 52:
EXPLAIN VERBOSE
SELECT count(value1), log(1-value3) FROM s3 GROUP BY log(1-value3) HAVING log(avg(value1)) > 0;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (log(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), log10((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((log10(avg(`value1`)) > 0))
(5 rows)

-- select log with group by having (result)
--Testcase 53:
SELECT count(value1), log(1-value3) FROM s3 GROUP BY log(1-value3) HAVING log(avg(value1)) > 0;
 count |         log         
-------+---------------------
     1 | 0.32221929966457985
     1 |   0.505149984791398
     1 |  0.6334684507635924
(3 rows)

-- select log with group by index having (result)
--Testcase 54:
SELECT value3, log(1-value3) FROM s3 GROUP BY 2,1 HAVING log(1-value3) < 0;
 value3 | log 
--------+-----
(0 rows)

-- select log with group by index having (result)
--Testcase 55:
SELECT value3, log(1-value3) FROM s3 GROUP BY 1,2 HAVING value3 > 1;
 value3 | log 
--------+-----
(0 rows)

-- select log and as
--Testcase 56:
SELECT log(value1) as log1 FROM s3;
        log1         
---------------------
                  -1
 -0.6989700043360187
 -0.5228787452803376
 0.04139268515822507
  0.3424226808222063
  0.5185139398778874
(6 rows)

-- select abs as nest function with agg (pushdown, explain)
--Testcase 57:
EXPLAIN VERBOSE
SELECT sum(value3),abs(sum(value3)) FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (abs(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), abs(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select abs as nest function with agg (pushdown, result)
--Testcase 58:
SELECT sum(value3),abs(sum(value3)) FROM s3;
        sum         |        abs        
--------------------+-------------------
 -7.200000040233135 | 7.200000040233135
(1 row)

-- test aggregation (sum, count, avg) with time interval
--Testcase 59:
SELECT * FROM s4;
 id |       c1        
----+-----------------
  0 | 12:10:30.123456
  1 | 23:12:12.654321
  2 | 11:12:12.112233
(3 rows)

-- sum and time without casting to interval
--Testcase 60:
EXPLAIN VERBOSE
SELECT sum(c1) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((sum((c1)::interval) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(sum(TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 61:
SELECT sum(c1) + '24:10:10'::interval FROM s4 GROUP BY id;
            ?column?             
---------------------------------
 @ 36 hours 20 mins 40.1235 secs
 @ 47 hours 22 mins 22.6543 secs
 @ 35 hours 22 mins 22.1122 secs
(3 rows)

-- sum and time with casting to interval
--Testcase 62:
EXPLAIN VERBOSE
SELECT sum(c1::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((sum((c1)::interval) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(sum(TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 63:
SELECT sum(c1::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
            ?column?             
---------------------------------
 @ 36 hours 20 mins 40.1235 secs
 @ 47 hours 22 mins 22.6543 secs
 @ 35 hours 22 mins 22.1122 secs
(3 rows)

-- sum and time with interval const and without casting to interval
--Testcase 64:
EXPLAIN VERBOSE
SELECT sum(c1 + '24:10:10'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((sum(((c1 + '@ 24 hours 10 mins 10 secs'::interval))::interval) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(sum((TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6) + 87010.0))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 65:
SELECT sum(c1 + '24:10:10'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
            ?column?             
---------------------------------
 @ 60 hours 30 mins 50.1235 secs
 @ 71 hours 32 mins 32.6543 secs
 @ 59 hours 32 mins 32.1122 secs
(3 rows)

-- sum and time with interval const and with casting to interval
--Testcase 66:
EXPLAIN VERBOSE
SELECT sum(c1::interval + '24:10:10'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((sum(((c1)::interval + '@ 24 hours 10 mins 10 secs'::interval)) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(sum((TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6) + 87010.0))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 67:
SELECT sum(c1::interval + '24:10:10'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
            ?column?             
---------------------------------
 @ 60 hours 30 mins 50.1235 secs
 @ 71 hours 32 mins 32.6543 secs
 @ 59 hours 32 mins 32.1122 secs
(3 rows)

-- sum and time with milisecond
--Testcase 68:
EXPLAIN VERBOSE
SELECT sum(c1::interval + '24:10:10.123456'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((sum(((c1)::interval + '@ 24 hours 10 mins 10.123456 secs'::interval)) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(sum((TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6) + 87010.123456))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 69:
SELECT sum(c1::interval + '24:10:10.123456'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
             ?column?              
-----------------------------------
 @ 60 hours 30 mins 50.246956 secs
 @ 71 hours 32 mins 32.777756 secs
 @ 59 hours 32 mins 32.235656 secs
(3 rows)

-- avg and time without casting to interval
--Testcase 70:
EXPLAIN VERBOSE
SELECT avg(c1) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((avg((c1)::interval) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(avg(TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 71:
SELECT avg(c1) + '24:10:10'::interval FROM s4 GROUP BY id;
            ?column?             
---------------------------------
 @ 36 hours 20 mins 40.1235 secs
 @ 47 hours 22 mins 22.6543 secs
 @ 35 hours 22 mins 22.1122 secs
(3 rows)

-- avg and time with casting to interval
--Testcase 72:
EXPLAIN VERBOSE
SELECT avg(c1::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((avg((c1)::interval) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(avg(TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 73:
SELECT avg(c1::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
            ?column?             
---------------------------------
 @ 36 hours 20 mins 40.1235 secs
 @ 47 hours 22 mins 22.6543 secs
 @ 35 hours 22 mins 22.1122 secs
(3 rows)

-- avg and time with interval const and without casting to interval
--Testcase 74:
EXPLAIN VERBOSE
SELECT avg(c1 + '24:10:10'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((avg(((c1 + '@ 24 hours 10 mins 10 secs'::interval))::interval) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(avg((TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6) + 87010.0))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 75:
SELECT avg(c1 + '24:10:10'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
            ?column?             
---------------------------------
 @ 60 hours 30 mins 50.1235 secs
 @ 71 hours 32 mins 32.6543 secs
 @ 59 hours 32 mins 32.1122 secs
(3 rows)

-- avg and time with interval const and with casting to interval
--Testcase 76:
EXPLAIN VERBOSE
SELECT avg(c1::interval + '24:10:10'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((avg(((c1)::interval + '@ 24 hours 10 mins 10 secs'::interval)) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(avg((TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6) + 87010.0))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 77:
SELECT avg(c1::interval + '24:10:10'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
            ?column?             
---------------------------------
 @ 60 hours 30 mins 50.1235 secs
 @ 71 hours 32 mins 32.6543 secs
 @ 59 hours 32 mins 32.1122 secs
(3 rows)

-- avg and time with milisecond
--Testcase 78:
EXPLAIN VERBOSE
SELECT avg(c1::interval + '24:10:10.123456'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
                                                                                                           QUERY PLAN                                                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: ((avg(((c1)::interval + '@ 24 hours 10 mins 10.123456 secs'::interval)) + '@ 24 hours 10 mins 10 secs'::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT (SEC_TO_TIME(avg((TIME_TO_SEC(`c1`) + ROUND(MICROSECOND(`c1`)/1000000, 6) + 87010.123456))) + INTERVAL 24 HOUR + INTERVAL 10 MINUTE + INTERVAL 10 SECOND), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 79:
SELECT avg(c1::interval + '24:10:10.123456'::interval) + '24:10:10'::interval FROM s4 GROUP BY id;
             ?column?              
-----------------------------------
 @ 60 hours 30 mins 50.246956 secs
 @ 71 hours 32 mins 32.777756 secs
 @ 59 hours 32 mins 32.235656 secs
(3 rows)

-- count with cast to interval
--Testcase 80:
EXPLAIN VERBOSE
SELECT count(c1::interval) FROM s4 GROUP BY id;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count((c1)::interval)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT count(`c1`), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 81:
SELECT count(c1::interval) FROM s4 GROUP BY id;
 count 
-------
     1
     1
     1
(3 rows)

-- count without cast to interval
--Testcase 82:
EXPLAIN VERBOSE
SELECT count(c1) FROM s4 GROUP BY id;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=12)
   Output: (count(c1)), id
   Relations: Aggregate on (mysql_fdw_regress.s4)
   Local server startup cost: 10
   Remote query: SELECT count(`c1`), `id` FROM `mysql_fdw_regress`.`s4` GROUP BY 2
(5 rows)

--Testcase 83:
SELECT count(c1) FROM s4 GROUP BY id;
 count 
-------
     1
     1
     1
(3 rows)

-- select abs as nest with log2 (pushdown, explain)
--Testcase 84:
EXPLAIN VERBOSE
SELECT value1, abs(log2(value1)),abs(log2(1/value1)) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, abs(log2(value1)), abs(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select abs as nest with log2 (pushdown, result)
--Testcase 85:
SELECT value1, abs(log2(value1)),abs(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select abs with non pushdown func and explicit constant (explain)
--Testcase 86:
EXPLAIN VERBOSE
SELECT abs(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: abs(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select abs with non pushdown func and explicit constant (result)
--Testcase 87:
SELECT abs(value3), pi(), 4.1 FROM s3;
 abs |        pi         | ?column? 
-----+-------------------+----------
 0.1 | 3.141592653589793 |      4.1
 0.2 | 3.141592653589793 |      4.1
 0.3 | 3.141592653589793 |      4.1
 1.1 | 3.141592653589793 |      4.1
 2.2 | 3.141592653589793 |      4.1
 3.3 | 3.141592653589793 |      4.1
(6 rows)

-- select sqrt as nest function with agg and explicit constant (pushdown, explain)
--Testcase 88:
EXPLAIN VERBOSE
SELECT sqrt(count(value1)), pi(), 4.1 FROM s3;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=48)
   Output: (sqrt((count(value1))::double precision)), '3.141592653589793'::double precision, 4.1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sqrt(count(`value1`)), 3.141592653589793, 4.1 FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select sqrt as nest function with agg and explicit constant (pushdown, result)
--Testcase 89:
SELECT sqrt(count(value1)), pi(), 4.1 FROM s3;
       sqrt        |        pi         | ?column? 
-------------------+-------------------+----------
 2.449489742783178 | 3.141592653589793 |      4.1
(1 row)

-- select sqrt as nest function with agg and explicit constant and tag (error, explain)
--Testcase 90:
EXPLAIN VERBOSE
SELECT sqrt(count(value1)), pi(), 4.1, tag1 FROM s3;
ERROR:  column "s3.tag1" must appear in the GROUP BY clause or be used in an aggregate function
LINE 2: SELECT sqrt(count(value1)), pi(), 4.1, tag1 FROM s3;
                                               ^
-- select abs with order by (explain)
--Testcase 91:
EXPLAIN VERBOSE
SELECT value3, abs(1-value3) FROM s3 ORDER BY abs(1-value3);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value3, abs(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY abs((1 - `value3`)) IS NULL ASC, abs((1 - `value3`)) ASC
(4 rows)

-- select abs with order by (result)
--Testcase 92:
SELECT value3, abs(1-value3) FROM s3 ORDER BY abs(1-value3);
 value3 | abs 
--------+-----
   -0.1 | 1.1
   -0.2 | 1.2
   -0.3 | 1.3
   -1.1 | 2.1
   -2.2 | 3.2
   -3.3 | 4.3
(6 rows)

-- select abs with order by index (result)
--Testcase 93:
SELECT value3, abs(1-value3) FROM s3 ORDER BY 2,1;
 value3 | abs 
--------+-----
   -0.1 | 1.1
   -0.2 | 1.2
   -0.3 | 1.3
   -1.1 | 2.1
   -2.2 | 3.2
   -3.3 | 4.3
(6 rows)

-- select abs with order by index (result)
--Testcase 94:
SELECT value3, abs(1-value3) FROM s3 ORDER BY 1,2;
 value3 | abs 
--------+-----
   -3.3 | 4.3
   -2.2 | 3.2
   -1.1 | 2.1
   -0.3 | 1.3
   -0.2 | 1.2
   -0.1 | 1.1
(6 rows)

-- select abs and as
--Testcase 95:
SELECT abs(value3) as abs1 FROM s3;
 abs1 
------
  0.1
  0.2
  0.3
  1.1
  2.2
  3.3
(6 rows)

-- select abs with arithmetic and tag in the middle (explain)
--Testcase 96:
EXPLAIN VERBOSE
SELECT abs(value1) + 1, value2, tag1, sqrt(value2) FROM s3;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..158.16 rows=1204 width=52)
   Output: (abs(value1) + '1'::double precision), value2, tag1, sqrt((value2)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select abs with arithmetic and tag in the middle (result)
--Testcase 97:
SELECT abs(value1) + 1, value2, tag1, sqrt(value2) FROM s3;
 ?column? | value2 | tag1 |        sqrt        
----------+--------+------+--------------------
      1.1 |    100 | a    |                 10
      1.2 |    100 | a    |                 10
      1.3 |    100 | a    |                 10
      2.1 |    200 | b    | 14.142135623730951
      3.2 |    200 | b    | 14.142135623730951
      4.3 |    200 | b    | 14.142135623730951
(6 rows)

-- select with order by limit (explain)
--Testcase 98:
EXPLAIN VERBOSE
SELECT abs(value1), abs(value3), sqrt(value2) FROM s3 ORDER BY abs(value3) LIMIT 1;
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=24)
   Output: (abs(value1)), (abs(value3)), (sqrt((value2)::double precision))
   Local server startup cost: 10
   Remote query: SELECT abs(`value1`), abs(`value3`), sqrt(`value2`) FROM `mysql_fdw_regress`.`s3` ORDER BY abs(`value3`) IS NULL ASC, abs(`value3`) ASC LIMIT 1
(4 rows)

-- select with order by limit (result)
--Testcase 99:
SELECT abs(value1), abs(value3), sqrt(value2) FROM s3 ORDER BY abs(value3) LIMIT 1;
         abs         |         abs         | sqrt 
---------------------+---------------------+------
 0.10000000149011612 | 0.10000000149011612 |   10
(1 row)

-- select mixing with non pushdown func (all not pushdown, explain)
--Testcase 100:
EXPLAIN VERBOSE
SELECT abs(value1), sqrt(value2), cosd(id+40) FROM s3;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..202.16 rows=2048 width=24)
   Output: abs(value1), sqrt((value2)::double precision), cosd(((id + 40))::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mixing with non pushdown func (result)
--Testcase 101:
SELECT abs(value1), sqrt(value2), cosd(id+40) FROM s3;
 abs |        sqrt        |        cosd        
-----+--------------------+--------------------
 0.1 |                 10 | 0.7660444431189779
 0.2 |                 10 | 0.7547095802227719
 0.3 |                 10 | 0.7431448254773942
 1.1 | 14.142135623730951 | 0.7313537016191705
 2.2 | 14.142135623730951 | 0.7193398003386511
 3.3 | 14.142135623730951 | 0.7071067811865475
(6 rows)

-- select conv (stub function, int column, explain)
--Testcase 102:
EXPLAIN VERBOSE
SELECT conv(id, 10, 2), id FROM s3 WHERE value2 != 100 ORDER BY id, conv(id, 10, 2);
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=36)
   Output: conv(id, 10, 2), id
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 100)) ORDER BY `id` IS NULL ASC, `id` ASC, conv(`id`, 10, 2) IS NULL ASC, conv(`id`, 10, 2) ASC
(4 rows)

-- select conv (stub function, int column, result)
--Testcase 103:
SELECT conv(id, 10, 2), id FROM s3 WHERE value2 != 100 ORDER BY id, conv(id, 10, 2);
ERROR:  stub conv(anyelement, int, int) is called
CONTEXT:  PL/pgSQL function conv(anyelement,integer,integer) line 3 at RAISE
-- select conv (stub function, text column, explain)
--Testcase 104:
EXPLAIN VERBOSE
SELECT conv(str1, 18, 8), str1 FROM s3 WHERE value2 != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..161.01 rows=1455 width=64)
   Output: conv(str1, 18, 8), str1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select conv (stub function, text column, result)
--Testcase 105:
SELECT conv(str1, 18, 8), str1 FROM s3 WHERE value2 != 200;
ERROR:  stub conv(text, int, int) is called
CONTEXT:  PL/pgSQL function conv(text,integer,integer) line 3 at RAISE
-- select conv (stub function, const integer, explain)
--Testcase 106:
EXPLAIN VERBOSE
SELECT conv(15, 16, 3), tag1 FROM s3 WHERE value2 != 200 LIMIT 1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=64)
   Output: (conv(15, 16, 3)), tag1
   Local server startup cost: 10
   Remote query: SELECT conv(15, 16, 3), `tag1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200)) LIMIT 1
(4 rows)

-- select conv (stub function, const integer, result)
--Testcase 107:
SELECT conv(15, 16, 3), tag1 FROM s3 WHERE value2 != 200 LIMIT 1;
 conv | tag1 
------+------
 210  | a
(1 row)

-- select conv (stub function, const text, explain)
--Testcase 108:
EXPLAIN VERBOSE
SELECT conv('6hE', 30, -9), str2 FROM s3 WHERE value2 != 200 LIMIT 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=64)
   Output: (conv('6hE'::text, 30, '-9'::integer)), str2
   Local server startup cost: 10
   Remote query: SELECT conv('6hE', 30, (-9)), `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200)) LIMIT 1
(4 rows)

-- select conv (stub function, const text, explain)
--Testcase 109:
SELECT conv('6hE', 30, -9), str2 FROM s3 WHERE value2 != 200 LIMIT 1;
 conv |   str2    
------+-----------
 8112 |    XYZ   
(1 row)

-- select conv (stub function, calculate, explain)
--Testcase 110:
EXPLAIN VERBOSE
SELECT conv(value2 + '10', 10, 10), value2 FROM s3 WHERE value2 != 50;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..219.31 rows=2910 width=36)
   Output: conv((value2 + 10), 10, 10), value2
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 50))
(4 rows)

-- select conv (stub function, calculate, explain)
--Testcase 111:
SELECT conv(value2 + '10', 10, 10), value2 FROM s3 WHERE value2 != 50;
ERROR:  stub conv(anyelement, int, int) is called
CONTEXT:  PL/pgSQL function conv(anyelement,integer,integer) line 3 at RAISE
-- conv() in where clause
-- where conv (stub function, int column, explain)
--Testcase 112:
EXPLAIN VERBOSE
SELECT * FROM s3 WHERE conv(value2,10,20) = '50';
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..118.36 rows=3 width=124)
   Output: id, tag1, value1, value2, value3, value4, str1, str2
   Local server startup cost: 10
   Remote query: SELECT `id`, `tag1`, `value1`, `value2`, `value3`, `value4`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((conv(`value2`, 10, 20) = '50'))
(4 rows)

-- where conv (stub function, int column, result)
--Testcase 113:
SELECT * FROM s3 WHERE conv(value2,10,20) = '50';
 id | tag1 | value1 | value2 | value3 | value4 |   str1    |   str2    
----+------+--------+--------+--------+--------+-----------+-----------
  0 | a    |    0.1 |    100 |   -0.1 |   -100 | ---XYZ--- |    XYZ   
  1 | a    |    0.2 |    100 |   -0.2 |   -100 | ---XYZ--- |    XYZ   
  2 | a    |    0.3 |    100 |   -0.3 |   -100 | ---XYZ--- |    XYZ   
(3 rows)

-- where conv (stub function, int column, explain)
--Testcase 114:
EXPLAIN VERBOSE
SELECT * FROM s3 WHERE conv(value2,10,20) != str1;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.30 rows=550 width=124)
   Output: id, tag1, value1, value2, value3, value4, str1, str2
   Local server startup cost: 10
   Remote query: SELECT `id`, `tag1`, `value1`, `value2`, `value3`, `value4`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((conv(`value2`, 10, 20) <> `str1`))
(4 rows)

-- where conv (stub function, int column, result)
--Testcase 115:
SELECT * FROM s3 WHERE conv(value2,10,20) != str1;
 id | tag1 | value1 | value2 | value3 | value4 |   str1    |   str2    
----+------+--------+--------+--------+--------+-----------+-----------
  0 | a    |    0.1 |    100 |   -0.1 |   -100 | ---XYZ--- |    XYZ   
  1 | a    |    0.2 |    100 |   -0.2 |   -100 | ---XYZ--- |    XYZ   
  2 | a    |    0.3 |    100 |   -0.3 |   -100 | ---XYZ--- |    XYZ   
  3 | b    |    1.1 |    200 |   -1.1 |   -200 | ---XYZ--- |    XYZ   
  4 | b    |    2.2 |    200 |   -2.2 |   -200 | ---XYZ--- |    XYZ   
  5 | b    |    3.3 |    200 |   -3.3 |   -200 | ---XYZ--- |    XYZ   
(6 rows)

-- order by conv  (stub function, int column)
-- select conv (stub function, text column, explain)
--Testcase 116:
EXPLAIN VERBOSE
SELECT conv(str1, 18, 8), str1 FROM s3 WHERE value2 != 200 ORDER BY 1;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=64)
   Output: conv(str1, 18, 8), str1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200)) ORDER BY conv(`str1`, 18, 8) IS NULL ASC, conv(`str1`, 18, 8) ASC
(4 rows)

-- select conv (stub function, text column, result)
--Testcase 117:
SELECT conv(str1, 18, 8), str1 FROM s3 WHERE value2 != 200 ORDER BY 1;
ERROR:  stub conv(text, int, int) is called
CONTEXT:  PL/pgSQL function conv(text,integer,integer) line 3 at RAISE
-- select crc32 (stub function, int column, explain)
--Testcase 118:
EXPLAIN VERBOSE
SELECT crc32(id), id FROM s3 WHERE value2 != 100 ORDER BY id, crc32(id);
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: crc32(id), id
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 100)) ORDER BY `id` IS NULL ASC, `id` ASC, crc32(`id`) IS NULL ASC, crc32(`id`) ASC
(4 rows)

-- select crc32 (stub function, int column, result)
--Testcase 119:
SELECT crc32(id), id FROM s3 WHERE value2 != 100 ORDER BY id, crc32(id);
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 (stub function, int column, explain)
--Testcase 120:
EXPLAIN VERBOSE
SELECT crc32(id), id FROM s3 WHERE value2 = 100 ORDER BY id, crc32(id);
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: crc32(id), id
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` = 100)) ORDER BY `id` IS NULL ASC, `id` ASC, crc32(`id`) IS NULL ASC, crc32(`id`) ASC
(4 rows)

-- select crc32 (stub function, int column, result)
--Testcase 121:
SELECT crc32(id), id FROM s3 WHERE value2 = 100 ORDER BY id, crc32(id);
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 (stub function, text column, explain)
--Testcase 122:
EXPLAIN VERBOSE
SELECT crc32(str1), str1 FROM s3 WHERE value2 != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..161.01 rows=1455 width=40)
   Output: crc32(str1), str1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select crc32 (stub function, text column, result)
--Testcase 123:
SELECT crc32(str1), str1 FROM s3 WHERE value2 != 200;
ERROR:  stub crc32(text) is called
CONTEXT:  PL/pgSQL function crc32(text) line 3 at RAISE
-- select crc32 (stub function, const integer, explain)
--Testcase 124:
EXPLAIN VERBOSE
SELECT crc32(15), tag1 FROM s3 WHERE value2 != 200 LIMIT 1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=40)
   Output: (crc32(15)), tag1
   Local server startup cost: 10
   Remote query: SELECT crc32(15), `tag1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200)) LIMIT 1
(4 rows)

-- select crc32 (stub function, const integer, result)
--Testcase 125:
SELECT crc32(15), tag1 FROM s3 WHERE value2 != 200 LIMIT 1;
   crc32    | tag1 
------------+------
 3510096238 | a
(1 row)

-- select crc32 (stub function, const text, explain)
--Testcase 126:
EXPLAIN VERBOSE
SELECT crc32('6hE'), str2 FROM s3 WHERE value2 != 200 LIMIT 1;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=40)
   Output: (crc32('6hE'::text)), str2
   Local server startup cost: 10
   Remote query: SELECT crc32('6hE'), `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200)) LIMIT 1
(4 rows)

-- select crc32 (stub function, const text, explain)
--Testcase 127:
SELECT crc32('6hE'), str2 FROM s3 WHERE value2 != 200 LIMIT 1;
   crc32    |   str2    
------------+-----------
 1949635712 |    XYZ   
(1 row)

-- select crc32 (stub function, calculate, explain)
--Testcase 128:
EXPLAIN VERBOSE
SELECT crc32(value2 + '10'), value2 FROM s3 WHERE value2 != 50;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..219.31 rows=2910 width=12)
   Output: crc32((value2 + 10)), value2
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 50))
(4 rows)

-- select crc32 (stub function, calculate, explain)
--Testcase 129:
SELECT crc32(value2 + '10'), value2 FROM s3 WHERE value2 != 50;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 (builtin function, explain)
--Testcase 130:
EXPLAIN VERBOSE
SELECT value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..178.24 rows=1706 width=40)
   Output: value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select crc32 (builtin function, result)
--Testcase 131:
SELECT value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 (builtin function, not pushdown constraints, explain)
--Testcase 132:
EXPLAIN VERBOSE
SELECT crc32(value1), crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.88 rows=9 width=40)
   Output: crc32(value1), crc32(value2), crc32(value3), crc32(value4), crc32(0.5)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select crc32 (builtin function, not pushdown constraints, result)
--Testcase 133:
SELECT crc32(value1), crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 (builtin function, pushdown constraints, explain)
--Testcase 134:
EXPLAIN VERBOSE
SELECT crc32(value1), crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3 WHERE value2 != 200;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.48 rows=1697 width=40)
   Output: crc32(value1), crc32(value2), crc32(value3), crc32(value4), crc32(0.5)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select crc32 (builtin function, pushdown constraints, result)
--Testcase 135:
SELECT crc32(value1), crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3 WHERE value2 != 200;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 (builtin function, crc32 in constraints, explain)
--Testcase 136:
EXPLAIN VERBOSE
SELECT value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3 WHERE crc32(value1) != 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.50 rows=1697 width=40)
   Output: value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((crc32(`value1`) <> 1))
(4 rows)

-- select crc32 (builtin function, crc32 in constraints, result)
--Testcase 137:
SELECT value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3 WHERE crc32(value1) != 1;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 (builtin function, crc32 in constraints, explain)
--Testcase 138:
EXPLAIN VERBOSE
SELECT value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3 WHERE crc32(0.5) > value1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..156.93 rows=569 width=40)
   Output: value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((crc32(0.5) > `value1`))
(4 rows)

-- select crc32 (builtin function, crc32 in constraints, result)
--Testcase 139:
SELECT value1, crc32(value2), crc32(value3), crc32(value4), crc32(0.5) FROM s3 WHERE crc32(0.5) > value1;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 as nest function with agg (pushdown, explain)
--Testcase 140:
EXPLAIN VERBOSE
SELECT sum(value3),crc32(sum(value3)) FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (crc32(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), crc32(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select crc32 as nest function with agg (pushdown, result)
--Testcase 141:
SELECT sum(value3),crc32(sum(value3)) FROM s3;
        sum         |   crc32   
--------------------+-----------
 -7.200000040233135 | 907837819
(1 row)

-- select crc32 as nest with log2 (pushdown, explain)
--Testcase 142:
EXPLAIN VERBOSE
SELECT value1, crc32(log2(value1)),crc32(log2(1/value1)) FROM s3;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, crc32(log2(value1)), crc32(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select crc32 as nest with log2 (pushdown, result)
--Testcase 143:
SELECT value1, crc32(log2(value1)),crc32(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select crc32 with non pushdown func and explicit conscrc32t (explain)
--Testcase 144:
EXPLAIN VERBOSE
SELECT value1, crc32(value3), pi(), 4.1 FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..176.56 rows=2048 width=56)
   Output: value1, crc32(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select crc32 with non pushdown func and explicit conscrc32t (result)
--Testcase 145:
SELECT value1, crc32(value3), pi(), 4.1 FROM s3;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 with order by (explain)
--Testcase 146:
EXPLAIN VERBOSE
SELECT value3, crc32(1-value3) FROM s3 ORDER BY crc32(1-value3);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value3, crc32(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY crc32((1 - `value3`)) IS NULL ASC, crc32((1 - `value3`)) ASC
(4 rows)

-- select crc32 with order by (result)
--Testcase 147:
SELECT value3, crc32(1-value3) FROM s3 ORDER BY crc32(1-value3);
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 with order by index (result)
--Testcase 148:
SELECT value3, crc32(1-value3) FROM s3 ORDER BY 2,1;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 with order by index (result)
--Testcase 149:
SELECT value3, crc32(1-value3) FROM s3 ORDER BY 1,2;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select crc32 with group by (explain)
--Testcase 150:
EXPLAIN VERBOSE
SELECT value1, crc32(1-value3) FROM s3 GROUP BY value1, crc32(1-value3);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=16)
   Output: value1, (crc32(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, crc32((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select crc32 with group by (result)
--Testcase 151:
SELECT value1, crc32(1-value3) FROM s3 GROUP BY value1, crc32(1-value3);
 value1 |   crc32    
--------+------------
    0.1 | 4080077135
    0.2 |  313124613
    0.3 | 2649881391
    1.1 | 3134819062
    2.2 | 3277450652
    3.3 | 2982988221
(6 rows)

-- select crc32 with group by index (result)
--Testcase 152:
SELECT value1, crc32(1-value3) FROM s3 GROUP BY 2,1;
 value1 |   crc32    
--------+------------
    0.1 | 4080077135
    0.2 |  313124613
    0.3 | 2649881391
    1.1 | 3134819062
    2.2 | 3277450652
    3.3 | 2982988221
(6 rows)

-- select crc32 with group by index (result)
--Testcase 153:
SELECT value1, crc32(1-value3) FROM s3 GROUP BY 1,2;
 value1 |   crc32    
--------+------------
    0.1 | 4080077135
    0.2 |  313124613
    0.3 | 2649881391
    1.1 | 3134819062
    2.2 | 3277450652
    3.3 | 2982988221
(6 rows)

-- select crc32 with group by having (explain)
--Testcase 154:
EXPLAIN VERBOSE
SELECT value1, crc32(1-value3) FROM s3 GROUP BY value1, crc32(1-value3) HAVING avg(value1) > 0;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=16)
   Output: value1, (crc32(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, crc32((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select crc32 with group by having (result)
--Testcase 155:
SELECT value1, crc32(1-value3) FROM s3 GROUP BY value1, crc32(1-value3) HAVING avg(value1) > 0;
 value1 |   crc32    
--------+------------
    0.1 | 4080077135
    0.2 |  313124613
    0.3 | 2649881391
    1.1 | 3134819062
    2.2 | 3277450652
    3.3 | 2982988221
(6 rows)

-- select crc32 with group by index having (result)
--Testcase 156:
SELECT value3, crc32(1-value3) FROM s3 GROUP BY 1,2 HAVING value3 > 1;
 value3 | crc32 
--------+-------
(0 rows)

-- select crc32 and as
--Testcase 157:
SELECT value1, crc32(value3) as crc321 FROM s3;
ERROR:  stub crc32(anyelement) is called
CONTEXT:  PL/pgSQL function crc32(anyelement) line 3 at RAISE
-- select log10 (builtin function, explain)
--Testcase 158:
EXPLAIN VERBOSE
SELECT log10(value1), log10(value2), log10(0.5) FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.31 rows=2275 width=48)
   Output: log10(value1), log10((value2)::double precision), '-0.3010299956639812'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log10 (builtin function, result)
--Testcase 159:
SELECT log10(value1), log10(value2), log10(0.5) FROM s3;
        log10        |       log10        |        log10        
---------------------+--------------------+---------------------
                  -1 |                  2 | -0.3010299956639812
 -0.6989700043360187 |                  2 | -0.3010299956639812
 -0.5228787452803376 |                  2 | -0.3010299956639812
 0.04139268515822507 | 2.3010299956639813 | -0.3010299956639812
  0.3424226808222063 | 2.3010299956639813 | -0.3010299956639812
  0.5185139398778874 | 2.3010299956639813 | -0.3010299956639812
(6 rows)

-- select log10 (builtin function, not pushdown constraints, explain)
--Testcase 160:
EXPLAIN VERBOSE
SELECT log10(value1), log10(value2), log10(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..144.43 rows=11 width=48)
   Output: log10(value1), log10((value2)::double precision), '-0.3010299956639812'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select log10 (builtin function, not pushdown constraints, result)
--Testcase 161:
SELECT log10(value1), log10(value2), log10(0.5) FROM s3 WHERE to_hex(value2) = '64';
        log10        | log10 |        log10        
---------------------+-------+---------------------
                  -1 |     2 | -0.3010299956639812
 -0.6989700043360187 |     2 | -0.3010299956639812
 -0.5228787452803376 |     2 | -0.3010299956639812
(3 rows)

-- select log10 (builtin function, pushdown constraints, explain)
--Testcase 162:
EXPLAIN VERBOSE
SELECT log10(value1), log10(value2), log10(0.5) FROM s3 WHERE value2 != 200;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..200.70 rows=2264 width=48)
   Output: log10(value1), log10((value2)::double precision), '-0.3010299956639812'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select log10 (builtin function, pushdown constraints, result)
--Testcase 163:
SELECT log10(value1), log10(value2), log10(0.5) FROM s3 WHERE value2 != 200;
        log10        | log10 |        log10        
---------------------+-------+---------------------
                  -1 |     2 | -0.3010299956639812
 -0.6989700043360187 |     2 | -0.3010299956639812
 -0.5228787452803376 |     2 | -0.3010299956639812
(3 rows)

-- select log10 (builtin function, log10 in constraints, explain)
--Testcase 164:
EXPLAIN VERBOSE
SELECT log10(value1), log10(value2), log10(0.5) FROM s3 WHERE log10(value1) != 1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..206.38 rows=2264 width=48)
   Output: log10(value1), log10((value2)::double precision), '-0.3010299956639812'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((log10(`value1`) <> 1))
(4 rows)

-- select log10 (builtin function, log10 in constraints, result)
--Testcase 165:
SELECT log10(value1), log10(value2), log10(0.5) FROM s3 WHERE log10(value1) != 1;
        log10        |       log10        |        log10        
---------------------+--------------------+---------------------
                  -1 |                  2 | -0.3010299956639812
 -0.6989700043360187 |                  2 | -0.3010299956639812
 -0.5228787452803376 |                  2 | -0.3010299956639812
 0.04139268515822507 | 2.3010299956639813 | -0.3010299956639812
  0.3424226808222063 | 2.3010299956639813 | -0.3010299956639812
  0.5185139398778874 | 2.3010299956639813 | -0.3010299956639812
(6 rows)

-- select log10 (builtin function, log10 in constraints, explain)
--Testcase 166:
EXPLAIN VERBOSE
SELECT log10(value1), log10(value2), log10(0.5) FROM s3 WHERE log10(0.5) < value1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..159.28 rows=758 width=48)
   Output: log10(value1), log10((value2)::double precision), '-0.3010299956639812'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE (((-0.3010299956639812) < `value1`))
(4 rows)

-- select log10 (builtin function, log10 in constraints, result)
--Testcase 167:
SELECT log10(value1), log10(value2), log10(0.5) FROM s3 WHERE log10(0.5) < value1;
        log10        |       log10        |        log10        
---------------------+--------------------+---------------------
                  -1 |                  2 | -0.3010299956639812
 -0.6989700043360187 |                  2 | -0.3010299956639812
 -0.5228787452803376 |                  2 | -0.3010299956639812
 0.04139268515822507 | 2.3010299956639813 | -0.3010299956639812
  0.3424226808222063 | 2.3010299956639813 | -0.3010299956639812
  0.5185139398778874 | 2.3010299956639813 | -0.3010299956639812
(6 rows)

-- select log10 as nest function with agg (pushdown, explain)
--Testcase 168:
EXPLAIN VERBOSE
SELECT sum(value3),log10(sum(value2)) FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (log10((sum(value2))::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), log10(sum(`value2`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select log10 as nest function with agg (pushdown, result)
--Testcase 169:
SELECT sum(value3),log10(sum(value2)) FROM s3;
        sum         |       log10        
--------------------+--------------------
 -7.200000040233135 | 2.9542425094393248
(1 row)

-- select log10 as nest with log2 (pushdown, explain)
--Testcase 170:
EXPLAIN VERBOSE
SELECT value1, log10(log2(value1)),log10(log2(1/value1)) FROM s3;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, log10(log2(value1)), log10(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log10 as nest with log2 (pushdown, result)
--Testcase 171:
SELECT value1, log10(log2(value1)),log10(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log10 with non pushdown func and explicit constant (explain)
--Testcase 172:
EXPLAIN VERBOSE
SELECT log10(value2), pi(), 4.1 FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2925 width=48)
   Output: log10((value2)::double precision), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log10 with non pushdown func and explicit constant (result)
--Testcase 173:
SELECT log10(value2), pi(), 4.1 FROM s3;
       log10        |        pi         | ?column? 
--------------------+-------------------+----------
                  2 | 3.141592653589793 |      4.1
                  2 | 3.141592653589793 |      4.1
                  2 | 3.141592653589793 |      4.1
 2.3010299956639813 | 3.141592653589793 |      4.1
 2.3010299956639813 | 3.141592653589793 |      4.1
 2.3010299956639813 | 3.141592653589793 |      4.1
(6 rows)

-- select log10 with order by (explain)
--Testcase 174:
EXPLAIN VERBOSE
SELECT value3, log10(1-value3) FROM s3 ORDER BY log10(1-value3);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value3, log10(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY log10((1 - `value3`)) IS NULL ASC, log10((1 - `value3`)) ASC
(4 rows)

-- select log10 with order by (result)
--Testcase 175:
SELECT value3, log10(1-value3) FROM s3 ORDER BY log10(1-value3);
 value3 |        log10        
--------+---------------------
   -0.1 | 0.04139268515822507
   -0.2 | 0.07918124604762482
   -0.3 | 0.11394335230683678
   -1.1 |  0.3222192947339193
   -2.2 |   0.505149978319906
   -3.3 |  0.6334684555795865
(6 rows)

-- select log10 with order by index (result)
--Testcase 176:
SELECT value3, log10(1-value3) FROM s3 ORDER BY 2,1;
 value3 |        log10        
--------+---------------------
   -0.1 | 0.04139268515822507
   -0.2 | 0.07918124604762482
   -0.3 | 0.11394335230683678
   -1.1 |  0.3222192947339193
   -2.2 |   0.505149978319906
   -3.3 |  0.6334684555795865
(6 rows)

-- select log10 with order by index (result)
--Testcase 177:
SELECT value3, log10(1-value3) FROM s3 ORDER BY 1,2;
 value3 |        log10        
--------+---------------------
   -3.3 |  0.6334684555795865
   -2.2 |   0.505149978319906
   -1.1 |  0.3222192947339193
   -0.3 | 0.11394335230683678
   -0.2 | 0.07918124604762482
   -0.1 | 0.04139268515822507
(6 rows)

-- select log10 with group by (explain)
--Testcase 178:
EXPLAIN VERBOSE
SELECT count(value1), log10(1-value3) FROM s3 GROUP BY log10(1-value3);
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (log10(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), log10((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select log10 with group by (result)
--Testcase 179:
SELECT count(value1), log10(1-value3) FROM s3 GROUP BY log10(1-value3);
 count |        log10        
-------+---------------------
     1 |  0.0413926857465425
     1 | 0.07918124712620683
     1 | 0.11394335628929342
     1 | 0.32221929966457985
     1 |   0.505149984791398
     1 |  0.6334684507635924
(6 rows)

-- select log10 with group by index (result)
--Testcase 180:
SELECT value1, log10(1-value3) FROM s3 GROUP BY 2,1;
 value1 |        log10        
--------+---------------------
    0.1 |  0.0413926857465425
    0.2 | 0.07918124712620683
    0.3 | 0.11394335628929342
    1.1 | 0.32221929966457985
    2.2 |   0.505149984791398
    3.3 |  0.6334684507635924
(6 rows)

-- select log10 with group by index (result)
--Testcase 181:
SELECT value1, log10(1-value3) FROM s3 GROUP BY 1,2;
 value1 |        log10        
--------+---------------------
    0.1 |  0.0413926857465425
    0.2 | 0.07918124712620683
    0.3 | 0.11394335628929342
    1.1 | 0.32221929966457985
    2.2 |   0.505149984791398
    3.3 |  0.6334684507635924
(6 rows)

-- select log10 with group by having (explain)
--Testcase 182:
EXPLAIN VERBOSE
SELECT count(value1), log10(1-value3) FROM s3 GROUP BY log10(1-value3) HAVING log10(avg(value1)) > 0;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (log10(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), log10((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((log10(avg(`value1`)) > 0))
(5 rows)

-- select log10 with group by having (result)
--Testcase 183:
SELECT count(value1), log10(1-value3) FROM s3 GROUP BY log10(1-value3) HAVING log10(avg(value1)) > 0;
 count |        log10        
-------+---------------------
     1 | 0.32221929966457985
     1 |   0.505149984791398
     1 |  0.6334684507635924
(3 rows)

-- select log10 with group by index having (result)
--Testcase 184:
SELECT value3, log10(1-value3) FROM s3 GROUP BY 2,1 HAVING log10(1-value3) < 0;
 value3 | log10 
--------+-------
(0 rows)

-- select log10 with group by index having (result)
--Testcase 185:
SELECT value3, log10(1-value3) FROM s3 GROUP BY 1,2 HAVING value3 > 1;
 value3 | log10 
--------+-------
(0 rows)

-- select log10 and as
--Testcase 186:
SELECT value1, log10(value1) as log101 FROM s3;
 value1 |       log101        
--------+---------------------
    0.1 |                  -1
    0.2 | -0.6989700043360187
    0.3 | -0.5228787452803376
    1.1 | 0.04139268515822507
    2.2 |  0.3424226808222063
    3.3 |  0.5185139398778874
(6 rows)

-- select log2 (builtin function, explain)
--Testcase 187:
EXPLAIN VERBOSE
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.30 rows=1706 width=40)
   Output: log2(value1), log2((value2)::double precision), log2((value3 + '1'::double precision)), log2((value4)::double precision), log2('0.5'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log2 (builtin function, result)
--Testcase 188:
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 (builtin function, not pushdown constraints, explain)
--Testcase 189:
EXPLAIN VERBOSE
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.95 rows=9 width=40)
   Output: log2(value1), log2((value2)::double precision), log2((value3 + '1'::double precision)), log2((value4)::double precision), log2('0.5'::double precision)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select log2 (builtin function, not pushdown constraints, result)
--Testcase 190:
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 (builtin function, pushdown constraints, explain)
--Testcase 191:
EXPLAIN VERBOSE
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3 WHERE value2 != 200;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..199.20 rows=1697 width=40)
   Output: log2(value1), log2((value2)::double precision), log2((value3 + '1'::double precision)), log2((value4)::double precision), log2('0.5'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select log2 (builtin function, pushdown constraints, result)
--Testcase 192:
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3 WHERE value2 != 200;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 (builtin function, log2 in constraints, explain)
--Testcase 193:
EXPLAIN VERBOSE
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3 WHERE log2(value1) != 1;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..203.47 rows=1697 width=40)
   Output: log2(value1), log2((value2)::double precision), log2((value3 + '1'::double precision)), log2((value4)::double precision), log2('0.5'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((log2(`value1`) <> 1))
(4 rows)

-- select log2 (builtin function, log2 in constraints, result)
--Testcase 194:
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3 WHERE log2(value1) != 1;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 (builtin function, log2 in constraints, explain)
--Testcase 195:
EXPLAIN VERBOSE
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3 WHERE log2(0.5) < value1;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..158.35 rows=569 width=40)
   Output: log2(value1), log2((value2)::double precision), log2((value3 + '1'::double precision)), log2((value4)::double precision), log2('0.5'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((log2(0.5) < `value1`))
(4 rows)

-- select log2 (builtin function, log2 in constraints, result)
--Testcase 196:
SELECT log2(value1), log2(value2), log2(value3 + 1), log2(value4), log2(0.5) FROM s3 WHERE log2(0.5) < value1;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 as nest function with agg (pushdown, explain)
--Testcase 197:
EXPLAIN VERBOSE
SELECT sum(value3),log2(sum(value3)) FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (log2(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), log2(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select log2 as nest function with agg (pushdown, result)
--Testcase 198:
SELECT sum(value3),log2(sum(value3)) FROM s3;
        sum         | log2 
--------------------+------
 -7.200000040233135 |     
(1 row)

-- select log2 as nest with log2 (pushdown, explain)
--Testcase 199:
EXPLAIN VERBOSE
SELECT value1, log2(log2(value1)),log2(log2(1/value1)) FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, log2(log2(value1)), log2(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log2 as nest with log2 (pushdown, result)
--Testcase 200:
SELECT value1, log2(log2(value1)),log2(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 with non pushdown func and explicit constant (explain)
--Testcase 201:
EXPLAIN VERBOSE
SELECT value1, log2(value3 + 1), pi(), 4.1 FROM s3;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..181.68 rows=2048 width=56)
   Output: value1, log2((value3 + '1'::double precision)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select log2 with non pushdown func and explicit constant (result)
--Testcase 202:
SELECT value1, log2(value3 + 1), pi(), 4.1 FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 with order by (explain)
--Testcase 203:
EXPLAIN VERBOSE
SELECT value3, log2(1-value3) FROM s3 ORDER BY log2(1-value3);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value3, log2(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY log2((1 - `value3`)) IS NULL ASC, log2((1 - `value3`)) ASC
(4 rows)

-- select log2 with order by (result)
--Testcase 204:
SELECT value3, log2(1-value3) FROM s3 ORDER BY log2(1-value3);
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 with order by index (result)
--Testcase 205:
SELECT value3, log2(1-value3) FROM s3 ORDER BY 2,1;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 with order by index (result)
--Testcase 206:
SELECT value3, log2(1-value3) FROM s3 ORDER BY 1,2;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select log2 with group by (explain)
--Testcase 207:
EXPLAIN VERBOSE
SELECT count(value1), log2(1-value3) FROM s3 GROUP BY log2(1-value3);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (log2(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), log2((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select log2 with group by (result)
--Testcase 208:
SELECT count(value1), log2(1-value3) FROM s3 GROUP BY log2(1-value3);
 count |        log2         
-------+---------------------
     1 | 0.13750352570428323
     1 | 0.26303440941676576
     1 | 0.37851163648316444
     1 |   1.070389344270698
     1 |   1.678071926610469
     1 |  2.1043366438163496
(6 rows)

-- select log2 with group by index (result)
--Testcase 209:
SELECT value1, log2(1-value3) FROM s3 GROUP BY 2,1;
 value1 |        log2         
--------+---------------------
    0.1 | 0.13750352570428323
    0.2 | 0.26303440941676576
    0.3 | 0.37851163648316444
    1.1 |   1.070389344270698
    2.2 |   1.678071926610469
    3.3 |  2.1043366438163496
(6 rows)

-- select log2 with group by index (result)
--Testcase 210:
SELECT value1, log2(1-value3) FROM s3 GROUP BY 1,2;
 value1 |        log2         
--------+---------------------
    0.1 | 0.13750352570428323
    0.2 | 0.26303440941676576
    0.3 | 0.37851163648316444
    1.1 |   1.070389344270698
    2.2 |   1.678071926610469
    3.3 |  2.1043366438163496
(6 rows)

-- select log2 with group by having (explain)
--Testcase 211:
EXPLAIN VERBOSE
SELECT count(value1), log2(1-value3) FROM s3 GROUP BY log2(1-value3) HAVING avg(value1) > 0;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (log2(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), log2((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select log2 with group by having (result)
--Testcase 212:
SELECT count(value1), log2(1-value3) FROM s3 GROUP BY log2(1-value3) HAVING avg(value1) > 0;
 count |        log2         
-------+---------------------
     1 | 0.13750352570428323
     1 | 0.26303440941676576
     1 | 0.37851163648316444
     1 |   1.070389344270698
     1 |   1.678071926610469
     1 |  2.1043366438163496
(6 rows)

-- select log2 with group by index having (result)
--Testcase 213:
SELECT value1, log2(1-value1) FROM s3 GROUP BY 1,2 HAVING value1 < 1;
 value1 |         log2         
--------+----------------------
    0.1 | -0.15200309583369792
    0.2 |  -0.3219281002618202
    0.3 |  -0.5145731973987085
(3 rows)

-- select log2 and as (return NULL with negative number)
--Testcase 214:
SELECT value1, value3 + 1, log2(value3 + 1) as log21 FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select pi (builtin function, explain)
--Testcase 215:
EXPLAIN VERBOSE
SELECT pi() FROM s3 WHERE value2 != 200 LIMIT 1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=8)
   Output: '3.141592653589793'::double precision
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200)) LIMIT 1
(4 rows)

-- select pi (builtin function, result)
--Testcase 216:
SELECT pi() FROM s3 WHERE value2 != 200 LIMIT 1;
        pi         
-------------------
 3.141592653589793
(1 row)

-- where pi (builtin function)
--Testcase 217:
EXPLAIN VERBOSE
SELECT id FROM s3 WHERE pi() > id LIMIT 1;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=4)
   Output: id
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s3` WHERE ((3.141592653589793 > `id`)) LIMIT 1
(4 rows)

--Testcase 218:
SELECT id FROM s3 WHERE pi() > id LIMIT 1;
 id 
----
  0
(1 row)

-- select pi (stub function, explain)
--Testcase 219:
EXPLAIN VERBOSE
SELECT mysql_pi() FROM s3 WHERE value2 != 200 LIMIT 1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=8)
   Output: (mysql_pi())
   Local server startup cost: 10
   Remote query: SELECT pi() FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200)) LIMIT 1
(4 rows)

-- select pi (stub function, result)
--Testcase 220:
SELECT mysql_pi() FROM s3 WHERE value2 != 200 LIMIT 1;
 mysql_pi 
----------
 3.141593
(1 row)

-- where pi (stub function)
--Testcase 221:
EXPLAIN VERBOSE
SELECT value1 FROM s3 WHERE mysql_pi() > value1 LIMIT 1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=0.00..0.00 rows=1 width=8)
   Output: value1
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` WHERE ((pi() > `value1`)) LIMIT 1
(4 rows)

--Testcase 222:
SELECT value1 FROM s3 WHERE mysql_pi() > value1 LIMIT 1;
 value1 
--------
    0.1
(1 row)

-- where pi (stub function) order by
--Testcase 223:
EXPLAIN VERBOSE
SELECT value1 FROM s3 WHERE mysql_pi() > value1 ORDER BY 1;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.00 rows=30 width=8)
   Output: value1
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` WHERE ((pi() > `value1`)) ORDER BY `value1` IS NULL ASC, `value1` ASC
(4 rows)

--Testcase 224:
SELECT value1 FROM s3 WHERE mysql_pi() > value1 ORDER BY 1;
 value1 
--------
    0.1
    0.2
    0.3
    1.1
    2.2
(5 rows)

-- slect stub function, order by pi (stub function)
--Testcase 225:
EXPLAIN VERBOSE
SELECT mysql_pi(), log2(value1) FROM s3 ORDER BY 1,2;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: mysql_pi(), log2(value1)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` ORDER BY pi() IS NULL ASC, pi() ASC, log2(`value1`) IS NULL ASC, log2(`value1`) ASC
(4 rows)

--Testcase 226:
SELECT mysql_pi(), log2(value1) FROM s3 ORDER BY 1,2;
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select pow (builtin function, explain)
--Testcase 227:
EXPLAIN VERBOSE
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=32)
   Output: pow(value1, '2'::double precision), pow((value2)::double precision, '2'::double precision), pow(value3, '2'::double precision), pow((value4)::double precision, '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select pow (builtin function, result)
--Testcase 228:
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3;
         pow          |  pow  |         pow          |  pow  
----------------------+-------+----------------------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000
                 0.09 | 10000 |                 0.09 | 10000
   1.2100000000000002 | 40000 |   1.2100000000000002 | 40000
    4.840000000000001 | 40000 |    4.840000000000001 | 40000
   10.889999999999999 | 40000 |   10.889999999999999 | 40000
(6 rows)

-- select pow (builtin function, not pushdown constraints, explain)
--Testcase 229:
EXPLAIN VERBOSE
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 WHERE to_hex(value2) != '64';
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=32)
   Output: pow(value1, '2'::double precision), pow((value2)::double precision, '2'::double precision), pow(value3, '2'::double precision), pow((value4)::double precision, '2'::double precision)
   Filter: (to_hex(s3.value2) <> '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select pow (builtin function, not pushdown constraints, result)
--Testcase 230:
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 WHERE to_hex(value2) != '64';
        pow         |  pow  |        pow         |  pow  
--------------------+-------+--------------------+-------
 1.2100000000000002 | 40000 | 1.2100000000000002 | 40000
  4.840000000000001 | 40000 |  4.840000000000001 | 40000
 10.889999999999999 | 40000 | 10.889999999999999 | 40000
(3 rows)

-- select pow (builtin function, pushdown constraints, explain)
--Testcase 231:
EXPLAIN VERBOSE
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 WHERE value2 != 200;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=32)
   Output: pow(value1, '2'::double precision), pow((value2)::double precision, '2'::double precision), pow(value3, '2'::double precision), pow((value4)::double precision, '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select pow (builtin function, pushdown constraints, result)
--Testcase 232:
SELECT pow(value1, 2), pow(value2, 2), pow(value3, 2), pow(value4, 2) FROM s3 WHERE value2 != 200;
         pow          |  pow  |         pow          |  pow  
----------------------+-------+----------------------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000
                 0.09 | 10000 |                 0.09 | 10000
(3 rows)

-- select pow as nest function with agg (pushdown, explain)
--Testcase 233:
EXPLAIN VERBOSE
SELECT sum(value3),pow(sum(value3), 2) FROM s3;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (pow(sum(value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), pow(sum(`value3`), 2) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select pow as nest function with agg (pushdown, result)
--Testcase 234:
SELECT sum(value3),pow(sum(value3), 2) FROM s3;
        sum         |        pow        
--------------------+-------------------
 -7.200000040233135 | 51.84000057935715
(1 row)

-- select pow as nest with log2 (pushdown, explain)
--Testcase 235:
EXPLAIN VERBOSE
SELECT value1, pow(log2(value1), 2),pow(log2(1/value1), 2) FROM s3;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, pow(log2(value1), '2'::double precision), pow(log2(('1'::double precision / value1)), '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select pow as nest with log2 (pushdown, result)
--Testcase 236:
SELECT value1, pow(log2(value1), 2),pow(log2(1/value1), 2) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select pow with non pushdown func and explicit constant (explain)
--Testcase 237:
EXPLAIN VERBOSE
SELECT pow(value3, 2), pi(), 4.1 FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: pow(value3, '2'::double precision), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select pow with non pushdown func and explicit constant (result)
--Testcase 238:
SELECT pow(value3, 2), pi(), 4.1 FROM s3;
         pow          |        pi         | ?column? 
----------------------+-------------------+----------
 0.010000000000000002 | 3.141592653589793 |      4.1
  0.04000000000000001 | 3.141592653589793 |      4.1
                 0.09 | 3.141592653589793 |      4.1
   1.2100000000000002 | 3.141592653589793 |      4.1
    4.840000000000001 | 3.141592653589793 |      4.1
   10.889999999999999 | 3.141592653589793 |      4.1
(6 rows)

-- select pow with order by (explain)
--Testcase 239:
EXPLAIN VERBOSE
SELECT value3, pow(1-value3, 2) FROM s3 ORDER BY pow(1-value3, 2);
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value3, pow(('1'::double precision - value3), '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY pow((1 - `value3`), 2) IS NULL ASC, pow((1 - `value3`), 2) ASC
(4 rows)

-- select pow with order by (result)
--Testcase 240:
SELECT value3, pow(1-value3, 2) FROM s3 ORDER BY pow(1-value3, 2);
 value3 |        pow         
--------+--------------------
   -0.1 | 1.2100000000000002
   -0.2 |               1.44
   -0.3 | 1.6900000000000002
   -1.1 |               4.41
   -2.2 | 10.240000000000002
   -3.3 |              18.49
(6 rows)

-- select pow with order by index (result)
--Testcase 241:
SELECT value3, pow(1-value3, 2) FROM s3 ORDER BY 2,1;
 value3 |        pow         
--------+--------------------
   -0.1 | 1.2100000000000002
   -0.2 |               1.44
   -0.3 | 1.6900000000000002
   -1.1 |               4.41
   -2.2 | 10.240000000000002
   -3.3 |              18.49
(6 rows)

-- select pow with order by index (result)
--Testcase 242:
SELECT value3, pow(1-value3, 2) FROM s3 ORDER BY 1,2;
 value3 |        pow         
--------+--------------------
   -3.3 |              18.49
   -2.2 | 10.240000000000002
   -1.1 |               4.41
   -0.3 | 1.6900000000000002
   -0.2 |               1.44
   -0.1 | 1.2100000000000002
(6 rows)

-- select pow and as
--Testcase 243:
SELECT pow(value3, 2) as pow1 FROM s3;
         pow1         
----------------------
 0.010000000000000002
  0.04000000000000001
                 0.09
   1.2100000000000002
    4.840000000000001
   10.889999999999999
(6 rows)

-- We only test rand with constant and column because it will be stable
-- select rand (stub function, rand with column, explain)
--Testcase 244:
EXPLAIN VERBOSE
SELECT id, rand(id), rand(3) FROM s3 WHERE value2 != 200;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..226.59 rows=2910 width=20)
   Output: id, rand((id)::double precision), rand('3'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select rand (stub function, rand with column, result)
--Testcase 245:
SELECT id, rand(id), rand(3) FROM s3 WHERE value2 != 200;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- rand() in WHERE clause only EXPLAIN, execute will return different result
--Testcase 246:
EXPLAIN VERBOSE
SELECT id, rand(id), rand(3), rand() FROM s3 WHERE rand() > 0.5;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..183.12 rows=975 width=28)
   Output: id, rand((id)::double precision), rand('3'::double precision), rand()
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s3` WHERE ((rand() > 0.5))
(4 rows)

-- select rand (stub function, explain)
--Testcase 247:
EXPLAIN VERBOSE
SELECT value1, rand(value1), rand(value2), rand(value3), rand(value4) FROM s3;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=40)
   Output: value1, rand(value1), rand((value2)::double precision), rand(value3), rand((value4)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select rand (stub function, result)
--Testcase 248:
SELECT value1, rand(value1), rand(value2), rand(value3), rand(value4) FROM s3;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand (stub function, not pushdown constraints, explain)
--Testcase 249:
EXPLAIN VERBOSE
SELECT rand(value1), rand(value2), rand(value3), rand(value4), rand(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.93 rows=9 width=40)
   Output: rand(value1), rand((value2)::double precision), rand(value3), rand((value4)::double precision), rand('0.5'::double precision)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select rand (stub function, not pushdown constraints, result)
--Testcase 250:
SELECT rand(value1), rand(value2), rand(value3), rand(value4), rand(0.5) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand (stub function, pushdown constraints, explain)
--Testcase 251:
EXPLAIN VERBOSE
SELECT rand(value1), rand(value2), rand(value3), rand(value4), rand(0.5) FROM s3 WHERE value2 != 200;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.96 rows=1697 width=40)
   Output: rand(value1), rand((value2)::double precision), rand(value3), rand((value4)::double precision), rand('0.5'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select rand (stub function, pushdown constraints, result)
--Testcase 252:
SELECT rand(value1), rand(value2), rand(value3), rand(value4), rand(0.5) FROM s3 WHERE value2 != 200;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand (stub function, rand in constraints, explain)
--Testcase 253:
EXPLAIN VERBOSE
SELECT value1, rand(value1), rand(value2), rand(value3), rand(value4) FROM s3 WHERE rand(value1) != 1;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=40)
   Output: value1, rand(value1), rand((value2)::double precision), rand(value3), rand((value4)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((rand(`value1`) <> 1))
(4 rows)

-- select rand (stub function, rand in constraints, result)
--Testcase 254:
SELECT value1, rand(value1), rand(value2), rand(value3), rand(value4) FROM s3 WHERE rand(value1) != 1;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand (stub function, rand in constraints, explain)
--Testcase 255:
EXPLAIN VERBOSE
SELECT value1, rand(value1), rand(value2), rand(value3), rand(value4) FROM s3 WHERE rand(0.5) > value1 - 1;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..159.77 rows=569 width=40)
   Output: value1, rand(value1), rand((value2)::double precision), rand(value3), rand((value4)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((rand(0.5) > (`value1` - 1)))
(4 rows)

-- select rand (stub function, rand in constraints, result)
--Testcase 256:
SELECT value1, rand(value1), rand(value2), rand(value3), rand(value4) FROM s3 WHERE rand(0.5) > value1 - 1;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand as nest function with agg (pushdown, explain)
--Testcase 257:
EXPLAIN VERBOSE
SELECT sum(value3),rand(sum(value3)) FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (rand(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), rand(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select rand as nest function with agg (pushdown, result)
--Testcase 258:
SELECT sum(value3),rand(sum(value3)) FROM s3;
        sum         |        rand        
--------------------+--------------------
 -7.200000040233135 | 0.4039386654309357
(1 row)

-- select rand as nest with log2 (pushdown, explain)
--Testcase 259:
EXPLAIN VERBOSE
SELECT value1, rand(log2(value1)),rand(log2(1/value1)) FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, rand(log2(value1)), rand(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select rand as nest with log2 (pushdown, result)
--Testcase 260:
SELECT value1, rand(log2(value1)),rand(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select rand with non pushdown func and explicit constant (explain)
--Testcase 261:
EXPLAIN VERBOSE
SELECT value1, rand(value3), pi(), 4.1 FROM s3;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..176.56 rows=2048 width=56)
   Output: value1, rand(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select rand with non pushdown func and explicit constant (result)
--Testcase 262:
SELECT value1, rand(value3), pi(), 4.1 FROM s3;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand with order by (explain)
--Testcase 263:
EXPLAIN VERBOSE
SELECT value3, rand(1-value3) FROM s3 ORDER BY rand(1-value3);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value3, rand(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY rand((1 - `value3`)) IS NULL ASC, rand((1 - `value3`)) ASC
(4 rows)

-- select rand with order by (result)
--Testcase 264:
SELECT value3, rand(1-value3) FROM s3 ORDER BY rand(1-value3);
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand with order by index (result)
--Testcase 265:
SELECT value3, rand(1-value3) FROM s3 ORDER BY 2,1;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand with order by index (result)
--Testcase 266:
SELECT value3, rand(1-value3) FROM s3 ORDER BY 1,2;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select rand with group by (explain)
--Testcase 267:
EXPLAIN VERBOSE
SELECT value1, rand(1-value3) FROM s3 GROUP BY value1, rand(1-value3);
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=16)
   Output: value1, (rand(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, rand((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select rand with group by (result)
--Testcase 268:
SELECT value1, rand(1-value3) FROM s3 GROUP BY value1, rand(1-value3);
 value1 |        rand         
--------+---------------------
    0.1 | 0.40540353712197724
    0.2 | 0.40540353712197724
    0.3 | 0.40540353712197724
    1.1 |  0.6555866465490187
    2.2 |  0.9057697559760601
    3.3 | 0.15595286540310166
(6 rows)

-- select rand with group by index (result)
--Testcase 269:
SELECT value1, rand(1-value3) FROM s3 GROUP BY 2,1;
 value1 |        rand         
--------+---------------------
    0.1 | 0.40540353712197724
    0.2 | 0.40540353712197724
    0.3 | 0.40540353712197724
    1.1 |  0.6555866465490187
    2.2 |  0.9057697559760601
    3.3 | 0.15595286540310166
(6 rows)

-- select rand with group by index (result)
--Testcase 270:
SELECT value1, rand(1-value3) FROM s3 GROUP BY 1,2;
 value1 |        rand         
--------+---------------------
    0.1 | 0.40540353712197724
    0.2 | 0.40540353712197724
    0.3 | 0.40540353712197724
    1.1 |  0.6555866465490187
    2.2 |  0.9057697559760601
    3.3 | 0.15595286540310166
(6 rows)

-- select rand with group by having (explain)
--Testcase 271:
EXPLAIN VERBOSE
SELECT value1, rand(1-value3) FROM s3 GROUP BY value1, rand(1-value3) HAVING avg(value1) > 0;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=16)
   Output: value1, (rand(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, rand((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select rand with group by having (result)
--Testcase 272:
SELECT value1, rand(1-value3) FROM s3 GROUP BY value1, rand(1-value3) HAVING avg(value1) > 0;
 value1 |        rand         
--------+---------------------
    0.1 | 0.40540353712197724
    0.2 | 0.40540353712197724
    0.3 | 0.40540353712197724
    1.1 |  0.6555866465490187
    2.2 |  0.9057697559760601
    3.3 | 0.15595286540310166
(6 rows)

-- select rand with group by index having (result)
--Testcase 273:
SELECT value1, rand(1-value1) FROM s3 GROUP BY 1,2 HAVING value1 < 1;
 value1 |        rand         
--------+---------------------
    0.1 | 0.40540353712197724
    0.2 | 0.40540353712197724
    0.3 | 0.40540353712197724
(3 rows)

-- select rand and as
--Testcase 274:
SELECT value1, rand(value3) as rand1 FROM s3;
ERROR:  stub rand(float8) is called
CONTEXT:  PL/pgSQL function rand(double precision) line 3 at RAISE
-- select truncate (stub function, explain)
--Testcase 275:
EXPLAIN VERBOSE
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..191.03 rows=1706 width=40)
   Output: truncate(value1, 2), truncate((value2)::double precision, 2), truncate(value3, 2), truncate((value4)::double precision, 2), truncate('5'::double precision, 2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select truncate (stub function, result)
--Testcase 276:
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3;
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate (stub function, not pushdown constraints, explain)
--Testcase 277:
EXPLAIN VERBOSE
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3 WHERE to_hex(value2) = '64';
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.93 rows=9 width=40)
   Output: truncate(value1, 2), truncate((value2)::double precision, 2), truncate(value3, 2), truncate((value4)::double precision, 2), truncate('5'::double precision, 2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select truncate (stub function, not pushdown constraints, result)
--Testcase 278:
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate (stub function, pushdown constraints, explain)
--Testcase 279:
EXPLAIN VERBOSE
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3 WHERE value2 != 200;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.96 rows=1697 width=40)
   Output: truncate(value1, 2), truncate((value2)::double precision, 2), truncate(value3, 2), truncate((value4)::double precision, 2), truncate('5'::double precision, 2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select truncate (stub function, pushdown constraints, result)
--Testcase 280:
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3 WHERE value2 != 200;
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate (stub function, truncate in constraints, explain)
--Testcase 281:
EXPLAIN VERBOSE
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3 WHERE truncate(value1, 2) != 1;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..199.23 rows=1697 width=40)
   Output: truncate(value1, 2), truncate((value2)::double precision, 2), truncate(value3, 2), truncate((value4)::double precision, 2), truncate('5'::double precision, 2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((truncate(`value1`, 2) <> 1))
(4 rows)

-- select truncate (stub function, truncate in constraints, result)
--Testcase 282:
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3 WHERE truncate(value1, 2) != 1;
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate (stub function, truncate in constraints, explain)
--Testcase 283:
EXPLAIN VERBOSE
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3 WHERE truncate(5, 2) > value1;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..156.93 rows=569 width=40)
   Output: truncate(value1, 2), truncate((value2)::double precision, 2), truncate(value3, 2), truncate((value4)::double precision, 2), truncate('5'::double precision, 2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((truncate(5, 2) > `value1`))
(4 rows)

-- select truncate (stub function, truncate in constraints, result)
--Testcase 284:
SELECT truncate(value1, 2), truncate(value2, 2), truncate(value3, 2), truncate(value4, 2), truncate(5, 2) FROM s3 WHERE truncate(5, 2) > value1;
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate as nest function with agg (pushdown, explain)
--Testcase 285:
EXPLAIN VERBOSE
SELECT sum(value3),truncate(sum(value3), 2) FROM s3;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (truncate(sum(value3), 2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), truncate(sum(`value3`), 2) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select truncate as nest function with agg (pushdown, result)
--Testcase 286:
SELECT sum(value3),truncate(sum(value3), 2) FROM s3;
        sum         | truncate 
--------------------+----------
 -7.200000040233135 |     -7.2
(1 row)

-- select truncate as nest with log2 (pushdown, explain)
--Testcase 287:
EXPLAIN VERBOSE
SELECT truncate(log2(value1), 2),truncate(log2(1/value1), 2) FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: truncate(log2(value1), 2), truncate(log2(('1'::double precision / value1)), 2)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select truncate as nest with log2 (pushdown, result)
--Testcase 288:
SELECT truncate(log2(value1), 2),truncate(log2(1/value1), 2) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select truncate with non pushdown func and explicit constant (explain)
--Testcase 289:
EXPLAIN VERBOSE
SELECT truncate(value3, 2), pi(), 4.1 FROM s3;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: truncate(value3, 2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select truncate with non pushdown func and explicit constant (result)
--Testcase 290:
SELECT truncate(value3, 2), pi(), 4.1 FROM s3;
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate with order by (explain)
--Testcase 291:
EXPLAIN VERBOSE
SELECT value3, truncate(1-value3, 2) FROM s3 ORDER BY truncate(1-value3, 2);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value3, truncate(('1'::double precision - value3), 2)
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY truncate((1 - `value3`), 2) IS NULL ASC, truncate((1 - `value3`), 2) ASC
(4 rows)

-- select truncate with order by (result)
--Testcase 292:
SELECT value3, truncate(1-value3, 2) FROM s3 ORDER BY truncate(1-value3, 2);
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate with order by index (result)
--Testcase 293:
SELECT value3, truncate(1-value3, 2) FROM s3 ORDER BY 2,1;
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate with order by index (result)
--Testcase 294:
SELECT value3, truncate(1-value3, 2) FROM s3 ORDER BY 1,2;
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select truncate with group by (explain)
--Testcase 295:
EXPLAIN VERBOSE
SELECT count(value1), truncate(1-value3, 2) FROM s3 GROUP BY truncate(1-value3, 2);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (truncate(('1'::double precision - value3), 2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), truncate((1 - `value3`), 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select truncate with group by (result)
--Testcase 296:
SELECT count(value1), truncate(1-value3, 2) FROM s3 GROUP BY truncate(1-value3, 2);
 count | truncate 
-------+----------
     1 |      1.1
     1 |      1.2
     1 |      1.3
     1 |      2.1
     1 |      3.2
     1 |     4.29
(6 rows)

-- select truncate with group by index (result)
--Testcase 297:
SELECT value3, truncate(1-value3, 2) FROM s3 GROUP BY 2,1;
 value3 | truncate 
--------+----------
   -0.1 |      1.1
   -0.2 |      1.2
   -0.3 |      1.3
   -1.1 |      2.1
   -2.2 |      3.2
   -3.3 |     4.29
(6 rows)

-- select truncate with group by index (result)
--Testcase 298:
SELECT value3, truncate(1-value3, 2) FROM s3 GROUP BY 1,2;
 value3 | truncate 
--------+----------
   -0.1 |      1.1
   -0.2 |      1.2
   -0.3 |      1.3
   -1.1 |      2.1
   -2.2 |      3.2
   -3.3 |     4.29
(6 rows)

-- select truncate with group by having (explain)
--Testcase 299:
EXPLAIN VERBOSE
SELECT count(value1), truncate(1-value3, 2) FROM s3 GROUP BY truncate(1-value3, 2) HAVING avg(value1) > 0;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (truncate(('1'::double precision - value3), 2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), truncate((1 - `value3`), 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select truncate with group by having (result)
--Testcase 300:
SELECT count(value1), truncate(1-value3, 2) FROM s3 GROUP BY truncate(1-value3, 2) HAVING avg(value1) > 0;
 count | truncate 
-------+----------
     1 |      1.1
     1 |      1.2
     1 |      1.3
     1 |      2.1
     1 |      3.2
     1 |     4.29
(6 rows)

-- select truncate with group by index having (result)
--Testcase 301:
SELECT value3, truncate(1-value3, 2) FROM s3 GROUP BY 2,1 HAVING truncate(1-value3, 2) > 0;
 value3 | truncate 
--------+----------
   -0.1 |      1.1
   -0.2 |      1.2
   -0.3 |      1.3
   -1.1 |      2.1
   -2.2 |      3.2
   -3.3 |     4.29
(6 rows)

-- select truncate with group by index having (result)
--Testcase 302:
SELECT value3, truncate(1-value3, 2) FROM s3 GROUP BY 1,2 HAVING value3 > 1;
 value3 | truncate 
--------+----------
(0 rows)

-- select truncate and as
--Testcase 303:
SELECT truncate(value3, 2) as truncate1 FROM s3;
ERROR:  stub truncate(float8, int) is called
CONTEXT:  PL/pgSQL function truncate(double precision,integer) line 3 at RAISE
-- select round (builtin function, explain)
--Testcase 304:
EXPLAIN VERBOSE
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=64)
   Output: round(value1), round((value2)::double precision), round(value3), round((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select round (builtin function, result)
--Testcase 305:
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3;
 round | round | round | round | round 
-------+-------+-------+-------+-------
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
     1 |   200 |    -1 |  -200 |     1
     2 |   200 |    -2 |  -200 |     1
     3 |   200 |    -3 |  -200 |     1
(6 rows)

-- select round (builtin function, not pushdown constraints, explain)
--Testcase 306:
EXPLAIN VERBOSE
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=64)
   Output: round(value1), round((value2)::double precision), round(value3), round((value4)::double precision), '1'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select round (builtin function, not pushdown constraints, result)
--Testcase 307:
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3 WHERE to_hex(value2) = '64';
 round | round | round | round | round 
-------+-------+-------+-------+-------
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
(3 rows)

-- select round (builtin function, pushdown constraints, explain)
--Testcase 308:
EXPLAIN VERBOSE
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3 WHERE value2 != 200;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=64)
   Output: round(value1), round((value2)::double precision), round(value3), round((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select round (builtin function, pushdown constraints, result)
--Testcase 309:
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3 WHERE value2 != 200;
 round | round | round | round | round 
-------+-------+-------+-------+-------
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
(3 rows)

-- select round (builtin function, round in constraints, explain)
--Testcase 310:
EXPLAIN VERBOSE
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3 WHERE round(value1) != 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=64)
   Output: round(value1), round((value2)::double precision), round(value3), round((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((round(`value1`) <> 1))
(4 rows)

-- select round (builtin function, round in constraints, result)
--Testcase 311:
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3 WHERE round(value1) != 1;
 round | round | round | round | round 
-------+-------+-------+-------+-------
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
     2 |   200 |    -2 |  -200 |     1
     3 |   200 |    -3 |  -200 |     1
(5 rows)

-- select round (builtin function, round in constraints, explain)
--Testcase 312:
EXPLAIN VERBOSE
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3 WHERE round(0.5) > value1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=64)
   Output: round(value1), round((value2)::double precision), round(value3), round((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1 > `value1`))
(4 rows)

-- select round (builtin function, round in constraints, result)
--Testcase 313:
SELECT round(value1), round(value2), round(value3), round(value4), round(0.5) FROM s3 WHERE round(0.5) > value1;
 round | round | round | round | round 
-------+-------+-------+-------+-------
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
     0 |   100 |    -0 |  -100 |     1
(3 rows)

-- select round as nest function with agg (pushdown, explain)
--Testcase 314:
EXPLAIN VERBOSE
SELECT sum(value3),round(sum(value3)) FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (round(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), round(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select round as nest function with agg (pushdown, result)
--Testcase 315:
SELECT sum(value3),round(sum(value3)) FROM s3;
        sum         | round 
--------------------+-------
 -7.200000040233135 |    -7
(1 row)

-- select round as nest with log2 (pushdown, explain)
--Testcase 316:
EXPLAIN VERBOSE
SELECT round(log2(value1)),round(log2(1/value1)) FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: round(log2(value1)), round(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select round as nest with log2 (pushdown, result)
--Testcase 317:
SELECT round(log2(value1)),round(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select round with non pushdown func and explicit constant (explain)
--Testcase 318:
EXPLAIN VERBOSE
SELECT round(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: round(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select round with non pushdown func and explicit constant (result)
--Testcase 319:
SELECT round(value3), pi(), 4.1 FROM s3;
 round |        pi         | ?column? 
-------+-------------------+----------
    -0 | 3.141592653589793 |      4.1
    -0 | 3.141592653589793 |      4.1
    -0 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -2 | 3.141592653589793 |      4.1
    -3 | 3.141592653589793 |      4.1
(6 rows)

-- select round with order by (explain)
--Testcase 320:
EXPLAIN VERBOSE
SELECT value1, round(1-value3) FROM s3 ORDER BY round(1-value3);
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, round(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY round((1 - `value3`)) IS NULL ASC, round((1 - `value3`)) ASC
(4 rows)

-- select round with order by (result)
--Testcase 321:
SELECT value1, round(1-value3) FROM s3 ORDER BY round(1-value3);
 value1 | round 
--------+-------
    0.1 |     1
    0.2 |     1
    0.3 |     1
    1.1 |     2
    2.2 |     3
    3.3 |     4
(6 rows)

-- select round with order by index (result)
--Testcase 322:
SELECT value1, round(1-value3) FROM s3 ORDER BY 2,1;
 value1 | round 
--------+-------
    0.1 |     1
    0.2 |     1
    0.3 |     1
    1.1 |     2
    2.2 |     3
    3.3 |     4
(6 rows)

-- select round with order by index (result)
--Testcase 323:
SELECT value1, round(1-value3) FROM s3 ORDER BY 1,2;
 value1 | round 
--------+-------
    0.1 |     1
    0.2 |     1
    0.3 |     1
    1.1 |     2
    2.2 |     3
    3.3 |     4
(6 rows)

-- select round with group by (explain)
--Testcase 324:
EXPLAIN VERBOSE
SELECT count(value1), round(1-value3) FROM s3 GROUP BY round(1-value3);
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (round(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), round((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select round with group by (result)
--Testcase 325:
SELECT count(value1), round(1-value3) FROM s3 GROUP BY round(1-value3);
 count | round 
-------+-------
     3 |     1
     1 |     2
     1 |     3
     1 |     4
(4 rows)

-- select round with group by index (result)
--Testcase 326:
SELECT value1, round(1-value3) FROM s3 GROUP BY 2,1;
 value1 | round 
--------+-------
    0.1 |     1
    0.2 |     1
    0.3 |     1
    1.1 |     2
    2.2 |     3
    3.3 |     4
(6 rows)

-- select round with group by index (result)
--Testcase 327:
SELECT value1, round(1-value3) FROM s3 GROUP BY 1,2;
 value1 | round 
--------+-------
    0.1 |     1
    0.2 |     1
    0.3 |     1
    1.1 |     2
    2.2 |     3
    3.3 |     4
(6 rows)

-- select round with group by having (explain)
--Testcase 328:
EXPLAIN VERBOSE
SELECT count(value1), round(1-value3) FROM s3 GROUP BY round(1-value3) HAVING round(avg(value1)) > 0;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (round(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), round((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((round(avg(`value1`)) > 0))
(5 rows)

-- select round with group by having (result)
--Testcase 329:
SELECT count(value1), round(1-value3) FROM s3 GROUP BY round(1-value3) HAVING round(avg(value1)) > 0;
 count | round 
-------+-------
     1 |     2
     1 |     3
     1 |     4
(3 rows)

-- select round with group by index having (result)
--Testcase 330:
SELECT value1, round(1-value3) FROM s3 GROUP BY 2,1 HAVING round(1-value3) > 0;
 value1 | round 
--------+-------
    0.1 |     1
    0.2 |     1
    0.3 |     1
    1.1 |     2
    2.2 |     3
    3.3 |     4
(6 rows)

-- select round with group by index having (result)
--Testcase 331:
SELECT value1, round(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | round 
--------+-------
    1.1 |     2
    2.2 |     3
    3.3 |     4
(3 rows)

-- select round and as
--Testcase 332:
SELECT round(value3) as round1 FROM s3;
 round1 
--------
     -0
     -0
     -0
     -1
     -2
     -3
(6 rows)

-- select acos (builtin function, explain)
--Testcase 333:
EXPLAIN VERBOSE
SELECT value1, acos(value3), acos(0.5) FROM s3;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..176.56 rows=2048 width=24)
   Output: value1, acos(value3), '1.0471975511965979'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select acos (builtin function, result)
--Testcase 334:
SELECT value1, acos(value3), acos(0.5) FROM s3;
ERROR:  input is out of range
-- select acos (builtin function, not pushdown constraints, explain)
--Testcase 335:
EXPLAIN VERBOSE
SELECT acos(value1), acos(value3), acos(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.97 rows=10 width=24)
   Output: acos(value1), acos(value3), '1.0471975511965979'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select acos (builtin function, not pushdown constraints, result)
--Testcase 336:
SELECT acos(value1), acos(value3), acos(0.5) FROM s3 WHERE to_hex(value2) = '64';
        acos        |        acos        |        acos        
--------------------+--------------------+--------------------
 1.4706289056333368 | 1.6709637479564565 | 1.0471975511965979
  1.369438406004566 | 1.7721542475852274 | 1.0471975511965979
 1.2661036727794992 | 1.8754889808102941 | 1.0471975511965979
(3 rows)

-- select acos (builtin function, pushdown constraints, explain)
--Testcase 337:
EXPLAIN VERBOSE
SELECT acos(value1), acos(value3), acos(0.5) FROM s3 WHERE value2 != 200;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.55 rows=2038 width=24)
   Output: acos(value1), acos(value3), '1.0471975511965979'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select acos (builtin function, pushdown constraints, result)
--Testcase 338:
SELECT acos(value1), acos(value3), acos(0.5) FROM s3 WHERE value2 != 200;
        acos        |        acos        |        acos        
--------------------+--------------------+--------------------
 1.4706289056333368 | 1.6709637479564565 | 1.0471975511965979
  1.369438406004566 | 1.7721542475852274 | 1.0471975511965979
 1.2661036727794992 | 1.8754889808102941 | 1.0471975511965979
(3 rows)

-- select acos (builtin function, acos in constraints, explain)
--Testcase 339:
EXPLAIN VERBOSE
SELECT acos(value1), acos(value3), acos(0.5) FROM s3 WHERE acos(value1) != 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..191.67 rows=2038 width=24)
   Output: acos(value1), acos(value3), '1.0471975511965979'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE ((acos(`value1`) <> 1))
(4 rows)

-- select acos (builtin function, acos in constraints, result)
--Testcase 340:
SELECT acos(value1), acos(value3), acos(0.5) FROM s3 WHERE acos(value1) != 1;
        acos        |        acos        |        acos        
--------------------+--------------------+--------------------
 1.4706289056333368 | 1.6709637479564565 | 1.0471975511965979
  1.369438406004566 | 1.7721542475852274 | 1.0471975511965979
 1.2661036727794992 | 1.8754889808102941 | 1.0471975511965979
(3 rows)

-- select acos (builtin function, acos in constraints, explain)
--Testcase 341:
EXPLAIN VERBOSE
SELECT acos(value1), acos(value3), acos(0.5) FROM s3 WHERE acos(0.5) > value1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..152.68 rows=683 width=24)
   Output: acos(value1), acos(value3), '1.0471975511965979'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE ((1.0471975511965979 > `value1`))
(4 rows)

-- select acos (builtin function, acos in constraints, result)
--Testcase 342:
SELECT acos(value1), acos(value3), acos(0.5) FROM s3 WHERE acos(0.5) > value1;
        acos        |        acos        |        acos        
--------------------+--------------------+--------------------
 1.4706289056333368 | 1.6709637479564565 | 1.0471975511965979
  1.369438406004566 | 1.7721542475852274 | 1.0471975511965979
 1.2661036727794992 | 1.8754889808102941 | 1.0471975511965979
(3 rows)

-- select acos as nest function with agg (pushdown, explain)
--Testcase 343:
EXPLAIN VERBOSE
SELECT sum(value3),acos(sum(value1)) FROM s3 WHERE value2 != 200;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (acos(sum(value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), acos(sum(`value1`)) FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(5 rows)

-- select acos as nest function with agg (pushdown, result)
--Testcase 344:
SELECT sum(value3),acos(sum(value1)) FROM s3 WHERE value2 != 200;
         sum         |        acos        
---------------------+--------------------
 -0.6000000163912773 | 0.9272951975125154
(1 row)

-- select acos as nest with log2 (pushdown, explain)
--Testcase 345:
EXPLAIN VERBOSE
SELECT value1, acos(log2(value1)),acos(log2(1/value1)) FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, acos(log2(value1)), acos(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select acos as nest with log2 (pushdown, result)
--Testcase 346:
SELECT value1, acos(log2(value1)),acos(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select acos with non pushdown func and explicit constant (explain)
--Testcase 347:
EXPLAIN VERBOSE
SELECT acos(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: acos(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select acos with non pushdown func and explicit constant (result)
--Testcase 348:
SELECT acos(value3), pi(), 4.1 FROM s3;
ERROR:  input is out of range
-- select acos with order by (explain)
--Testcase 349:
EXPLAIN VERBOSE
SELECT value1, acos(1-value1) FROM s3 ORDER BY acos(1-value1);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, acos(('1'::double precision - value1))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` ORDER BY acos((1 - `value1`)) IS NULL ASC, acos((1 - `value1`)) ASC
(4 rows)

-- select acos with order by (result)
--Testcase 350:
SELECT value1, acos(1-value1) FROM s3 ORDER BY acos(1-value1);
ERROR:  input is out of range
-- select acos with order by index (result)
--Testcase 351:
SELECT value1, acos(1-value1) FROM s3 ORDER BY 2,1;
ERROR:  input is out of range
-- select acos with order by index (result)
--Testcase 352:
SELECT value1, acos(1-value1) FROM s3 ORDER BY 1,2;
ERROR:  input is out of range
-- select acos with group by (explain)
--Testcase 353:
EXPLAIN VERBOSE
SELECT count(value1), acos(1-value1) FROM s3 GROUP BY acos(1-value1);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (acos(('1'::double precision - value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), acos((1 - `value1`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select acos with group by (result)
--Testcase 354:
SELECT count(value1), acos(1-value1) FROM s3 GROUP BY acos(1-value1);
 count |        acos         
-------+---------------------
     1 | 0.45102681521482324
     1 |  0.6435011137603381
     1 |  0.7953988468767829
     1 |  1.6709637719184252
     2 |                    
(5 rows)

-- select acos with group by index (result)
--Testcase 355:
SELECT value1, acos(1-value1) FROM s3 GROUP BY 2,1;
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681521482324
    0.2 |  0.6435011137603381
    0.3 |  0.7953988468767829
    1.1 |  1.6709637719184252
    2.2 |                    
    3.3 |                    
(6 rows)

-- select acos with group by index (result)
--Testcase 356:
SELECT value1, acos(1-value1) FROM s3 GROUP BY 1,2;
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681521482324
    0.2 |  0.6435011137603381
    0.3 |  0.7953988468767829
    1.1 |  1.6709637719184252
    2.2 |                    
    3.3 |                    
(6 rows)

-- select acos with group by having (explain)
--Testcase 357:
EXPLAIN VERBOSE
SELECT count(value1), acos(1-value1) FROM s3 GROUP BY acos(1-value1) HAVING avg(value1) > 0;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (acos(('1'::double precision - value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), acos((1 - `value1`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select acos with group by having (result)
--Testcase 358:
SELECT count(value1), acos(1-value1) FROM s3 GROUP BY acos(1-value1) HAVING avg(value1) > 0;
 count |        acos         
-------+---------------------
     1 | 0.45102681521482324
     1 |  0.6435011137603381
     1 |  0.7953988468767829
     1 |  1.6709637719184252
     2 |                    
(5 rows)

-- select acos with group by index having (result)
--Testcase 359:
SELECT value1, acos(1-value1) FROM s3 GROUP BY 2,1 HAVING acos(1-value1) > 0;
 value1 |        acos         
--------+---------------------
    0.1 | 0.45102681521482324
    0.2 |  0.6435011137603381
    0.3 |  0.7953988468767829
    1.1 |  1.6709637719184252
(4 rows)

-- select acos with group by index having (result)
--Testcase 360:
SELECT value1, acos(1-value1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |        acos        
--------+--------------------
    1.1 | 1.6709637719184252
    2.2 |                   
    3.3 |                   
(3 rows)

-- select acos and as
--Testcase 361:
SELECT acos(value3) as acos1 FROM s3;
ERROR:  input is out of range
-- select asin (builtin function, explain)
--Testcase 362:
EXPLAIN VERBOSE
SELECT asin(value1), asin(value3), asin(0.5) FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..181.68 rows=2048 width=24)
   Output: asin(value1), asin(value3), '0.5235987755982989'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select asin (builtin function, result)
--Testcase 363:
SELECT asin(value1), asin(value3), asin(0.5) FROM s3;
ERROR:  input is out of range
-- select asin (builtin function, not pushdown constraints, explain)
--Testcase 364:
EXPLAIN VERBOSE
SELECT asin(value1), asin(value3), asin(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.97 rows=10 width=24)
   Output: asin(value1), asin(value3), '0.5235987755982989'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select asin (builtin function, not pushdown constraints, result)
--Testcase 365:
SELECT asin(value1), asin(value3), asin(0.5) FROM s3 WHERE to_hex(value2) = '64';
        asin        |        asin         |        asin        
--------------------+---------------------+--------------------
 0.1001674211615598 | -0.1001674211615598 | 0.5235987755982989
 0.2013579207903308 | -0.2013579207903308 | 0.5235987755982989
 0.3046926540153975 | -0.3046926540153975 | 0.5235987755982989
(3 rows)

-- select asin (builtin function, pushdown constraints, explain)
--Testcase 366:
EXPLAIN VERBOSE
SELECT asin(value1), asin(value3), asin(0.5) FROM s3 WHERE value2 != 200;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.55 rows=2038 width=24)
   Output: asin(value1), asin(value3), '0.5235987755982989'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select asin (builtin function, pushdown constraints, result)
--Testcase 367:
SELECT asin(value1), asin(value3), asin(0.5) FROM s3 WHERE value2 != 200;
        asin        |        asin         |        asin        
--------------------+---------------------+--------------------
 0.1001674211615598 | -0.1001674211615598 | 0.5235987755982989
 0.2013579207903308 | -0.2013579207903308 | 0.5235987755982989
 0.3046926540153975 | -0.3046926540153975 | 0.5235987755982989
(3 rows)

-- select asin (builtin function, asin in constraints, explain)
--Testcase 368:
EXPLAIN VERBOSE
SELECT asin(value1), asin(value3), asin(0.5) FROM s3 WHERE asin(value1) != 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..191.67 rows=2038 width=24)
   Output: asin(value1), asin(value3), '0.5235987755982989'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE ((asin(`value1`) <> 1))
(4 rows)

-- select asin (builtin function, asin in constraints, result)
--Testcase 369:
SELECT asin(value1), asin(value3), asin(0.5) FROM s3 WHERE asin(value1) != 1;
        asin        |        asin         |        asin        
--------------------+---------------------+--------------------
 0.1001674211615598 | -0.1001674211615598 | 0.5235987755982989
 0.2013579207903308 | -0.2013579207903308 | 0.5235987755982989
 0.3046926540153975 | -0.3046926540153975 | 0.5235987755982989
(3 rows)

-- select asin (builtin function, asin in constraints, explain)
--Testcase 370:
EXPLAIN VERBOSE
SELECT asin(value1), asin(value3), asin(0.5) FROM s3 WHERE asin(0.5) > value1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..152.68 rows=683 width=24)
   Output: asin(value1), asin(value3), '0.5235987755982989'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE ((0.5235987755982989 > `value1`))
(4 rows)

-- select asin (builtin function, asin in constraints, result)
--Testcase 371:
SELECT asin(value1), asin(value3), asin(0.5) FROM s3 WHERE asin(0.5) > value1;
        asin        |        asin         |        asin        
--------------------+---------------------+--------------------
 0.1001674211615598 | -0.1001674211615598 | 0.5235987755982989
 0.2013579207903308 | -0.2013579207903308 | 0.5235987755982989
 0.3046926540153975 | -0.3046926540153975 | 0.5235987755982989
(3 rows)

-- select asin as nest function with agg (pushdown, explain)
--Testcase 372:
EXPLAIN VERBOSE
SELECT sum(value3),asin(sum(value1)) FROM s3 WHERE value2 != 200;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (asin(sum(value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), asin(sum(`value1`)) FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(5 rows)

-- select asin as nest function with agg (pushdown, result)
--Testcase 373:
SELECT sum(value3),asin(sum(value1)) FROM s3 WHERE value2 != 200;
         sum         |        asin        
---------------------+--------------------
 -0.6000000163912773 | 0.6435011292823812
(1 row)

-- select asin as nest with log2 (pushdown, explain)
--Testcase 374:
EXPLAIN VERBOSE
SELECT value1, asin(log2(value1)),asin(log2(1/value1)) FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, asin(log2(value1)), asin(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select asin as nest with log2 (pushdown, result)
--Testcase 375:
SELECT value1, asin(log2(value1)),asin(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select asin with non pushdown func and explicit constant (explain)
--Testcase 376:
EXPLAIN VERBOSE
SELECT value1, asin(value3), pi(), 4.1 FROM s3;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..176.56 rows=2048 width=56)
   Output: value1, asin(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select asin with non pushdown func and explicit constant (result)
--Testcase 377:
SELECT value1, asin(value3), pi(), 4.1 FROM s3;
ERROR:  input is out of range
-- select asin with order by (explain)
--Testcase 378:
EXPLAIN VERBOSE
SELECT value1, asin(1-value1) FROM s3 ORDER BY asin(1-value1);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, asin(('1'::double precision - value1))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` ORDER BY asin((1 - `value1`)) IS NULL ASC, asin((1 - `value1`)) ASC
(4 rows)

-- select asin with order by (result)
--Testcase 379:
SELECT value1, asin(1-value1) FROM s3 ORDER BY asin(1-value1);
ERROR:  input is out of range
-- select asin with order by index (result)
--Testcase 380:
SELECT value1, asin(1-value1) FROM s3 ORDER BY 2,1;
ERROR:  input is out of range
-- select asin with order by index (result)
--Testcase 381:
SELECT value1, asin(1-value1) FROM s3 ORDER BY 1,2;
ERROR:  input is out of range
-- select asin with group by (explain)
--Testcase 382:
EXPLAIN VERBOSE
SELECT value1, asin(1-value1) FROM s3 GROUP BY value1, asin(1-value1);
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: value1, (asin(('1'::double precision - value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, asin((1 - `value1`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select asin with group by (result)
--Testcase 383:
SELECT value1, asin(1-value1) FROM s3 GROUP BY value1, asin(1-value1);
 value1 |         asin         
--------+----------------------
    0.1 |   1.1197695115800734
    0.2 |   0.9272952130345585
    0.3 |   0.7753974799181138
    1.1 | -0.10016744512352861
    2.2 |                     
    3.3 |                     
(6 rows)

-- select asin with group by index (result)
--Testcase 384:
SELECT value1, asin(1-value1) FROM s3 GROUP BY 2,1;
 value1 |         asin         
--------+----------------------
    0.1 |   1.1197695115800734
    0.2 |   0.9272952130345585
    0.3 |   0.7753974799181138
    1.1 | -0.10016744512352861
    2.2 |                     
    3.3 |                     
(6 rows)

-- select asin with group by index (result)
--Testcase 385:
SELECT value1, asin(1-value1) FROM s3 GROUP BY 1,2;
 value1 |         asin         
--------+----------------------
    0.1 |   1.1197695115800734
    0.2 |   0.9272952130345585
    0.3 |   0.7753974799181138
    1.1 | -0.10016744512352861
    2.2 |                     
    3.3 |                     
(6 rows)

-- select asin with group by having (explain)
--Testcase 386:
EXPLAIN VERBOSE
SELECT value1, asin(1-value1) FROM s3 GROUP BY value1, asin(1-value1) HAVING avg(value1) > 0;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: value1, (asin(('1'::double precision - value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, asin((1 - `value1`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select asin with group by having (result)
--Testcase 387:
SELECT value1, asin(1-value1) FROM s3 GROUP BY value1, asin(1-value1) HAVING avg(value1) > 0;
 value1 |         asin         
--------+----------------------
    0.1 |   1.1197695115800734
    0.2 |   0.9272952130345585
    0.3 |   0.7753974799181138
    1.1 | -0.10016744512352861
    2.2 |                     
    3.3 |                     
(6 rows)

-- select asin with group by index having (result)
--Testcase 388:
SELECT value1, asin(1-value1) FROM s3 GROUP BY 2,1 HAVING asin(1-value1) > 0;
 value1 |        asin        
--------+--------------------
    0.1 | 1.1197695115800734
    0.2 | 0.9272952130345585
    0.3 | 0.7753974799181138
(3 rows)

-- select asin with group by index having (result)
--Testcase 389:
SELECT value1, asin(1-value1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |         asin         
--------+----------------------
    1.1 | -0.10016744512352861
    2.2 |                     
    3.3 |                     
(3 rows)

-- select asin and as
--Testcase 390:
SELECT value1, asin(value3) as asin1 FROM s3;
ERROR:  input is out of range
-- select atan (builtin function, explain)
--Testcase 391:
EXPLAIN VERBOSE
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=40)
   Output: atan(value1), atan((value2)::double precision), atan(value3), atan((value4)::double precision), '0.4636476090008061'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan (builtin function, result)
--Testcase 392:
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3;
        atan         |        atan        |         atan         |        atan         |        atan        
---------------------+--------------------+----------------------+---------------------+--------------------
 0.09966865249116204 | 1.5607966601082315 | -0.09966865249116204 | -1.5607966601082315 | 0.4636476090008061
 0.19739555984988078 | 1.5607966601082315 | -0.19739555984988078 | -1.5607966601082315 | 0.4636476090008061
  0.2914567944778671 | 1.5607966601082315 |  -0.2914567944778671 | -1.5607966601082315 | 0.4636476090008061
  0.8329812666744317 | 1.5657963684609384 |  -0.8329812666744317 | -1.5657963684609384 | 0.4636476090008061
  1.1441688336680205 | 1.5657963684609384 |  -1.1441688336680205 | -1.5657963684609384 | 0.4636476090008061
  1.2765617616837088 | 1.5657963684609384 |  -1.2765617616837088 | -1.5657963684609384 | 0.4636476090008061
(6 rows)

-- select atan (builtin function, not pushdown constraints, explain)
--Testcase 393:
EXPLAIN VERBOSE
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: atan(value1), atan((value2)::double precision), atan(value3), atan((value4)::double precision), '0.4636476090008061'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select atan (builtin function, not pushdown constraints, result)
--Testcase 394:
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3 WHERE to_hex(value2) = '64';
        atan         |        atan        |         atan         |        atan         |        atan        
---------------------+--------------------+----------------------+---------------------+--------------------
 0.09966865249116204 | 1.5607966601082315 | -0.09966865249116204 | -1.5607966601082315 | 0.4636476090008061
 0.19739555984988078 | 1.5607966601082315 | -0.19739555984988078 | -1.5607966601082315 | 0.4636476090008061
  0.2914567944778671 | 1.5607966601082315 |  -0.2914567944778671 | -1.5607966601082315 | 0.4636476090008061
(3 rows)

-- select atan (builtin function, pushdown constraints, explain)
--Testcase 395:
EXPLAIN VERBOSE
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3 WHERE value2 != 200;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: atan(value1), atan((value2)::double precision), atan(value3), atan((value4)::double precision), '0.4636476090008061'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select atan (builtin function, pushdown constraints, result)
--Testcase 396:
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3 WHERE value2 != 200;
        atan         |        atan        |         atan         |        atan         |        atan        
---------------------+--------------------+----------------------+---------------------+--------------------
 0.09966865249116204 | 1.5607966601082315 | -0.09966865249116204 | -1.5607966601082315 | 0.4636476090008061
 0.19739555984988078 | 1.5607966601082315 | -0.19739555984988078 | -1.5607966601082315 | 0.4636476090008061
  0.2914567944778671 | 1.5607966601082315 |  -0.2914567944778671 | -1.5607966601082315 | 0.4636476090008061
(3 rows)

-- select atan (builtin function, atan in constraints, explain)
--Testcase 397:
EXPLAIN VERBOSE
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3 WHERE atan(value1) != 1;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=40)
   Output: atan(value1), atan((value2)::double precision), atan(value3), atan((value4)::double precision), '0.4636476090008061'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((atan(`value1`) <> 1))
(4 rows)

-- select atan (builtin function, atan in constraints, result)
--Testcase 398:
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3 WHERE atan(value1) != 1;
        atan         |        atan        |         atan         |        atan         |        atan        
---------------------+--------------------+----------------------+---------------------+--------------------
 0.09966865249116204 | 1.5607966601082315 | -0.09966865249116204 | -1.5607966601082315 | 0.4636476090008061
 0.19739555984988078 | 1.5607966601082315 | -0.19739555984988078 | -1.5607966601082315 | 0.4636476090008061
  0.2914567944778671 | 1.5607966601082315 |  -0.2914567944778671 | -1.5607966601082315 | 0.4636476090008061
  0.8329812666744317 | 1.5657963684609384 |  -0.8329812666744317 | -1.5657963684609384 | 0.4636476090008061
  1.1441688336680205 | 1.5657963684609384 |  -1.1441688336680205 | -1.5657963684609384 | 0.4636476090008061
  1.2765617616837088 | 1.5657963684609384 |  -1.2765617616837088 | -1.5657963684609384 | 0.4636476090008061
(6 rows)

-- select atan (builtin function, atan in constraints, explain)
--Testcase 399:
EXPLAIN VERBOSE
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3 WHERE atan(0.5) > value1;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=40)
   Output: atan(value1), atan((value2)::double precision), atan(value3), atan((value4)::double precision), '0.4636476090008061'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((0.4636476090008061 > `value1`))
(4 rows)

-- select atan (builtin function, atan in constraints, result)
--Testcase 400:
SELECT atan(value1), atan(value2), atan(value3), atan(value4), atan(0.5) FROM s3 WHERE atan(0.5) > value1;
        atan         |        atan        |         atan         |        atan         |        atan        
---------------------+--------------------+----------------------+---------------------+--------------------
 0.09966865249116204 | 1.5607966601082315 | -0.09966865249116204 | -1.5607966601082315 | 0.4636476090008061
 0.19739555984988078 | 1.5607966601082315 | -0.19739555984988078 | -1.5607966601082315 | 0.4636476090008061
  0.2914567944778671 | 1.5607966601082315 |  -0.2914567944778671 | -1.5607966601082315 | 0.4636476090008061
(3 rows)

-- select atan as nest function with agg (pushdown, explain)
--Testcase 401:
EXPLAIN VERBOSE
SELECT sum(value3),atan(sum(value3)) FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (atan(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), atan(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select atan as nest function with agg (pushdown, result)
--Testcase 402:
SELECT sum(value3),atan(sum(value3)) FROM s3;
        sum         |        atan         
--------------------+---------------------
 -7.200000040233135 | -1.4327903038987915
(1 row)

-- select atan as nest with log2 (pushdown, explain)
--Testcase 403:
EXPLAIN VERBOSE
SELECT atan(log2(value1)),atan(log2(1/value1)) FROM s3;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: atan(log2(value1)), atan(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan as nest with log2 (pushdown, result)
--Testcase 404:
SELECT atan(log2(value1)),atan(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select atan with non pushdown func and explicit constant (explain)
--Testcase 405:
EXPLAIN VERBOSE
SELECT atan(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: atan(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan with non pushdown func and explicit constant (result)
--Testcase 406:
SELECT atan(value3), pi(), 4.1 FROM s3;
         atan         |        pi         | ?column? 
----------------------+-------------------+----------
 -0.09966865249116204 | 3.141592653589793 |      4.1
 -0.19739555984988078 | 3.141592653589793 |      4.1
  -0.2914567944778671 | 3.141592653589793 |      4.1
  -0.8329812666744317 | 3.141592653589793 |      4.1
  -1.1441688336680205 | 3.141592653589793 |      4.1
  -1.2765617616837088 | 3.141592653589793 |      4.1
(6 rows)

-- select atan with order by (explain)
--Testcase 407:
EXPLAIN VERBOSE
SELECT value1, atan(1-value3) FROM s3 ORDER BY atan(1-value3);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, atan(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY atan((1 - `value3`)) IS NULL ASC, atan((1 - `value3`)) ASC
(4 rows)

-- select atan with order by (result)
--Testcase 408:
SELECT value1, atan(1-value3) FROM s3 ORDER BY atan(1-value3);
 value1 |        atan        
--------+--------------------
    0.1 | 0.8329812666744317
    0.2 | 0.8760580505981934
    0.3 | 0.9151007005533605
    1.1 | 1.1263771168937977
    2.2 | 1.2679114584199251
    3.3 | 1.3422996875030344
(6 rows)

-- select atan with order by index (result)
--Testcase 409:
SELECT value1, atan(1-value3) FROM s3 ORDER BY 2,1;
 value1 |        atan        
--------+--------------------
    0.1 | 0.8329812666744317
    0.2 | 0.8760580505981934
    0.3 | 0.9151007005533605
    1.1 | 1.1263771168937977
    2.2 | 1.2679114584199251
    3.3 | 1.3422996875030344
(6 rows)

-- select atan with order by index (result)
--Testcase 410:
SELECT value1, atan(1-value3) FROM s3 ORDER BY 1,2;
 value1 |        atan        
--------+--------------------
    0.1 | 0.8329812666744317
    0.2 | 0.8760580505981934
    0.3 | 0.9151007005533605
    1.1 | 1.1263771168937977
    2.2 | 1.2679114584199251
    3.3 | 1.3422996875030344
(6 rows)

-- select atan with group by (explain)
--Testcase 411:
EXPLAIN VERBOSE
SELECT count(value1), atan(1-value3) FROM s3 GROUP BY atan(1-value3);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (atan(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), atan((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select atan with group by (result)
--Testcase 412:
SELECT count(value1), atan(1-value3) FROM s3 GROUP BY atan(1-value3);
 count |        atan        
-------+--------------------
     1 | 0.8329812673486924
     1 | 0.8760580518196001
     1 | 0.9151007049849325
     1 | 1.1263771213007954
     1 | 1.2679114626622485
     1 | 1.3422996850564608
(6 rows)

-- select atan with group by index (result)
--Testcase 413:
SELECT value1, atan(1-value3) FROM s3 GROUP BY 2,1;
 value1 |        atan        
--------+--------------------
    0.1 | 0.8329812673486924
    0.2 | 0.8760580518196001
    0.3 | 0.9151007049849325
    1.1 | 1.1263771213007954
    2.2 | 1.2679114626622485
    3.3 | 1.3422996850564608
(6 rows)

-- select atan with group by index (result)
--Testcase 414:
SELECT value1, atan(1-value3) FROM s3 GROUP BY 1,2;
 value1 |        atan        
--------+--------------------
    0.1 | 0.8329812673486924
    0.2 | 0.8760580518196001
    0.3 | 0.9151007049849325
    1.1 | 1.1263771213007954
    2.2 | 1.2679114626622485
    3.3 | 1.3422996850564608
(6 rows)

-- select atan with group by having (explain)
--Testcase 415:
EXPLAIN VERBOSE
SELECT count(value1), atan(1-value3) FROM s3 GROUP BY atan(1-value3) HAVING atan(avg(value1)) > 0;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (atan(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), atan((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((atan(avg(`value1`)) > 0))
(5 rows)

-- select atan with group by having (result)
--Testcase 416:
SELECT count(value1), atan(1-value3) FROM s3 GROUP BY atan(1-value3) HAVING atan(avg(value1)) > 0;
 count |        atan        
-------+--------------------
     1 | 0.8329812673486924
     1 | 0.8760580518196001
     1 | 0.9151007049849325
     1 | 1.1263771213007954
     1 | 1.2679114626622485
     1 | 1.3422996850564608
(6 rows)

-- select atan with group by index having (result)
--Testcase 417:
SELECT value1, atan(1-value3) FROM s3 GROUP BY 2,1 HAVING atan(1-value3) > 0;
 value1 |        atan        
--------+--------------------
    0.1 | 0.8329812673486924
    0.2 | 0.8760580518196001
    0.3 | 0.9151007049849325
    1.1 | 1.1263771213007954
    2.2 | 1.2679114626622485
    3.3 | 1.3422996850564608
(6 rows)

-- select atan with group by index having (result)
--Testcase 418:
SELECT value1, atan(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |        atan        
--------+--------------------
    1.1 | 1.1263771213007954
    2.2 | 1.2679114626622485
    3.3 | 1.3422996850564608
(3 rows)

-- select atan and as
--Testcase 419:
SELECT atan(value3) as atan1 FROM s3;
        atan1         
----------------------
 -0.09966865249116204
 -0.19739555984988078
  -0.2914567944778671
  -0.8329812666744317
  -1.1441688336680205
  -1.2765617616837088
(6 rows)

-- select atan2 (builtin function, explain)
--Testcase 420:
EXPLAIN VERBOSE
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3;
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=40)
   Output: atan2(value1, '2'::double precision), atan2((value2)::double precision, '2'::double precision), atan2(value3, '2'::double precision), atan2((value4)::double precision, '2'::double precision), '1.1902899496825317'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan2 (builtin function, result)
--Testcase 421:
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3;
        atan2         |       atan2        |         atan2         |        atan2        |       atan2        
----------------------+--------------------+-----------------------+---------------------+--------------------
 0.049958395721942765 |  1.550798992821746 | -0.049958395721942765 |  -1.550798992821746 | 1.1902899496825317
  0.09966865249116204 |  1.550798992821746 |  -0.09966865249116204 |  -1.550798992821746 | 1.1902899496825317
  0.14888994760949725 |  1.550798992821746 |  -0.14888994760949725 |  -1.550798992821746 | 1.1902899496825317
   0.5028432109278609 | 1.5607966601082315 |   -0.5028432109278609 | -1.5607966601082315 | 1.1902899496825317
   0.8329812666744317 | 1.5607966601082315 |   -0.8329812666744317 | -1.5607966601082315 | 1.1902899496825317
    1.025932411343353 | 1.5607966601082315 |    -1.025932411343353 | -1.5607966601082315 | 1.1902899496825317
(6 rows)

-- select atan2 (builtin function, not pushdown constraints, explain)
--Testcase 422:
EXPLAIN VERBOSE
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3 WHERE to_hex(value2) = '64';
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: atan2(value1, '2'::double precision), atan2((value2)::double precision, '2'::double precision), atan2(value3, '2'::double precision), atan2((value4)::double precision, '2'::double precision), '1.1902899496825317'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select atan2 (builtin function, not pushdown constraints, result)
--Testcase 423:
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3 WHERE to_hex(value2) = '64';
        atan2         |       atan2       |         atan2         |       atan2        |       atan2        
----------------------+-------------------+-----------------------+--------------------+--------------------
 0.049958395721942765 | 1.550798992821746 | -0.049958395721942765 | -1.550798992821746 | 1.1902899496825317
  0.09966865249116204 | 1.550798992821746 |  -0.09966865249116204 | -1.550798992821746 | 1.1902899496825317
  0.14888994760949725 | 1.550798992821746 |  -0.14888994760949725 | -1.550798992821746 | 1.1902899496825317
(3 rows)

-- select atan2 (builtin function, pushdown constraints, explain)
--Testcase 424:
EXPLAIN VERBOSE
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3 WHERE value2 != 200;
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: atan2(value1, '2'::double precision), atan2((value2)::double precision, '2'::double precision), atan2(value3, '2'::double precision), atan2((value4)::double precision, '2'::double precision), '1.1902899496825317'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select atan2 (builtin function, pushdown constraints, result)
--Testcase 425:
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3 WHERE value2 != 200;
        atan2         |       atan2       |         atan2         |       atan2        |       atan2        
----------------------+-------------------+-----------------------+--------------------+--------------------
 0.049958395721942765 | 1.550798992821746 | -0.049958395721942765 | -1.550798992821746 | 1.1902899496825317
  0.09966865249116204 | 1.550798992821746 |  -0.09966865249116204 | -1.550798992821746 | 1.1902899496825317
  0.14888994760949725 | 1.550798992821746 |  -0.14888994760949725 | -1.550798992821746 | 1.1902899496825317
(3 rows)

-- select atan2 (builtin function, atan2 in constraints, explain)
--Testcase 426:
EXPLAIN VERBOSE
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3 WHERE atan2(value1, 2) != 1;
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=40)
   Output: atan2(value1, '2'::double precision), atan2((value2)::double precision, '2'::double precision), atan2(value3, '2'::double precision), atan2((value4)::double precision, '2'::double precision), '1.1902899496825317'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((atan2(`value1`, 2) <> 1))
(4 rows)

-- select atan2 (builtin function, atan2 in constraints, result)
--Testcase 427:
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3 WHERE atan2(value1, 2) != 1;
        atan2         |       atan2        |         atan2         |        atan2        |       atan2        
----------------------+--------------------+-----------------------+---------------------+--------------------
 0.049958395721942765 |  1.550798992821746 | -0.049958395721942765 |  -1.550798992821746 | 1.1902899496825317
  0.09966865249116204 |  1.550798992821746 |  -0.09966865249116204 |  -1.550798992821746 | 1.1902899496825317
  0.14888994760949725 |  1.550798992821746 |  -0.14888994760949725 |  -1.550798992821746 | 1.1902899496825317
   0.5028432109278609 | 1.5607966601082315 |   -0.5028432109278609 | -1.5607966601082315 | 1.1902899496825317
   0.8329812666744317 | 1.5607966601082315 |   -0.8329812666744317 | -1.5607966601082315 | 1.1902899496825317
    1.025932411343353 | 1.5607966601082315 |    -1.025932411343353 | -1.5607966601082315 | 1.1902899496825317
(6 rows)

-- select atan2 (builtin function, atan2 in constraints, explain)
--Testcase 428:
EXPLAIN VERBOSE
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3 WHERE atan2(5, 2) > value1;
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=40)
   Output: atan2(value1, '2'::double precision), atan2((value2)::double precision, '2'::double precision), atan2(value3, '2'::double precision), atan2((value4)::double precision, '2'::double precision), '1.1902899496825317'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1.1902899496825317 > `value1`))
(4 rows)

-- select atan2 (builtin function, atan2 in constraints, result)
--Testcase 429:
SELECT atan2(value1, 2), atan2(value2, 2), atan2(value3, 2), atan2(value4, 2), atan2(5, 2) FROM s3 WHERE atan2(5, 2) > value1;
        atan2         |       atan2        |         atan2         |        atan2        |       atan2        
----------------------+--------------------+-----------------------+---------------------+--------------------
 0.049958395721942765 |  1.550798992821746 | -0.049958395721942765 |  -1.550798992821746 | 1.1902899496825317
  0.09966865249116204 |  1.550798992821746 |  -0.09966865249116204 |  -1.550798992821746 | 1.1902899496825317
  0.14888994760949725 |  1.550798992821746 |  -0.14888994760949725 |  -1.550798992821746 | 1.1902899496825317
   0.5028432109278609 | 1.5607966601082315 |   -0.5028432109278609 | -1.5607966601082315 | 1.1902899496825317
(4 rows)

-- select atan2 as nest function with agg (pushdown, explain)
--Testcase 430:
EXPLAIN VERBOSE
SELECT sum(value3),atan2(sum(value3), 2) FROM s3;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (atan2(sum(value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), atan2(sum(`value3`), 2) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select atan2 as nest function with agg (pushdown, result)
--Testcase 431:
SELECT sum(value3),atan2(sum(value3), 2) FROM s3;
        sum         |       atan2        
--------------------+--------------------
 -7.200000040233135 | -1.299849477897491
(1 row)

-- select atan2 as nest with log2 (pushdown, explain)
--Testcase 432:
EXPLAIN VERBOSE
SELECT atan2(log2(value1), 2),atan2(log2(1/value1), 2) FROM s3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: atan2(log2(value1), '2'::double precision), atan2(log2(('1'::double precision / value1)), '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan2 as nest with log2 (pushdown, result)
--Testcase 433:
SELECT atan2(log2(value1), 2),atan2(log2(1/value1), 2) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select atan2 with non pushdown func and atan2licit constant (explain)
--Testcase 434:
EXPLAIN VERBOSE
SELECT atan2(value3, 2), pi(), 4.1 FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: atan2(value3, '2'::double precision), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan2 with non pushdown func and atan2licit constant (result)
--Testcase 435:
SELECT atan2(value3, 2), pi(), 4.1 FROM s3;
         atan2         |        pi         | ?column? 
-----------------------+-------------------+----------
 -0.049958395721942765 | 3.141592653589793 |      4.1
  -0.09966865249116204 | 3.141592653589793 |      4.1
  -0.14888994760949725 | 3.141592653589793 |      4.1
   -0.5028432109278609 | 3.141592653589793 |      4.1
   -0.8329812666744317 | 3.141592653589793 |      4.1
    -1.025932411343353 | 3.141592653589793 |      4.1
(6 rows)

-- select atan2 with order by (explain)
--Testcase 436:
EXPLAIN VERBOSE
SELECT value1, atan2(1-value3, 2) FROM s3 ORDER BY atan2(1-value3, 2);
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, atan2(('1'::double precision - value3), '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY atan2((1 - `value3`), 2) IS NULL ASC, atan2((1 - `value3`), 2) ASC
(4 rows)

-- select atan2 with order by (result)
--Testcase 437:
SELECT value1, atan2(1-value3, 2) FROM s3 ORDER BY atan2(1-value3, 2);
 value1 |       atan2        
--------+--------------------
    0.1 | 0.5028432109278609
    0.2 | 0.5404195002705842
    0.3 | 0.5763752205911837
    1.1 | 0.8097835725701669
    2.2 | 1.0121970114513341
    3.3 | 1.1354430516425942
(6 rows)

-- select atan2 with order by index (result)
--Testcase 438:
SELECT value1, atan2(1-value3, 2) FROM s3 ORDER BY 2,1;
 value1 |       atan2        
--------+--------------------
    0.1 | 0.5028432109278609
    0.2 | 0.5404195002705842
    0.3 | 0.5763752205911837
    1.1 | 0.8097835725701669
    2.2 | 1.0121970114513341
    3.3 | 1.1354430516425942
(6 rows)

-- select atan2 with order by index (result)
--Testcase 439:
SELECT value1, atan2(1-value3, 2) FROM s3 ORDER BY 1,2;
 value1 |       atan2        
--------+--------------------
    0.1 | 0.5028432109278609
    0.2 | 0.5404195002705842
    0.3 | 0.5763752205911837
    1.1 | 0.8097835725701669
    2.2 | 1.0121970114513341
    3.3 | 1.1354430516425942
(6 rows)

-- select atan2 with group by (explain)
--Testcase 440:
EXPLAIN VERBOSE
SELECT count(value1), atan2(1-value3, 2) FROM s3 GROUP BY atan2(1-value3, 2);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (atan2(('1'::double precision - value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), atan2((1 - `value3`), 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select atan2 with group by (result)
--Testcase 441:
SELECT count(value1), atan2(1-value3, 2) FROM s3 GROUP BY atan2(1-value3, 2);
 count |       atan2        
-------+--------------------
     1 | 0.5028432114998824
     1 | 0.5404195013662578
     1 | 0.5763752247813169
     1 | 0.8097835782400498
     1 | 1.0121970181484852
     1 |  1.135443047402157
(6 rows)

-- select atan2 with group by index (result)
--Testcase 442:
SELECT value1, atan2(1-value3, 2) FROM s3 GROUP BY 2,1;
 value1 |       atan2        
--------+--------------------
    0.1 | 0.5028432114998824
    0.2 | 0.5404195013662578
    0.3 | 0.5763752247813169
    1.1 | 0.8097835782400498
    2.2 | 1.0121970181484852
    3.3 |  1.135443047402157
(6 rows)

-- select atan2 with group by index (result)
--Testcase 443:
SELECT value1, atan2(1-value3, 2) FROM s3 GROUP BY 1,2;
 value1 |       atan2        
--------+--------------------
    0.1 | 0.5028432114998824
    0.2 | 0.5404195013662578
    0.3 | 0.5763752247813169
    1.1 | 0.8097835782400498
    2.2 | 1.0121970181484852
    3.3 |  1.135443047402157
(6 rows)

-- select atan2 with group by having (explain)
--Testcase 444:
EXPLAIN VERBOSE
SELECT count(value1), atan2(1-value3, 2) FROM s3 GROUP BY atan2(1-value3, 2) HAVING atan2(avg(value1), 2) > 0;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (atan2(('1'::double precision - value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), atan2((1 - `value3`), 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((atan2(avg(`value1`), 2) > 0))
(5 rows)

-- select atan2 with group by having (result)
--Testcase 445:
SELECT count(value1), atan2(1-value3, 2) FROM s3 GROUP BY atan2(1-value3, 2) HAVING atan2(avg(value1), 2) > 0;
 count |       atan2        
-------+--------------------
     1 | 0.5028432114998824
     1 | 0.5404195013662578
     1 | 0.5763752247813169
     1 | 0.8097835782400498
     1 | 1.0121970181484852
     1 |  1.135443047402157
(6 rows)

-- select atan2 with group by index having (result)
--Testcase 446:
SELECT value1, atan2(1-value3, 2) FROM s3 GROUP BY 2,1 HAVING atan2(1-value3, 2) > 0;
 value1 |       atan2        
--------+--------------------
    0.1 | 0.5028432114998824
    0.2 | 0.5404195013662578
    0.3 | 0.5763752247813169
    1.1 | 0.8097835782400498
    2.2 | 1.0121970181484852
    3.3 |  1.135443047402157
(6 rows)

-- select atan2 with group by index having (result)
--Testcase 447:
SELECT value1, atan2(1-value3, 2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |       atan2        
--------+--------------------
    1.1 | 0.8097835782400498
    2.2 | 1.0121970181484852
    3.3 |  1.135443047402157
(3 rows)

-- select atan2 and as
--Testcase 448:
SELECT atan2(value3, 2) as atan21 FROM s3;
        atan21         
-----------------------
 -0.049958395721942765
  -0.09966865249116204
  -0.14888994760949725
   -0.5028432109278609
   -0.8329812666744317
    -1.025932411343353
(6 rows)

-- select atan (stub function, explain)
--Testcase 449:
EXPLAIN VERBOSE
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..191.03 rows=1706 width=40)
   Output: atan(value1, '2'::double precision), atan((value2)::double precision, '2'::double precision), atan(value3, '2'::double precision), atan((value4)::double precision, '2'::double precision), atan('5'::double precision, '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan (stub function, result)
--Testcase 450:
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3;
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan (stub function, not pushdown constraints, explain)
--Testcase 451:
EXPLAIN VERBOSE
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3 WHERE to_hex(value2) = '64';
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.93 rows=9 width=40)
   Output: atan(value1, '2'::double precision), atan((value2)::double precision, '2'::double precision), atan(value3, '2'::double precision), atan((value4)::double precision, '2'::double precision), atan('5'::double precision, '2'::double precision)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select atan (stub function, not pushdown constraints, result)
--Testcase 452:
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan (stub function, pushdown constraints, explain)
--Testcase 453:
EXPLAIN VERBOSE
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3 WHERE value2 != 200;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.96 rows=1697 width=40)
   Output: atan(value1, '2'::double precision), atan((value2)::double precision, '2'::double precision), atan(value3, '2'::double precision), atan((value4)::double precision, '2'::double precision), atan('5'::double precision, '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select atan (stub function, pushdown constraints, result)
--Testcase 454:
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3 WHERE value2 != 200;
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan (stub function, atan in constraints, explain)
--Testcase 455:
EXPLAIN VERBOSE
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3 WHERE atan(value1, 2) != 1;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..199.23 rows=1697 width=40)
   Output: atan(value1, '2'::double precision), atan((value2)::double precision, '2'::double precision), atan(value3, '2'::double precision), atan((value4)::double precision, '2'::double precision), atan('5'::double precision, '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((atan(`value1`, 2) <> 1))
(4 rows)

-- select atan (stub function, atan in constraints, result)
--Testcase 456:
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3 WHERE atan(value1, 2) != 1;
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan (stub function, atan in constraints, explain)
--Testcase 457:
EXPLAIN VERBOSE
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3 WHERE atan(5, 2) > value1;
                                                                                                                        QUERY PLAN                                                                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..156.93 rows=569 width=40)
   Output: atan(value1, '2'::double precision), atan((value2)::double precision, '2'::double precision), atan(value3, '2'::double precision), atan((value4)::double precision, '2'::double precision), atan('5'::double precision, '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((atan(5, 2) > `value1`))
(4 rows)

-- select atan (stub function, atan in constraints, result)
--Testcase 458:
SELECT atan(value1, 2), atan(value2, 2), atan(value3, 2), atan(value4, 2), atan(5, 2) FROM s3 WHERE atan(5, 2) > value1;
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan as nest function with agg (pushdown, explain)
--Testcase 459:
EXPLAIN VERBOSE
SELECT sum(value3),atan(sum(value3), 2) FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (atan(sum(value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), atan(sum(`value3`), 2) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select atan as nest function with agg (pushdown, result)
--Testcase 460:
SELECT sum(value3),atan(sum(value3), 2) FROM s3;
        sum         |        atan        
--------------------+--------------------
 -7.200000040233135 | -1.299849477897491
(1 row)

-- select atan as nest with log2 (pushdown, explain)
--Testcase 461:
EXPLAIN VERBOSE
SELECT atan(log2(value1), 2),atan(log2(1/value1), 2) FROM s3;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: atan(log2(value1), '2'::double precision), atan(log2(('1'::double precision / value1)), '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan as nest with log2 (pushdown, result)
--Testcase 462:
SELECT atan(log2(value1), 2),atan(log2(1/value1), 2) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select atan with non pushdown func and atanlicit constant (explain)
--Testcase 463:
EXPLAIN VERBOSE
SELECT atan(value3, 2), pi(), 4.1 FROM s3;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: atan(value3, '2'::double precision), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select atan with non pushdown func and atanlicit constant (result)
--Testcase 464:
SELECT atan(value3, 2), pi(), 4.1 FROM s3;
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan with order by (explain)
--Testcase 465:
EXPLAIN VERBOSE
SELECT value1, atan(1-value3, 2) FROM s3 ORDER BY atan(1-value3, 2);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, atan(('1'::double precision - value3), '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY atan((1 - `value3`), 2) IS NULL ASC, atan((1 - `value3`), 2) ASC
(4 rows)

-- select atan with order by (result)
--Testcase 466:
SELECT value1, atan(1-value3, 2) FROM s3 ORDER BY atan(1-value3, 2);
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan with order by index (result)
--Testcase 467:
SELECT value1, atan(1-value3, 2) FROM s3 ORDER BY 2,1;
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan with order by index (result)
--Testcase 468:
SELECT value1, atan(1-value3, 2) FROM s3 ORDER BY 1,2;
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select atan with group by (explain)
--Testcase 469:
EXPLAIN VERBOSE
SELECT count(value1), atan(1-value3, 2) FROM s3 GROUP BY atan(1-value3, 2);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (atan(('1'::double precision - value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), atan((1 - `value3`), 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select atan with group by (result)
--Testcase 470:
SELECT count(value1), atan(1-value3, 2) FROM s3 GROUP BY atan(1-value3, 2);
 count |        atan        
-------+--------------------
     1 | 0.5028432114998824
     1 | 0.5404195013662578
     1 | 0.5763752247813169
     1 | 0.8097835782400498
     1 | 1.0121970181484852
     1 |  1.135443047402157
(6 rows)

-- select atan with group by index (result)
--Testcase 471:
SELECT value1, atan(1-value3, 2) FROM s3 GROUP BY 2,1;
 value1 |        atan        
--------+--------------------
    0.1 | 0.5028432114998824
    0.2 | 0.5404195013662578
    0.3 | 0.5763752247813169
    1.1 | 0.8097835782400498
    2.2 | 1.0121970181484852
    3.3 |  1.135443047402157
(6 rows)

-- select atan with group by index (result)
--Testcase 472:
SELECT value1, atan(1-value3, 2) FROM s3 GROUP BY 1,2;
 value1 |        atan        
--------+--------------------
    0.1 | 0.5028432114998824
    0.2 | 0.5404195013662578
    0.3 | 0.5763752247813169
    1.1 | 0.8097835782400498
    2.2 | 1.0121970181484852
    3.3 |  1.135443047402157
(6 rows)

-- select atan with group by having (explain)
--Testcase 473:
EXPLAIN VERBOSE
SELECT count(value1), atan(1-value3, 2) FROM s3 GROUP BY atan(1-value3, 2) HAVING avg(value1) > 0;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (atan(('1'::double precision - value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), atan((1 - `value3`), 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select atan with group by having (result)
--Testcase 474:
SELECT count(value1), atan(1-value3, 2) FROM s3 GROUP BY atan(1-value3, 2) HAVING avg(value1) > 0;
 count |        atan        
-------+--------------------
     1 | 0.5028432114998824
     1 | 0.5404195013662578
     1 | 0.5763752247813169
     1 | 0.8097835782400498
     1 | 1.0121970181484852
     1 |  1.135443047402157
(6 rows)

-- select atan with group by index having (result)
--Testcase 475:
SELECT value3, atan(1-value3, 2) FROM s3 GROUP BY 2,1 HAVING atan(1-value3, 2) > 0;
 value3 |        atan        
--------+--------------------
   -0.1 | 0.5028432114998824
   -0.2 | 0.5404195013662578
   -0.3 | 0.5763752247813169
   -1.1 | 0.8097835782400498
   -2.2 | 1.0121970181484852
   -3.3 |  1.135443047402157
(6 rows)

-- select atan with group by index having (result)
--Testcase 476:
SELECT value1, atan(1-value3, 2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |        atan        
--------+--------------------
    1.1 | 0.8097835782400498
    2.2 | 1.0121970181484852
    3.3 |  1.135443047402157
(3 rows)

-- select atan and as
--Testcase 477:
SELECT atan(value3, 2) as atan1 FROM s3;
ERROR:  stub atan(float8, float8) is called
CONTEXT:  PL/pgSQL function atan(double precision,double precision) line 3 at RAISE
-- select ceil (builtin function, explain)
--Testcase 478:
EXPLAIN VERBOSE
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=64)
   Output: ceil(value1), ceil((value2)::double precision), ceil(value3), ceil((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ceil (builtin function, result)
--Testcase 479:
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3;
 ceil | ceil | ceil | ceil | ceil 
------+------+------+------+------
    1 |  100 |   -0 | -100 |    1
    1 |  100 |   -0 | -100 |    1
    1 |  100 |   -0 | -100 |    1
    2 |  200 |   -1 | -200 |    1
    3 |  200 |   -2 | -200 |    1
    4 |  200 |   -3 | -200 |    1
(6 rows)

-- select ceil (builtin function, not pushdown constraints, explain)
--Testcase 480:
EXPLAIN VERBOSE
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=64)
   Output: ceil(value1), ceil((value2)::double precision), ceil(value3), ceil((value4)::double precision), '1'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ceil (builtin function, not pushdown constraints, result)
--Testcase 481:
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3 WHERE to_hex(value2) = '64';
 ceil | ceil | ceil | ceil | ceil 
------+------+------+------+------
    1 |  100 |   -0 | -100 |    1
    1 |  100 |   -0 | -100 |    1
    1 |  100 |   -0 | -100 |    1
(3 rows)

-- select ceil (builtin function, pushdown constraints, explain)
--Testcase 482:
EXPLAIN VERBOSE
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3 WHERE value2 != 200;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=64)
   Output: ceil(value1), ceil((value2)::double precision), ceil(value3), ceil((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select ceil (builtin function, pushdown constraints, result)
--Testcase 483:
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3 WHERE value2 != 200;
 ceil | ceil | ceil | ceil | ceil 
------+------+------+------+------
    1 |  100 |   -0 | -100 |    1
    1 |  100 |   -0 | -100 |    1
    1 |  100 |   -0 | -100 |    1
(3 rows)

-- select ceil (builtin function, ceil in constraints, explain)
--Testcase 484:
EXPLAIN VERBOSE
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3 WHERE ceil(value1) != 1;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=64)
   Output: ceil(value1), ceil((value2)::double precision), ceil(value3), ceil((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((ceil(`value1`) <> 1))
(4 rows)

-- select ceil (builtin function, ceil in constraints, result)
--Testcase 485:
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3 WHERE ceil(value1) != 1;
 ceil | ceil | ceil | ceil | ceil 
------+------+------+------+------
    2 |  200 |   -1 | -200 |    1
    3 |  200 |   -2 | -200 |    1
    4 |  200 |   -3 | -200 |    1
(3 rows)

-- select ceil (builtin function, ceil in constraints, explain)
--Testcase 486:
EXPLAIN VERBOSE
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3 WHERE ceil(0.5) > value1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=64)
   Output: ceil(value1), ceil((value2)::double precision), ceil(value3), ceil((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1 > `value1`))
(4 rows)

-- select ceil (builtin function, ceil in constraints, result)
--Testcase 487:
SELECT ceil(value1), ceil(value2), ceil(value3), ceil(value4), ceil(0.5) FROM s3 WHERE ceil(0.5) > value1;
 ceil | ceil | ceil | ceil | ceil 
------+------+------+------+------
    1 |  100 |   -0 | -100 |    1
    1 |  100 |   -0 | -100 |    1
    1 |  100 |   -0 | -100 |    1
(3 rows)

-- select ceil as nest function with agg (pushdown, explain)
--Testcase 488:
EXPLAIN VERBOSE
SELECT sum(value3),ceil(sum(value3)) FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (ceil(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), ceil(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ceil as nest function with agg (pushdown, result)
--Testcase 489:
SELECT sum(value3),ceil(sum(value3)) FROM s3;
        sum         | ceil 
--------------------+------
 -7.200000040233135 |   -7
(1 row)

-- select ceil as nest with log2 (pushdown, explain)
--Testcase 490:
EXPLAIN VERBOSE
SELECT ceil(log2(value1)),ceil(log2(1/value1)) FROM s3;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: ceil(log2(value1)), ceil(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ceil as nest with log2 (pushdown, result)
--Testcase 491:
SELECT ceil(log2(value1)),ceil(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select ceil with non pushdown func and explicit constant (explain)
--Testcase 492:
EXPLAIN VERBOSE
SELECT ceil(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: ceil(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ceil with non pushdown func and explicit constant (result)
--Testcase 493:
SELECT ceil(value3), pi(), 4.1 FROM s3;
 ceil |        pi         | ?column? 
------+-------------------+----------
   -0 | 3.141592653589793 |      4.1
   -0 | 3.141592653589793 |      4.1
   -0 | 3.141592653589793 |      4.1
   -1 | 3.141592653589793 |      4.1
   -2 | 3.141592653589793 |      4.1
   -3 | 3.141592653589793 |      4.1
(6 rows)

-- select ceil with order by (explain)
--Testcase 494:
EXPLAIN VERBOSE
SELECT value1, ceil(1-value3) FROM s3 ORDER BY ceil(1-value3);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, ceil(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY ceil((1 - `value3`)) IS NULL ASC, ceil((1 - `value3`)) ASC
(4 rows)

-- select ceil with order by (result)
--Testcase 495:
SELECT value1, ceil(1-value3) FROM s3 ORDER BY ceil(1-value3);
 value1 | ceil 
--------+------
    0.1 |    2
    0.2 |    2
    0.3 |    2
    1.1 |    3
    2.2 |    4
    3.3 |    5
(6 rows)

-- select ceil with order by index (result)
--Testcase 496:
SELECT value1, ceil(1-value3) FROM s3 ORDER BY 2,1;
 value1 | ceil 
--------+------
    0.1 |    2
    0.2 |    2
    0.3 |    2
    1.1 |    3
    2.2 |    4
    3.3 |    5
(6 rows)

-- select ceil with order by index (result)
--Testcase 497:
SELECT value1, ceil(1-value3) FROM s3 ORDER BY 1,2;
 value1 | ceil 
--------+------
    0.1 |    2
    0.2 |    2
    0.3 |    2
    1.1 |    3
    2.2 |    4
    3.3 |    5
(6 rows)

-- select ceil with group by (explain)
--Testcase 498:
EXPLAIN VERBOSE
SELECT value1, ceil(1-value3) FROM s3 GROUP BY value1, ceil(1-value3);
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=16)
   Output: value1, (ceil(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, ceil((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select ceil with group by (result)
--Testcase 499:
SELECT value1, ceil(1-value3) FROM s3 GROUP BY value1, ceil(1-value3);
 value1 | ceil 
--------+------
    0.1 |    2
    0.2 |    2
    0.3 |    2
    1.1 |    3
    2.2 |    4
    3.3 |    5
(6 rows)

-- select ceil with group by index (result)
--Testcase 500:
SELECT value1, ceil(1-value3) FROM s3 GROUP BY 2,1;
 value1 | ceil 
--------+------
    0.1 |    2
    0.2 |    2
    0.3 |    2
    1.1 |    3
    2.2 |    4
    3.3 |    5
(6 rows)

-- select ceil with group by index (result)
--Testcase 501:
SELECT value1, ceil(1-value3) FROM s3 GROUP BY 1,2;
 value1 | ceil 
--------+------
    0.1 |    2
    0.2 |    2
    0.3 |    2
    1.1 |    3
    2.2 |    4
    3.3 |    5
(6 rows)

-- select ceil with group by having (explain)
--Testcase 502:
EXPLAIN VERBOSE
SELECT value1, ceil(1-value3) FROM s3 GROUP BY value1, ceil(1-value3) HAVING ceil(avg(value1)) > 0;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=16)
   Output: value1, (ceil(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, ceil((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((ceil(avg(`value1`)) > 0))
(5 rows)

-- select ceil with group by having (result)
--Testcase 503:
SELECT value1, ceil(1-value3) FROM s3 GROUP BY value1, ceil(1-value3) HAVING ceil(avg(value1)) > 0;
 value1 | ceil 
--------+------
    0.1 |    2
    0.2 |    2
    0.3 |    2
    1.1 |    3
    2.2 |    4
    3.3 |    5
(6 rows)

-- select ceil with group by index having (result)
--Testcase 504:
SELECT value1, ceil(1-value3) FROM s3 GROUP BY 2,1 HAVING ceil(1-value3) > 0;
 value1 | ceil 
--------+------
    0.1 |    2
    0.2 |    2
    0.3 |    2
    1.1 |    3
    2.2 |    4
    3.3 |    5
(6 rows)

-- select ceil with group by index having (result)
--Testcase 505:
SELECT value1, ceil(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | ceil 
--------+------
    1.1 |    3
    2.2 |    4
    3.3 |    5
(3 rows)

-- select ceil and as
--Testcase 506:
SELECT ceil(value3) as ceil1 FROM s3;
 ceil1 
-------
    -0
    -0
    -0
    -1
    -2
    -3
(6 rows)

-- select ceiling (builtin function, explain)
--Testcase 507:
EXPLAIN VERBOSE
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=64)
   Output: ceiling(value1), ceiling((value2)::double precision), ceiling(value3), ceiling((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ceiling (builtin function, result)
--Testcase 508:
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3;
 ceiling | ceiling | ceiling | ceiling | ceiling 
---------+---------+---------+---------+---------
       1 |     100 |      -0 |    -100 |       1
       1 |     100 |      -0 |    -100 |       1
       1 |     100 |      -0 |    -100 |       1
       2 |     200 |      -1 |    -200 |       1
       3 |     200 |      -2 |    -200 |       1
       4 |     200 |      -3 |    -200 |       1
(6 rows)

-- select ceiling (builtin function, not pushdown constraints, explain)
--Testcase 509:
EXPLAIN VERBOSE
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=64)
   Output: ceiling(value1), ceiling((value2)::double precision), ceiling(value3), ceiling((value4)::double precision), '1'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ceiling (builtin function, not pushdown constraints, result)
--Testcase 510:
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3 WHERE to_hex(value2) = '64';
 ceiling | ceiling | ceiling | ceiling | ceiling 
---------+---------+---------+---------+---------
       1 |     100 |      -0 |    -100 |       1
       1 |     100 |      -0 |    -100 |       1
       1 |     100 |      -0 |    -100 |       1
(3 rows)

-- select ceiling (builtin function, pushdown constraints, explain)
--Testcase 511:
EXPLAIN VERBOSE
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3 WHERE value2 != 200;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=64)
   Output: ceiling(value1), ceiling((value2)::double precision), ceiling(value3), ceiling((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select ceiling (builtin function, pushdown constraints, result)
--Testcase 512:
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3 WHERE value2 != 200;
 ceiling | ceiling | ceiling | ceiling | ceiling 
---------+---------+---------+---------+---------
       1 |     100 |      -0 |    -100 |       1
       1 |     100 |      -0 |    -100 |       1
       1 |     100 |      -0 |    -100 |       1
(3 rows)

-- select ceiling (builtin function, ceiling in constraints, explain)
--Testcase 513:
EXPLAIN VERBOSE
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3 WHERE ceiling(value1) != 1;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=64)
   Output: ceiling(value1), ceiling((value2)::double precision), ceiling(value3), ceiling((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((ceiling(`value1`) <> 1))
(4 rows)

-- select ceiling (builtin function, ceiling in constraints, result)
--Testcase 514:
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3 WHERE ceiling(value1) != 1;
 ceiling | ceiling | ceiling | ceiling | ceiling 
---------+---------+---------+---------+---------
       2 |     200 |      -1 |    -200 |       1
       3 |     200 |      -2 |    -200 |       1
       4 |     200 |      -3 |    -200 |       1
(3 rows)

-- select ceiling (builtin function, ceiling in constraints, explain)
--Testcase 515:
EXPLAIN VERBOSE
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3 WHERE ceiling(0.5) > value1;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=64)
   Output: ceiling(value1), ceiling((value2)::double precision), ceiling(value3), ceiling((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1 > `value1`))
(4 rows)

-- select ceiling (builtin function, ceiling in constraints, result)
--Testcase 516:
SELECT ceiling(value1), ceiling(value2), ceiling(value3), ceiling(value4), ceiling(0.5) FROM s3 WHERE ceiling(0.5) > value1;
 ceiling | ceiling | ceiling | ceiling | ceiling 
---------+---------+---------+---------+---------
       1 |     100 |      -0 |    -100 |       1
       1 |     100 |      -0 |    -100 |       1
       1 |     100 |      -0 |    -100 |       1
(3 rows)

-- select ceiling as nest function with agg (pushdown, explain)
--Testcase 517:
EXPLAIN VERBOSE
SELECT sum(value3),ceiling(sum(value3)) FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (ceiling(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), ceiling(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ceiling as nest function with agg (pushdown, result)
--Testcase 518:
SELECT sum(value3),ceiling(sum(value3)) FROM s3;
        sum         | ceiling 
--------------------+---------
 -7.200000040233135 |      -7
(1 row)

-- select ceiling as nest with log2 (pushdown, explain)
--Testcase 519:
EXPLAIN VERBOSE
SELECT ceiling(log2(value1)),ceiling(log2(1/value1)) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: ceiling(log2(value1)), ceiling(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ceiling as nest with log2 (pushdown, result)
--Testcase 520:
SELECT ceiling(log2(value1)),ceiling(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select ceiling with non pushdown func and explicit constant (explain)
--Testcase 521:
EXPLAIN VERBOSE
SELECT ceiling(value3), pi(), 4.1 FROM s3;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: ceiling(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ceiling with non pushdown func and explicit constant (result)
--Testcase 522:
SELECT ceiling(value3), pi(), 4.1 FROM s3;
 ceiling |        pi         | ?column? 
---------+-------------------+----------
      -0 | 3.141592653589793 |      4.1
      -0 | 3.141592653589793 |      4.1
      -0 | 3.141592653589793 |      4.1
      -1 | 3.141592653589793 |      4.1
      -2 | 3.141592653589793 |      4.1
      -3 | 3.141592653589793 |      4.1
(6 rows)

-- select ceiling with order by (explain)
--Testcase 523:
EXPLAIN VERBOSE
SELECT value1, ceiling(1-value3) FROM s3 ORDER BY ceiling(1-value3);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, ceiling(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY ceiling((1 - `value3`)) IS NULL ASC, ceiling((1 - `value3`)) ASC
(4 rows)

-- select ceiling with order by (result)
--Testcase 524:
SELECT value1, ceiling(1-value3) FROM s3 ORDER BY ceiling(1-value3);
 value1 | ceiling 
--------+---------
    0.1 |       2
    0.2 |       2
    0.3 |       2
    1.1 |       3
    2.2 |       4
    3.3 |       5
(6 rows)

-- select ceiling with order by index (result)
--Testcase 525:
SELECT value1, ceiling(1-value3) FROM s3 ORDER BY 2,1;
 value1 | ceiling 
--------+---------
    0.1 |       2
    0.2 |       2
    0.3 |       2
    1.1 |       3
    2.2 |       4
    3.3 |       5
(6 rows)

-- select ceiling with order by index (result)
--Testcase 526:
SELECT value1, ceiling(1-value3) FROM s3 ORDER BY 1,2;
 value1 | ceiling 
--------+---------
    0.1 |       2
    0.2 |       2
    0.3 |       2
    1.1 |       3
    2.2 |       4
    3.3 |       5
(6 rows)

-- select ceiling with group by (explain)
--Testcase 527:
EXPLAIN VERBOSE
SELECT count(value1), ceiling(1-value3) FROM s3 GROUP BY ceiling(1-value3);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (ceiling(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ceiling((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select ceiling with group by (result)
--Testcase 528:
SELECT count(value1), ceiling(1-value3) FROM s3 GROUP BY ceiling(1-value3);
 count | ceiling 
-------+---------
     3 |       2
     1 |       3
     1 |       4
     1 |       5
(4 rows)

-- select ceiling with group by index (result)
--Testcase 529:
SELECT value1, ceiling(1-value3) FROM s3 GROUP BY 2,1;
 value1 | ceiling 
--------+---------
    0.1 |       2
    0.2 |       2
    0.3 |       2
    1.1 |       3
    2.2 |       4
    3.3 |       5
(6 rows)

-- select ceiling with group by index (result)
--Testcase 530:
SELECT value1, ceiling(1-value3) FROM s3 GROUP BY 1,2;
 value1 | ceiling 
--------+---------
    0.1 |       2
    0.2 |       2
    0.3 |       2
    1.1 |       3
    2.2 |       4
    3.3 |       5
(6 rows)

-- select ceiling with group by having (explain)
--Testcase 531:
EXPLAIN VERBOSE
SELECT count(value1), ceiling(1-value3) FROM s3 GROUP BY ceiling(1-value3) HAVING ceiling(avg(value1)) > 0;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (ceiling(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ceiling((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((ceiling(avg(`value1`)) > 0))
(5 rows)

-- select ceiling with group by having (result)
--Testcase 532:
SELECT count(value1), ceiling(1-value3) FROM s3 GROUP BY ceiling(1-value3) HAVING ceiling(avg(value1)) > 0;
 count | ceiling 
-------+---------
     3 |       2
     1 |       3
     1 |       4
     1 |       5
(4 rows)

-- select ceiling with group by index having (result)
--Testcase 533:
SELECT value1, ceiling(1-value3) FROM s3 GROUP BY 2,1 HAVING ceiling(1-value3) > 0;
 value1 | ceiling 
--------+---------
    0.1 |       2
    0.2 |       2
    0.3 |       2
    1.1 |       3
    2.2 |       4
    3.3 |       5
(6 rows)

-- select ceiling with group by index having (result)
--Testcase 534:
SELECT value1, ceiling(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | ceiling 
--------+---------
    1.1 |       3
    2.2 |       4
    3.3 |       5
(3 rows)

-- select ceiling and as
--Testcase 535:
SELECT ceiling(value3) as ceiling1 FROM s3;
 ceiling1 
----------
       -0
       -0
       -0
       -1
       -2
       -3
(6 rows)

-- select cos (builtin function, explain)
--Testcase 536:
EXPLAIN VERBOSE
SELECT value1, cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..182.50 rows=1706 width=40)
   Output: value1, cos((value2)::double precision), cos(value3), cos((value4)::double precision), '0.8775825618903728'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select cos (builtin function, result)
--Testcase 537:
SELECT value1, cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3;
 value1 |         cos         |         cos         |         cos         |        cos         
--------+---------------------+---------------------+---------------------+--------------------
    0.1 |  0.8623188722876839 |  0.9950041652780258 |  0.8623188722876839 | 0.8775825618903728
    0.2 |  0.8623188722876839 |  0.9800665778412416 |  0.8623188722876839 | 0.8775825618903728
    0.3 |  0.8623188722876839 |   0.955336489125606 |  0.8623188722876839 | 0.8775825618903728
    1.1 | 0.48718767500700594 |  0.4535961214255773 | 0.48718767500700594 | 0.8775825618903728
    2.2 | 0.48718767500700594 | -0.5885011172553458 | 0.48718767500700594 | 0.8775825618903728
    3.3 | 0.48718767500700594 | -0.9874797699088649 | 0.48718767500700594 | 0.8775825618903728
(6 rows)

-- select cos (builtin function, not pushdown constraints, explain)
--Testcase 538:
EXPLAIN VERBOSE
SELECT cos(value1), cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: cos(value1), cos((value2)::double precision), cos(value3), cos((value4)::double precision), '0.8775825618903728'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select cos (builtin function, not pushdown constraints, result)
--Testcase 539:
SELECT cos(value1), cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3 WHERE to_hex(value2) = '64';
        cos         |        cos         |        cos         |        cos         |        cos         
--------------------+--------------------+--------------------+--------------------+--------------------
 0.9950041652780258 | 0.8623188722876839 | 0.9950041652780258 | 0.8623188722876839 | 0.8775825618903728
 0.9800665778412416 | 0.8623188722876839 | 0.9800665778412416 | 0.8623188722876839 | 0.8775825618903728
  0.955336489125606 | 0.8623188722876839 |  0.955336489125606 | 0.8623188722876839 | 0.8775825618903728
(3 rows)

-- select cos (builtin function, pushdown constraints, explain)
--Testcase 540:
EXPLAIN VERBOSE
SELECT cos(value1), cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3 WHERE value2 != 200;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: cos(value1), cos((value2)::double precision), cos(value3), cos((value4)::double precision), '0.8775825618903728'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select cos (builtin function, pushdown constraints, result)
--Testcase 541:
SELECT cos(value1), cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3 WHERE value2 != 200;
        cos         |        cos         |        cos         |        cos         |        cos         
--------------------+--------------------+--------------------+--------------------+--------------------
 0.9950041652780258 | 0.8623188722876839 | 0.9950041652780258 | 0.8623188722876839 | 0.8775825618903728
 0.9800665778412416 | 0.8623188722876839 | 0.9800665778412416 | 0.8623188722876839 | 0.8775825618903728
  0.955336489125606 | 0.8623188722876839 |  0.955336489125606 | 0.8623188722876839 | 0.8775825618903728
(3 rows)

-- select cos (builtin function, cos in constraints, explain)
--Testcase 542:
EXPLAIN VERBOSE
SELECT value1, cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3 WHERE cos(value1) != 1;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.74 rows=1697 width=40)
   Output: value1, cos((value2)::double precision), cos(value3), cos((value4)::double precision), '0.8775825618903728'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((cos(`value1`) <> 1))
(4 rows)

-- select cos (builtin function, cos in constraints, result)
--Testcase 543:
SELECT value1, cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3 WHERE cos(value1) != 1;
 value1 |         cos         |         cos         |         cos         |        cos         
--------+---------------------+---------------------+---------------------+--------------------
    0.1 |  0.8623188722876839 |  0.9950041652780258 |  0.8623188722876839 | 0.8775825618903728
    0.2 |  0.8623188722876839 |  0.9800665778412416 |  0.8623188722876839 | 0.8775825618903728
    0.3 |  0.8623188722876839 |   0.955336489125606 |  0.8623188722876839 | 0.8775825618903728
    1.1 | 0.48718767500700594 |  0.4535961214255773 | 0.48718767500700594 | 0.8775825618903728
    2.2 | 0.48718767500700594 | -0.5885011172553458 | 0.48718767500700594 | 0.8775825618903728
    3.3 | 0.48718767500700594 | -0.9874797699088649 | 0.48718767500700594 | 0.8775825618903728
(6 rows)

-- select cos (builtin function, cos in constraints, explain)
--Testcase 544:
EXPLAIN VERBOSE
SELECT cos(value1), cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3 WHERE cos(0.5) > value1;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=40)
   Output: cos(value1), cos((value2)::double precision), cos(value3), cos((value4)::double precision), '0.8775825618903728'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((0.8775825618903728 > `value1`))
(4 rows)

-- select cos (builtin function, cos in constraints, result)
--Testcase 545:
SELECT cos(value1), cos(value2), cos(value3), cos(value4), cos(0.5) FROM s3 WHERE cos(0.5) > value1;
        cos         |        cos         |        cos         |        cos         |        cos         
--------------------+--------------------+--------------------+--------------------+--------------------
 0.9950041652780258 | 0.8623188722876839 | 0.9950041652780258 | 0.8623188722876839 | 0.8775825618903728
 0.9800665778412416 | 0.8623188722876839 | 0.9800665778412416 | 0.8623188722876839 | 0.8775825618903728
  0.955336489125606 | 0.8623188722876839 |  0.955336489125606 | 0.8623188722876839 | 0.8775825618903728
(3 rows)

-- select cos as nest function with agg (pushdown, explain)
--Testcase 546:
EXPLAIN VERBOSE
SELECT sum(value3),cos(sum(value3)) FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (cos(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), cos(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select cos as nest function with agg (pushdown, result)
--Testcase 547:
SELECT sum(value3),cos(sum(value3)) FROM s3;
        sum         |        cos         
--------------------+--------------------
 -7.200000040233135 | 0.6083512826005076
(1 row)

-- select cos as nest with log2 (pushdown, explain)
--Testcase 548:
EXPLAIN VERBOSE
SELECT value1, cos(log2(value1)),cos(log2(1/value1)) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, cos(log2(value1)), cos(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select cos as nest with log2 (pushdown, result)
--Testcase 549:
SELECT value1, cos(log2(value1)),cos(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select cos with non pushdown func and explicit constant (explain)
--Testcase 550:
EXPLAIN VERBOSE
SELECT cos(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: cos(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select cos with non pushdown func and explicit constant (result)
--Testcase 551:
SELECT cos(value3), pi(), 4.1 FROM s3;
         cos         |        pi         | ?column? 
---------------------+-------------------+----------
  0.9950041652780258 | 3.141592653589793 |      4.1
  0.9800665778412416 | 3.141592653589793 |      4.1
   0.955336489125606 | 3.141592653589793 |      4.1
  0.4535961214255773 | 3.141592653589793 |      4.1
 -0.5885011172553458 | 3.141592653589793 |      4.1
 -0.9874797699088649 | 3.141592653589793 |      4.1
(6 rows)

-- select cos with order by (explain)
--Testcase 552:
EXPLAIN VERBOSE
SELECT value1, cos(1-value3) FROM s3 ORDER BY cos(1-value3);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, cos(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY cos((1 - `value3`)) IS NULL ASC, cos((1 - `value3`)) ASC
(4 rows)

-- select cos with order by (result)
--Testcase 553:
SELECT value1, cos(1-value3) FROM s3 ORDER BY cos(1-value3);
 value1 |         cos          
--------+----------------------
    2.2 |  -0.9982947757947531
    1.1 |  -0.5048461045998576
    3.3 | -0.40079917207997545
    0.3 |  0.26749882862458735
    0.2 |   0.3623577544766736
    0.1 |   0.4535961214255773
(6 rows)

-- select cos with order by index (result)
--Testcase 554:
SELECT value1, cos(1-value3) FROM s3 ORDER BY 2,1;
 value1 |         cos          
--------+----------------------
    2.2 |  -0.9982947757947531
    1.1 |  -0.5048461045998576
    3.3 | -0.40079917207997545
    0.3 |  0.26749882862458735
    0.2 |   0.3623577544766736
    0.1 |   0.4535961214255773
(6 rows)

-- select cos with order by index (result)
--Testcase 555:
SELECT value1, cos(1-value3) FROM s3 ORDER BY 1,2;
 value1 |         cos          
--------+----------------------
    0.1 |   0.4535961214255773
    0.2 |   0.3623577544766736
    0.3 |  0.26749882862458735
    1.1 |  -0.5048461045998576
    2.2 |  -0.9982947757947531
    3.3 | -0.40079917207997545
(6 rows)

-- select cos with group by (explain)
--Testcase 556:
EXPLAIN VERBOSE
SELECT value1, cos(1-value3) FROM s3 GROUP BY value1, cos(1-value3);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=16)
   Output: value1, (cos(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, cos((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select cos with group by (result)
--Testcase 557:
SELECT value1, cos(1-value3) FROM s3 GROUP BY value1, cos(1-value3);
 value1 |         cos         
--------+---------------------
    0.1 | 0.45359612009757494
    0.2 | 0.36235775169898066
    0.3 |  0.2674988171380787
    1.1 | -0.5048461251803724
    2.2 | -0.9982947730112559
    3.3 |  -0.400799215766171
(6 rows)

-- select cos with group by index (result)
--Testcase 558:
SELECT value1, cos(1-value3) FROM s3 GROUP BY 2,1;
 value1 |         cos         
--------+---------------------
    0.1 | 0.45359612009757494
    0.2 | 0.36235775169898066
    0.3 |  0.2674988171380787
    1.1 | -0.5048461251803724
    2.2 | -0.9982947730112559
    3.3 |  -0.400799215766171
(6 rows)

-- select cos with group by index (result)
--Testcase 559:
SELECT value1, cos(1-value3) FROM s3 GROUP BY 1,2;
 value1 |         cos         
--------+---------------------
    0.1 | 0.45359612009757494
    0.2 | 0.36235775169898066
    0.3 |  0.2674988171380787
    1.1 | -0.5048461251803724
    2.2 | -0.9982947730112559
    3.3 |  -0.400799215766171
(6 rows)

-- select cos with group by having (explain)
--Testcase 560:
EXPLAIN VERBOSE
SELECT value1, cos(1-value3) FROM s3 GROUP BY value1, cos(1-value3) HAVING cos(avg(value1)) > 0;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=16)
   Output: value1, (cos(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, cos((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((cos(avg(`value1`)) > 0))
(5 rows)

-- select cos with group by having (result)
--Testcase 561:
SELECT value1, cos(1-value3) FROM s3 GROUP BY value1, cos(1-value3) HAVING cos(avg(value1)) > 0;
 value1 |         cos         
--------+---------------------
    0.1 | 0.45359612009757494
    0.2 | 0.36235775169898066
    0.3 |  0.2674988171380787
    1.1 | -0.5048461251803724
(4 rows)

-- select cos with group by index having (result)
--Testcase 562:
SELECT value1, cos(1-value3) FROM s3 GROUP BY 2,1 HAVING cos(1-value3) > 0;
 value1 |         cos         
--------+---------------------
    0.1 | 0.45359612009757494
    0.2 | 0.36235775169898066
    0.3 |  0.2674988171380787
(3 rows)

-- select cos with group by index having (result)
--Testcase 563:
SELECT value1, cos(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |         cos         
--------+---------------------
    1.1 | -0.5048461251803724
    2.2 | -0.9982947730112559
    3.3 |  -0.400799215766171
(3 rows)

-- select cos and as
--Testcase 564:
SELECT cos(value3) as cos1 FROM s3;
        cos1         
---------------------
  0.9950041652780258
  0.9800665778412416
   0.955336489125606
  0.4535961214255773
 -0.5885011172553458
 -0.9874797699088649
(6 rows)

-- select cot (builtin function, explain)
--Testcase 565:
EXPLAIN VERBOSE
SELECT value1, cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..182.50 rows=1706 width=40)
   Output: value1, cot((value2)::double precision), cot(value3), cot((value4)::double precision), '1.830487721712452'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select cot (builtin function, result)
--Testcase 566:
SELECT value1, cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3;
 value1 |         cot         |         cot         |        cot         |        cot        
--------+---------------------+---------------------+--------------------+-------------------
    0.1 |  -1.702956919426469 |  -9.966644423259238 |  1.702956919426469 | 1.830487721712452
    0.2 |  -1.702956919426469 |  -4.933154875586893 |  1.702956919426469 | 1.830487721712452
    0.3 |  -1.702956919426469 | -3.2327281437658275 |  1.702956919426469 | 1.830487721712452
    1.1 | -0.5578715021347701 | -0.5089681052390643 | 0.5578715021347701 | 1.830487721712452
    2.2 | -0.5578715021347701 |   0.727895776004794 | 0.5578715021347701 | 1.830487721712452
    3.3 | -0.5578715021347701 |  -6.259947539437359 | 0.5578715021347701 | 1.830487721712452
(6 rows)

-- select cot (builtin function, not pushdown constraints, explain)
--Testcase 567:
EXPLAIN VERBOSE
SELECT cot(value1), cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: cot(value1), cot((value2)::double precision), cot(value3), cot((value4)::double precision), '1.830487721712452'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select cot (builtin function, not pushdown constraints, result)
--Testcase 568:
SELECT cot(value1), cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3 WHERE to_hex(value2) = '64';
        cot         |        cot         |         cot         |        cot        |        cot        
--------------------+--------------------+---------------------+-------------------+-------------------
  9.966644423259238 | -1.702956919426469 |  -9.966644423259238 | 1.702956919426469 | 1.830487721712452
  4.933154875586893 | -1.702956919426469 |  -4.933154875586893 | 1.702956919426469 | 1.830487721712452
 3.2327281437658275 | -1.702956919426469 | -3.2327281437658275 | 1.702956919426469 | 1.830487721712452
(3 rows)

-- select cot (builtin function, pushdown constraints, explain)
--Testcase 569:
EXPLAIN VERBOSE
SELECT cot(value1), cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3 WHERE value2 != 200;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: cot(value1), cot((value2)::double precision), cot(value3), cot((value4)::double precision), '1.830487721712452'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select cot (builtin function, pushdown constraints, result)
--Testcase 570:
SELECT cot(value1), cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3 WHERE value2 != 200;
        cot         |        cot         |         cot         |        cot        |        cot        
--------------------+--------------------+---------------------+-------------------+-------------------
  9.966644423259238 | -1.702956919426469 |  -9.966644423259238 | 1.702956919426469 | 1.830487721712452
  4.933154875586893 | -1.702956919426469 |  -4.933154875586893 | 1.702956919426469 | 1.830487721712452
 3.2327281437658275 | -1.702956919426469 | -3.2327281437658275 | 1.702956919426469 | 1.830487721712452
(3 rows)

-- select cot (builtin function, cot in constraints, explain)
--Testcase 571:
EXPLAIN VERBOSE
SELECT value1, cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3 WHERE cot(value1) != 1;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.74 rows=1697 width=40)
   Output: value1, cot((value2)::double precision), cot(value3), cot((value4)::double precision), '1.830487721712452'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((cot(`value1`) <> 1))
(4 rows)

-- select cot (builtin function, cot in constraints, result)
--Testcase 572:
SELECT value1, cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3 WHERE cot(value1) != 1;
 value1 |         cot         |         cot         |        cot         |        cot        
--------+---------------------+---------------------+--------------------+-------------------
    0.1 |  -1.702956919426469 |  -9.966644423259238 |  1.702956919426469 | 1.830487721712452
    0.2 |  -1.702956919426469 |  -4.933154875586893 |  1.702956919426469 | 1.830487721712452
    0.3 |  -1.702956919426469 | -3.2327281437658275 |  1.702956919426469 | 1.830487721712452
    1.1 | -0.5578715021347701 | -0.5089681052390643 | 0.5578715021347701 | 1.830487721712452
    2.2 | -0.5578715021347701 |   0.727895776004794 | 0.5578715021347701 | 1.830487721712452
    3.3 | -0.5578715021347701 |  -6.259947539437359 | 0.5578715021347701 | 1.830487721712452
(6 rows)

-- select cot (builtin function, cot in constraints, explain)
--Testcase 573:
EXPLAIN VERBOSE
SELECT value1, cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3 WHERE cot(0.5) > value1;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..149.82 rows=569 width=40)
   Output: value1, cot((value2)::double precision), cot(value3), cot((value4)::double precision), '1.830487721712452'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1.830487721712452 > `value1`))
(4 rows)

-- select cot (builtin function, cot in constraints, result)
--Testcase 574:
SELECT value1, cot(value2), cot(value3), cot(value4), cot(0.5) FROM s3 WHERE cot(0.5) > value1;
 value1 |         cot         |         cot         |        cot         |        cot        
--------+---------------------+---------------------+--------------------+-------------------
    0.1 |  -1.702956919426469 |  -9.966644423259238 |  1.702956919426469 | 1.830487721712452
    0.2 |  -1.702956919426469 |  -4.933154875586893 |  1.702956919426469 | 1.830487721712452
    0.3 |  -1.702956919426469 | -3.2327281437658275 |  1.702956919426469 | 1.830487721712452
    1.1 | -0.5578715021347701 | -0.5089681052390643 | 0.5578715021347701 | 1.830487721712452
(4 rows)

-- select cot as nest function with agg (pushdown, explain)
--Testcase 575:
EXPLAIN VERBOSE
SELECT sum(value3),cot(sum(value3)) FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (cot(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), cot(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select cot as nest function with agg (pushdown, result)
--Testcase 576:
SELECT sum(value3),cot(sum(value3)) FROM s3;
        sum         |         cot         
--------------------+---------------------
 -7.200000040233135 | -0.7665061060796853
(1 row)

-- select cot as nest with log2 (pushdown, explain)
--Testcase 577:
EXPLAIN VERBOSE
SELECT value1, cot(log2(value1)),cot(log2(1/value1)) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, cot(log2(value1)), cot(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select cot as nest with log2 (pushdown, result)
--Testcase 578:
SELECT value1, cot(log2(value1)),cot(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select cot with non pushdown func and explicit constant (explain)
--Testcase 579:
EXPLAIN VERBOSE
SELECT value1, cot(value3), pi(), 4.1 FROM s3;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..176.56 rows=2048 width=56)
   Output: value1, cot(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select cot with non pushdown func and explicit constant (result)
--Testcase 580:
SELECT value1, cot(value3), pi(), 4.1 FROM s3;
 value1 |         cot         |        pi         | ?column? 
--------+---------------------+-------------------+----------
    0.1 |  -9.966644423259238 | 3.141592653589793 |      4.1
    0.2 |  -4.933154875586893 | 3.141592653589793 |      4.1
    0.3 | -3.2327281437658275 | 3.141592653589793 |      4.1
    1.1 | -0.5089681052390643 | 3.141592653589793 |      4.1
    2.2 |   0.727895776004794 | 3.141592653589793 |      4.1
    3.3 |  -6.259947539437359 | 3.141592653589793 |      4.1
(6 rows)

-- select cot with order by (explain)
--Testcase 581:
EXPLAIN VERBOSE
SELECT value1, cot(1-value3) FROM s3 ORDER BY cot(1-value3);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, cot(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY cot((1 - `value3`)) IS NULL ASC, cot((1 - `value3`)) ASC
(4 rows)

-- select cot with order by (result)
--Testcase 582:
SELECT value1, cot(1-value3) FROM s3 ORDER BY cot(1-value3);
 value1 |         cot         
--------+---------------------
    1.1 | -0.5848478064594647
    0.3 | 0.27761564654112514
    0.2 | 0.38877956936820496
    3.3 |  0.4374744312171285
    0.1 |  0.5089681052390643
    2.2 |  17.101660378678684
(6 rows)

-- select cot with order by index (result)
--Testcase 583:
SELECT value1, cot(1-value3) FROM s3 ORDER BY 2,1;
 value1 |         cot         
--------+---------------------
    1.1 | -0.5848478064594647
    0.3 | 0.27761564654112514
    0.2 | 0.38877956936820496
    3.3 |  0.4374744312171285
    0.1 |  0.5089681052390643
    2.2 |  17.101660378678684
(6 rows)

-- select cot with order by index (result)
--Testcase 584:
SELECT value1, cot(1-value3) FROM s3 ORDER BY 1,2;
 value1 |         cot         
--------+---------------------
    0.1 |  0.5089681052390643
    0.2 | 0.38877956936820496
    0.3 | 0.27761564654112514
    1.1 | -0.5848478064594647
    2.2 |  17.101660378678684
    3.3 |  0.4374744312171285
(6 rows)

-- select cot with group by (explain)
--Testcase 585:
EXPLAIN VERBOSE
SELECT value1, cot(1-value3) FROM s3 GROUP BY value1, cot(1-value3);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=16)
   Output: value1, (cot(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, cot((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select cot with group by (result)
--Testcase 586:
SELECT value1, cot(1-value3) FROM s3 GROUP BY value1, cot(1-value3);
 value1 |         cot         
--------+---------------------
    0.1 |  0.5089681033629359
    0.2 |  0.3887795659375119
    0.3 | 0.27761563370144493
    1.1 | -0.5848478384563578
    2.2 |   17.10164638510324
    3.3 |  0.4374744880267397
(6 rows)

-- select cot with group by index (result)
--Testcase 587:
SELECT value1, cot(1-value3) FROM s3 GROUP BY 2,1;
 value1 |         cot         
--------+---------------------
    0.1 |  0.5089681033629359
    0.2 |  0.3887795659375119
    0.3 | 0.27761563370144493
    1.1 | -0.5848478384563578
    2.2 |   17.10164638510324
    3.3 |  0.4374744880267397
(6 rows)

-- select cot with group by index (result)
--Testcase 588:
SELECT value1, cot(1-value3) FROM s3 GROUP BY 1,2;
 value1 |         cot         
--------+---------------------
    0.1 |  0.5089681033629359
    0.2 |  0.3887795659375119
    0.3 | 0.27761563370144493
    1.1 | -0.5848478384563578
    2.2 |   17.10164638510324
    3.3 |  0.4374744880267397
(6 rows)

-- select cot with group by having (explain)
--Testcase 589:
EXPLAIN VERBOSE
SELECT value1, cot(1-value3) FROM s3 GROUP BY value1, cot(1-value3) HAVING cot(avg(value1)) > 0;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=16)
   Output: value1, (cot(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, cot((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((cot(avg(`value1`)) > 0))
(5 rows)

-- select cot with group by having (result)
--Testcase 590:
SELECT value1, cot(1-value3) FROM s3 GROUP BY value1, cot(1-value3) HAVING cot(avg(value1)) > 0;
 value1 |         cot         
--------+---------------------
    0.1 |  0.5089681033629359
    0.2 |  0.3887795659375119
    0.3 | 0.27761563370144493
    1.1 | -0.5848478384563578
    3.3 |  0.4374744880267397
(5 rows)

-- select cot with group by index having (result)
--Testcase 591:
SELECT value1, cot(1-value3) FROM s3 GROUP BY 2,1 HAVING cot(1-value3) > 0;
 value1 |         cot         
--------+---------------------
    0.1 |  0.5089681033629359
    0.2 |  0.3887795659375119
    0.3 | 0.27761563370144493
    2.2 |   17.10164638510324
    3.3 |  0.4374744880267397
(5 rows)

-- select cot with group by index having (result)
--Testcase 592:
SELECT value1, cot(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |         cot         
--------+---------------------
    1.1 | -0.5848478384563578
    2.2 |   17.10164638510324
    3.3 |  0.4374744880267397
(3 rows)

-- select cot and as
--Testcase 593:
SELECT value1, cot(value3) as cot1 FROM s3;
 value1 |        cot1         
--------+---------------------
    0.1 |  -9.966644423259238
    0.2 |  -4.933154875586893
    0.3 | -3.2327281437658275
    1.1 | -0.5089681052390643
    2.2 |   0.727895776004794
    3.3 |  -6.259947539437359
(6 rows)

-- select degrees (builtin function, explain)
--Testcase 594:
EXPLAIN VERBOSE
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=40)
   Output: degrees(value1), degrees((value2)::double precision), degrees(value3), degrees((value4)::double precision), '28.64788975654116'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select degrees (builtin function, result)
--Testcase 595:
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3;
      degrees       |      degrees       |       degrees       |       degrees       |      degrees      
--------------------+--------------------+---------------------+---------------------+-------------------
  5.729577951308232 | 5729.5779513082325 |  -5.729577951308232 | -5729.5779513082325 | 28.64788975654116
 11.459155902616464 | 5729.5779513082325 | -11.459155902616464 | -5729.5779513082325 | 28.64788975654116
 17.188733853924695 | 5729.5779513082325 | -17.188733853924695 | -5729.5779513082325 | 28.64788975654116
  63.02535746439056 | 11459.155902616465 |  -63.02535746439056 | -11459.155902616465 | 28.64788975654116
 126.05071492878112 | 11459.155902616465 | -126.05071492878112 | -11459.155902616465 | 28.64788975654116
 189.07607239317164 | 11459.155902616465 | -189.07607239317164 | -11459.155902616465 | 28.64788975654116
(6 rows)

-- select degrees (builtin function, not pushdown constraints, explain)
--Testcase 596:
EXPLAIN VERBOSE
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: degrees(value1), degrees((value2)::double precision), degrees(value3), degrees((value4)::double precision), '28.64788975654116'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select degrees (builtin function, not pushdown constraints, result)
--Testcase 597:
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3 WHERE to_hex(value2) = '64';
      degrees       |      degrees       |       degrees       |       degrees       |      degrees      
--------------------+--------------------+---------------------+---------------------+-------------------
  5.729577951308232 | 5729.5779513082325 |  -5.729577951308232 | -5729.5779513082325 | 28.64788975654116
 11.459155902616464 | 5729.5779513082325 | -11.459155902616464 | -5729.5779513082325 | 28.64788975654116
 17.188733853924695 | 5729.5779513082325 | -17.188733853924695 | -5729.5779513082325 | 28.64788975654116
(3 rows)

-- select degrees (builtin function, pushdown constraints, explain)
--Testcase 598:
EXPLAIN VERBOSE
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3 WHERE value2 != 200;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: degrees(value1), degrees((value2)::double precision), degrees(value3), degrees((value4)::double precision), '28.64788975654116'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select degrees (builtin function, pushdown constraints, result)
--Testcase 599:
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3 WHERE value2 != 200;
      degrees       |      degrees       |       degrees       |       degrees       |      degrees      
--------------------+--------------------+---------------------+---------------------+-------------------
  5.729577951308232 | 5729.5779513082325 |  -5.729577951308232 | -5729.5779513082325 | 28.64788975654116
 11.459155902616464 | 5729.5779513082325 | -11.459155902616464 | -5729.5779513082325 | 28.64788975654116
 17.188733853924695 | 5729.5779513082325 | -17.188733853924695 | -5729.5779513082325 | 28.64788975654116
(3 rows)

-- select degrees (builtin function, degrees in constraints, explain)
--Testcase 600:
EXPLAIN VERBOSE
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3 WHERE degrees(value1) != 1;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=40)
   Output: degrees(value1), degrees((value2)::double precision), degrees(value3), degrees((value4)::double precision), '28.64788975654116'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((degrees(`value1`) <> 1))
(4 rows)

-- select degrees (builtin function, degrees in constraints, result)
--Testcase 601:
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3 WHERE degrees(value1) != 1;
      degrees       |      degrees       |       degrees       |       degrees       |      degrees      
--------------------+--------------------+---------------------+---------------------+-------------------
  5.729577951308232 | 5729.5779513082325 |  -5.729577951308232 | -5729.5779513082325 | 28.64788975654116
 11.459155902616464 | 5729.5779513082325 | -11.459155902616464 | -5729.5779513082325 | 28.64788975654116
 17.188733853924695 | 5729.5779513082325 | -17.188733853924695 | -5729.5779513082325 | 28.64788975654116
  63.02535746439056 | 11459.155902616465 |  -63.02535746439056 | -11459.155902616465 | 28.64788975654116
 126.05071492878112 | 11459.155902616465 | -126.05071492878112 | -11459.155902616465 | 28.64788975654116
 189.07607239317164 | 11459.155902616465 | -189.07607239317164 | -11459.155902616465 | 28.64788975654116
(6 rows)

-- select degrees (builtin function, degrees in constraints, explain)
--Testcase 602:
EXPLAIN VERBOSE
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3 WHERE degrees(0.5) > value1;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=40)
   Output: degrees(value1), degrees((value2)::double precision), degrees(value3), degrees((value4)::double precision), '28.64788975654116'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((28.64788975654116 > `value1`))
(4 rows)

-- select degrees (builtin function, degrees in constraints, result)
--Testcase 603:
SELECT degrees(value1), degrees(value2), degrees(value3), degrees(value4), degrees(0.5) FROM s3 WHERE degrees(0.5) > value1;
      degrees       |      degrees       |       degrees       |       degrees       |      degrees      
--------------------+--------------------+---------------------+---------------------+-------------------
  5.729577951308232 | 5729.5779513082325 |  -5.729577951308232 | -5729.5779513082325 | 28.64788975654116
 11.459155902616464 | 5729.5779513082325 | -11.459155902616464 | -5729.5779513082325 | 28.64788975654116
 17.188733853924695 | 5729.5779513082325 | -17.188733853924695 | -5729.5779513082325 | 28.64788975654116
  63.02535746439056 | 11459.155902616465 |  -63.02535746439056 | -11459.155902616465 | 28.64788975654116
 126.05071492878112 | 11459.155902616465 | -126.05071492878112 | -11459.155902616465 | 28.64788975654116
 189.07607239317164 | 11459.155902616465 | -189.07607239317164 | -11459.155902616465 | 28.64788975654116
(6 rows)

-- select degrees as nest function with agg (pushdown, explain)
--Testcase 604:
EXPLAIN VERBOSE
SELECT sum(value3),degrees(sum(value3)) FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (degrees(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), degrees(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select degrees as nest function with agg (pushdown, result)
--Testcase 605:
SELECT sum(value3),degrees(sum(value3)) FROM s3;
        sum         |      degrees       
--------------------+--------------------
 -7.200000040233135 | -412.5296147993816
(1 row)

-- select degrees as nest with log2 (pushdown, explain)
--Testcase 606:
EXPLAIN VERBOSE
SELECT value1, degrees(log2(value1)),degrees(log2(1/value1)) FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, degrees(log2(value1)), degrees(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select degrees as nest with log2 (pushdown, result)
--Testcase 607:
SELECT value1, degrees(log2(value1)),degrees(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select degrees with non pushdown func and explicit constant (explain)
--Testcase 608:
EXPLAIN VERBOSE
SELECT degrees(value3), pi(), 4.1 FROM s3;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: degrees(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select degrees with non pushdown func and explicit constant (result)
--Testcase 609:
SELECT degrees(value3), pi(), 4.1 FROM s3;
       degrees       |        pi         | ?column? 
---------------------+-------------------+----------
  -5.729577951308232 | 3.141592653589793 |      4.1
 -11.459155902616464 | 3.141592653589793 |      4.1
 -17.188733853924695 | 3.141592653589793 |      4.1
  -63.02535746439056 | 3.141592653589793 |      4.1
 -126.05071492878112 | 3.141592653589793 |      4.1
 -189.07607239317164 | 3.141592653589793 |      4.1
(6 rows)

-- select degrees with order by (explain)
--Testcase 610:
EXPLAIN VERBOSE
SELECT value1, degrees(1-value3) FROM s3 ORDER BY degrees(1-value3);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, degrees(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY degrees((1 - `value3`)) IS NULL ASC, degrees((1 - `value3`)) ASC
(4 rows)

-- select degrees with order by (result)
--Testcase 611:
SELECT value1, degrees(1-value3) FROM s3 ORDER BY degrees(1-value3);
 value1 |      degrees       
--------+--------------------
    0.1 |  63.02535746439056
    0.2 |  68.75493541569878
    0.3 |  74.48451336700703
    1.1 | 120.32113697747288
    2.2 | 183.34649444186343
    3.3 | 246.37185190625397
(6 rows)

-- select degrees with order by index (result)
--Testcase 612:
SELECT value1, degrees(1-value3) FROM s3 ORDER BY 2,1;
 value1 |      degrees       
--------+--------------------
    0.1 |  63.02535746439056
    0.2 |  68.75493541569878
    0.3 |  74.48451336700703
    1.1 | 120.32113697747288
    2.2 | 183.34649444186343
    3.3 | 246.37185190625397
(6 rows)

-- select degrees with order by index (result)
--Testcase 613:
SELECT value1, degrees(1-value3) FROM s3 ORDER BY 1,2;
 value1 |      degrees       
--------+--------------------
    0.1 |  63.02535746439056
    0.2 |  68.75493541569878
    0.3 |  74.48451336700703
    1.1 | 120.32113697747288
    2.2 | 183.34649444186343
    3.3 | 246.37185190625397
(6 rows)

-- select degrees with group by (explain)
--Testcase 614:
EXPLAIN VERBOSE
SELECT count(value1), degrees(1-value3) FROM s3 GROUP BY degrees(1-value3);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (degrees(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), degrees((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select degrees with group by (result)
--Testcase 615:
SELECT count(value1), degrees(1-value3) FROM s3 GROUP BY degrees(1-value3);
 count |      degrees       
-------+--------------------
     1 |  63.02535754976792
     1 |  68.75493558645351
     1 |  74.48451405002594
     1 | 120.32113834351071
     1 |  183.3464971739391
     1 | 246.37184917417832
(6 rows)

-- select degrees with group by index (result)
--Testcase 616:
SELECT value1, degrees(1-value3) FROM s3 GROUP BY 2,1;
 value1 |      degrees       
--------+--------------------
    0.1 |  63.02535754976792
    0.2 |  68.75493558645351
    0.3 |  74.48451405002594
    1.1 | 120.32113834351071
    2.2 |  183.3464971739391
    3.3 | 246.37184917417832
(6 rows)

-- select degrees with group by index (result)
--Testcase 617:
SELECT value1, degrees(1-value3) FROM s3 GROUP BY 1,2;
 value1 |      degrees       
--------+--------------------
    0.1 |  63.02535754976792
    0.2 |  68.75493558645351
    0.3 |  74.48451405002594
    1.1 | 120.32113834351071
    2.2 |  183.3464971739391
    3.3 | 246.37184917417832
(6 rows)

-- select degrees with group by having (explain)
--Testcase 618:
EXPLAIN VERBOSE
SELECT count(value1), degrees(1-value3) FROM s3 GROUP BY degrees(1-value3) HAVING degrees(avg(value1)) > 0;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (degrees(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), degrees((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((degrees(avg(`value1`)) > 0))
(5 rows)

-- select degrees with group by having (result)
--Testcase 619:
SELECT count(value1), degrees(1-value3) FROM s3 GROUP BY degrees(1-value3) HAVING degrees(avg(value1)) > 0;
 count |      degrees       
-------+--------------------
     1 |  63.02535754976792
     1 |  68.75493558645351
     1 |  74.48451405002594
     1 | 120.32113834351071
     1 |  183.3464971739391
     1 | 246.37184917417832
(6 rows)

-- select degrees with group by index having (result)
--Testcase 620:
SELECT value1, degrees(1-value3) FROM s3 GROUP BY 2,1 HAVING degrees(1-value3) > 0;
 value1 |      degrees       
--------+--------------------
    0.1 |  63.02535754976792
    0.2 |  68.75493558645351
    0.3 |  74.48451405002594
    1.1 | 120.32113834351071
    2.2 |  183.3464971739391
    3.3 | 246.37184917417832
(6 rows)

-- select degrees with group by index having (result)
--Testcase 621:
SELECT value1, degrees(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |      degrees       
--------+--------------------
    1.1 | 120.32113834351071
    2.2 |  183.3464971739391
    3.3 | 246.37184917417832
(3 rows)

-- select degrees and as
--Testcase 622:
SELECT degrees(value3) as degrees1 FROM s3;
      degrees1       
---------------------
  -5.729577951308232
 -11.459155902616464
 -17.188733853924695
  -63.02535746439056
 -126.05071492878112
 -189.07607239317164
(6 rows)

-- select div (builtin function, explain)
--Testcase 623:
EXPLAIN VERBOSE
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.30 rows=1706 width=160)
   Output: div((value1)::numeric, '2'::numeric), div((value2)::numeric, '2'::numeric), div((value3)::numeric, '2'::numeric), div((value4)::numeric, '2'::numeric), '2'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select div (builtin function, result)
--Testcase 624:
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3;
 div | div | div | div  | div 
-----+-----+-----+------+-----
   0 |  50 |   0 |  -50 |   2
   0 |  50 |   0 |  -50 |   2
   0 |  50 |   0 |  -50 |   2
   0 | 100 |   0 | -100 |   2
   1 | 100 |  -1 | -100 |   2
   1 | 100 |  -1 | -100 |   2
(6 rows)

-- select div (builtin function, not pushdown constraints, explain)
--Testcase 625:
EXPLAIN VERBOSE
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3 WHERE to_hex(value2) = '64';
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.95 rows=9 width=160)
   Output: div((value1)::numeric, '2'::numeric), div((value2)::numeric, '2'::numeric), div((value3)::numeric, '2'::numeric), div((value4)::numeric, '2'::numeric), '2'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select div (builtin function, not pushdown constraints, result)
--Testcase 626:
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3 WHERE to_hex(value2) = '64';
 div | div | div | div | div 
-----+-----+-----+-----+-----
   0 |  50 |   0 | -50 |   2
   0 |  50 |   0 | -50 |   2
   0 |  50 |   0 | -50 |   2
(3 rows)

-- select div (builtin function, pushdown constraints, explain)
--Testcase 627:
EXPLAIN VERBOSE
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3 WHERE value2 != 200;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..199.20 rows=1697 width=160)
   Output: div((value1)::numeric, '2'::numeric), div((value2)::numeric, '2'::numeric), div((value3)::numeric, '2'::numeric), div((value4)::numeric, '2'::numeric), '2'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select div (builtin function, pushdown constraints, result)
--Testcase 628:
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3 WHERE value2 != 200;
 div | div | div | div | div 
-----+-----+-----+-----+-----
   0 |  50 |   0 | -50 |   2
   0 |  50 |   0 | -50 |   2
   0 |  50 |   0 | -50 |   2
(3 rows)

-- select div (builtin function, div in constraints, explain)
--Testcase 629:
EXPLAIN VERBOSE
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3 WHERE div(value1::numeric, 2) != 1;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..207.74 rows=1697 width=160)
   Output: div((value1)::numeric, '2'::numeric), div((value2)::numeric, '2'::numeric), div((value3)::numeric, '2'::numeric), div((value4)::numeric, '2'::numeric), '2'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE (((`value1` div 2) <> 1))
(4 rows)

-- select div (builtin function, div in constraints, result)
--Testcase 630:
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3 WHERE div(value1::numeric, 2) != 1;
 div | div | div | div  | div 
-----+-----+-----+------+-----
   0 |  50 |   0 |  -50 |   2
   0 |  50 |   0 |  -50 |   2
   0 |  50 |   0 |  -50 |   2
   0 | 100 |   0 | -100 |   2
(4 rows)

-- select div (builtin function, div in constraints, explain)
--Testcase 631:
EXPLAIN VERBOSE
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3 WHERE div(5, 2) > value1;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.08 rows=569 width=160)
   Output: div((value1)::numeric, '2'::numeric), div((value2)::numeric, '2'::numeric), div((value3)::numeric, '2'::numeric), div((value4)::numeric, '2'::numeric), '2'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((2 > `value1`))
(4 rows)

-- select div (builtin function, div in constraints, result)
--Testcase 632:
SELECT div(value1::numeric, 2), div(value2::numeric, 2), div(value3::numeric, 2), div(value4::numeric, 2), div(5, 2) FROM s3 WHERE div(5, 2) > value1;
 div | div | div | div  | div 
-----+-----+-----+------+-----
   0 |  50 |   0 |  -50 |   2
   0 |  50 |   0 |  -50 |   2
   0 |  50 |   0 |  -50 |   2
   0 | 100 |   0 | -100 |   2
(4 rows)

-- select div as nest function with agg (pushdown, explain)
--Testcase 633:
EXPLAIN VERBOSE
SELECT sum(value3),div(sum(value3)::numeric, 2) FROM s3;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(value3)), (div((sum(value3))::numeric, '2'::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), (sum(`value3`) div 2) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select div as nest function with agg (pushdown, result)
--Testcase 634:
SELECT sum(value3),div(sum(value3)::numeric, 2) FROM s3;
        sum         | div 
--------------------+-----
 -7.200000040233135 |  -3
(1 row)

-- select div as nest with log2 (pushdown, explain)
--Testcase 635:
EXPLAIN VERBOSE
SELECT div(log2(value1)::numeric, 2),div(log2(1/value1)::numeric, 2) FROM s3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..231.60 rows=2560 width=64)
   Output: div((log2(value1))::numeric, '2'::numeric), div((log2(('1'::double precision / value1)))::numeric, '2'::numeric)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select div as nest with log2 (pushdown, result)
--Testcase 636:
SELECT div(log2(value1)::numeric, 2),div(log2(1/value1)::numeric, 2) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select div with non pushdown func and explicit constant (explain)
--Testcase 637:
EXPLAIN VERBOSE
SELECT div(value3::numeric, 2), pi(), 4.1 FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..199.60 rows=2560 width=72)
   Output: div((value3)::numeric, '2'::numeric), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select div with non pushdown func and explicit constant (result)
--Testcase 638:
SELECT div(value3::numeric, 2), pi(), 4.1 FROM s3;
 div |        pi         | ?column? 
-----+-------------------+----------
   0 | 3.141592653589793 |      4.1
   0 | 3.141592653589793 |      4.1
   0 | 3.141592653589793 |      4.1
   0 | 3.141592653589793 |      4.1
  -1 | 3.141592653589793 |      4.1
  -1 | 3.141592653589793 |      4.1
(6 rows)

-- select div with order by (explain)
--Testcase 639:
EXPLAIN VERBOSE
SELECT value1, div((10-value1)::numeric, 2) FROM s3 ORDER BY value1, div((10-value1)::numeric, 2);
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.23 rows=30 width=40)
   Output: value1, div((('10'::double precision - value1))::numeric, '2'::numeric)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` ORDER BY `value1` IS NULL ASC, `value1` ASC, ((10 - `value1`) div 2) IS NULL ASC, ((10 - `value1`) div 2) ASC
(4 rows)

-- select div with order by (result)
--Testcase 640:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 ORDER BY value1, div((10-value1)::numeric, 2);
 value1 | div 
--------+-----
    0.1 |   4
    0.2 |   4
    0.3 |   4
    1.1 |   4
    2.2 |   3
    3.3 |   3
(6 rows)

-- select div with order by index (result)
--Testcase 641:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 ORDER BY 2,1;
 value1 | div 
--------+-----
    2.2 |   3
    3.3 |   3
    0.1 |   4
    0.2 |   4
    0.3 |   4
    1.1 |   4
(6 rows)

-- select div with order by index (result)
--Testcase 642:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 ORDER BY 1,2;
 value1 | div 
--------+-----
    0.1 |   4
    0.2 |   4
    0.3 |   4
    1.1 |   4
    2.2 |   3
    3.3 |   3
(6 rows)

-- select div with group by (explain)
--Testcase 643:
EXPLAIN VERBOSE
SELECT value1, div((10-value1)::numeric, 2) FROM s3 GROUP BY value1, div((10-value1)::numeric, 2);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: value1, (div((('10'::double precision - value1))::numeric, '2'::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, ((10 - `value1`) div 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select div with group by (result)
--Testcase 644:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 GROUP BY value1, div((10-value1)::numeric, 2);
 value1 | div 
--------+-----
    0.1 |   4
    0.2 |   4
    0.3 |   4
    1.1 |   4
    2.2 |   3
    3.3 |   3
(6 rows)

-- select div with group by index (result)
--Testcase 645:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 GROUP BY 2,1;
 value1 | div 
--------+-----
    0.1 |   4
    0.2 |   4
    0.3 |   4
    1.1 |   4
    2.2 |   3
    3.3 |   3
(6 rows)

-- select div with group by index (result)
--Testcase 646:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 GROUP BY 1,2;
 value1 | div 
--------+-----
    0.1 |   4
    0.2 |   4
    0.3 |   4
    1.1 |   4
    2.2 |   3
    3.3 |   3
(6 rows)

-- select div with group by having (explain)
--Testcase 647:
EXPLAIN VERBOSE
SELECT value1, div((10-value1)::numeric, 2) FROM s3 GROUP BY value1, div((10-value1)::numeric, 2) HAVING avg(value1) > 0;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=40)
   Output: value1, (div((('10'::double precision - value1))::numeric, '2'::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, ((10 - `value1`) div 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select div with group by having (result)
--Testcase 648:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 GROUP BY value1, div((10-value1)::numeric, 2) HAVING avg(value1) > 0;
 value1 | div 
--------+-----
    0.1 |   4
    0.2 |   4
    0.3 |   4
    1.1 |   4
    2.2 |   3
    3.3 |   3
(6 rows)

-- select div with group by index having (result)
--Testcase 649:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 GROUP BY 2,1 HAVING div((10-value1)::numeric, 2) > 0;
 value1 | div 
--------+-----
    0.1 |   4
    0.2 |   4
    0.3 |   4
    1.1 |   4
    2.2 |   3
    3.3 |   3
(6 rows)

-- select div with group by index having (result)
--Testcase 650:
SELECT value1, div((10-value1)::numeric, 2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | div 
--------+-----
    1.1 |   4
    2.2 |   3
    3.3 |   3
(3 rows)

-- select div and as
--Testcase 651:
SELECT div(value3::numeric, 2) as div1 FROM s3;
 div1 
------
    0
    0
    0
    0
   -1
   -1
(6 rows)

-- select exp (builtin function, explain)
--Testcase 652:
EXPLAIN VERBOSE
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=64)
   Output: exp(value1), exp((value2)::double precision), exp(value3), exp((value4)::double precision), 1.6487212707001281
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select exp (builtin function, result)
--Testcase 653:
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3;
        exp         |          exp           |         exp          |          exp           |        exp         
--------------------+------------------------+----------------------+------------------------+--------------------
 1.1051709180756477 | 2.6881171418161356e+43 |   0.9048374180359595 |  3.720075976020836e-44 | 1.6487212707001281
 1.2214027581601699 | 2.6881171418161356e+43 |   0.8187307530779818 |  3.720075976020836e-44 | 1.6487212707001281
 1.3498588075760032 | 2.6881171418161356e+43 |   0.7408182206817179 |  3.720075976020836e-44 | 1.6487212707001281
 3.0041660239464334 |  7.225973768125749e+86 |  0.33287108369807955 | 1.3838965267367376e-87 | 1.6487212707001281
  9.025013499434122 |  7.225973768125749e+86 |  0.11080315836233387 | 1.3838965267367376e-87 | 1.6487212707001281
 27.112638920657883 |  7.225973768125749e+86 | 0.036883167401240015 | 1.3838965267367376e-87 | 1.6487212707001281
(6 rows)

-- select exp (builtin function, not pushdown constraints, explain)
--Testcase 654:
EXPLAIN VERBOSE
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=64)
   Output: exp(value1), exp((value2)::double precision), exp(value3), exp((value4)::double precision), 1.6487212707001281
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select exp (builtin function, not pushdown constraints, result)
--Testcase 655:
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3 WHERE to_hex(value2) = '64';
        exp         |          exp           |        exp         |          exp          |        exp         
--------------------+------------------------+--------------------+-----------------------+--------------------
 1.1051709180756477 | 2.6881171418161356e+43 | 0.9048374180359595 | 3.720075976020836e-44 | 1.6487212707001281
 1.2214027581601699 | 2.6881171418161356e+43 | 0.8187307530779818 | 3.720075976020836e-44 | 1.6487212707001281
 1.3498588075760032 | 2.6881171418161356e+43 | 0.7408182206817179 | 3.720075976020836e-44 | 1.6487212707001281
(3 rows)

-- select exp (builtin function, pushdown constraints, explain)
--Testcase 656:
EXPLAIN VERBOSE
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3 WHERE value2 != 200;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=64)
   Output: exp(value1), exp((value2)::double precision), exp(value3), exp((value4)::double precision), 1.6487212707001281
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select exp (builtin function, pushdown constraints, result)
--Testcase 657:
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3 WHERE value2 != 200;
        exp         |          exp           |        exp         |          exp          |        exp         
--------------------+------------------------+--------------------+-----------------------+--------------------
 1.1051709180756477 | 2.6881171418161356e+43 | 0.9048374180359595 | 3.720075976020836e-44 | 1.6487212707001281
 1.2214027581601699 | 2.6881171418161356e+43 | 0.8187307530779818 | 3.720075976020836e-44 | 1.6487212707001281
 1.3498588075760032 | 2.6881171418161356e+43 | 0.7408182206817179 | 3.720075976020836e-44 | 1.6487212707001281
(3 rows)

-- select exp (builtin function, exp in constraints, explain)
--Testcase 658:
EXPLAIN VERBOSE
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3 WHERE exp(value1) != 1;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=64)
   Output: exp(value1), exp((value2)::double precision), exp(value3), exp((value4)::double precision), 1.6487212707001281
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((exp(`value1`) <> 1))
(4 rows)

-- select exp (builtin function, exp in constraints, result)
--Testcase 659:
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3 WHERE exp(value1) != 1;
        exp         |          exp           |         exp          |          exp           |        exp         
--------------------+------------------------+----------------------+------------------------+--------------------
 1.1051709180756477 | 2.6881171418161356e+43 |   0.9048374180359595 |  3.720075976020836e-44 | 1.6487212707001281
 1.2214027581601699 | 2.6881171418161356e+43 |   0.8187307530779818 |  3.720075976020836e-44 | 1.6487212707001281
 1.3498588075760032 | 2.6881171418161356e+43 |   0.7408182206817179 |  3.720075976020836e-44 | 1.6487212707001281
 3.0041660239464334 |  7.225973768125749e+86 |  0.33287108369807955 | 1.3838965267367376e-87 | 1.6487212707001281
  9.025013499434122 |  7.225973768125749e+86 |  0.11080315836233387 | 1.3838965267367376e-87 | 1.6487212707001281
 27.112638920657883 |  7.225973768125749e+86 | 0.036883167401240015 | 1.3838965267367376e-87 | 1.6487212707001281
(6 rows)

-- select exp (builtin function, exp in constraints, explain)
--Testcase 660:
EXPLAIN VERBOSE
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3 WHERE exp(0.5) > value1;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=64)
   Output: exp(value1), exp((value2)::double precision), exp(value3), exp((value4)::double precision), 1.6487212707001281
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1.6487212707001282 > `value1`))
(4 rows)

-- select exp (builtin function, exp in constraints, result)
--Testcase 661:
SELECT exp(value1), exp(value2), exp(value3), exp(value4), exp(0.5) FROM s3 WHERE exp(0.5) > value1;
        exp         |          exp           |         exp         |          exp           |        exp         
--------------------+------------------------+---------------------+------------------------+--------------------
 1.1051709180756477 | 2.6881171418161356e+43 |  0.9048374180359595 |  3.720075976020836e-44 | 1.6487212707001281
 1.2214027581601699 | 2.6881171418161356e+43 |  0.8187307530779818 |  3.720075976020836e-44 | 1.6487212707001281
 1.3498588075760032 | 2.6881171418161356e+43 |  0.7408182206817179 |  3.720075976020836e-44 | 1.6487212707001281
 3.0041660239464334 |  7.225973768125749e+86 | 0.33287108369807955 | 1.3838965267367376e-87 | 1.6487212707001281
(4 rows)

-- select exp as nest function with agg (pushdown, explain)
--Testcase 662:
EXPLAIN VERBOSE
SELECT sum(value3),exp(sum(value3)) FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (exp(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), exp(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select exp as nest function with agg (pushdown, result)
--Testcase 663:
SELECT sum(value3),exp(sum(value3)) FROM s3;
        sum         |          exp          
--------------------+-----------------------
 -7.200000040233135 | 0.0007465857783391922
(1 row)

-- select exp as nest with log2 (pushdown, explain)
--Testcase 664:
EXPLAIN VERBOSE
SELECT exp(log2(value1)),exp(log2(1/value1)) FROM s3;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: exp(log2(value1)), exp(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select exp as nest with log2 (pushdown, result)
--Testcase 665:
SELECT exp(log2(value1)),exp(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select exp with non pushdown func and explicit constant (explain)
--Testcase 666:
EXPLAIN VERBOSE
SELECT exp(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: exp(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select exp with non pushdown func and explicit constant (result)
--Testcase 667:
SELECT exp(value3), pi(), 4.1 FROM s3;
         exp          |        pi         | ?column? 
----------------------+-------------------+----------
   0.9048374180359595 | 3.141592653589793 |      4.1
   0.8187307530779818 | 3.141592653589793 |      4.1
   0.7408182206817179 | 3.141592653589793 |      4.1
  0.33287108369807955 | 3.141592653589793 |      4.1
  0.11080315836233387 | 3.141592653589793 |      4.1
 0.036883167401240015 | 3.141592653589793 |      4.1
(6 rows)

-- select exp with order by (explain)
--Testcase 668:
EXPLAIN VERBOSE
SELECT value1, exp(1-value3) FROM s3 ORDER BY exp(1-value3);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, exp(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY exp((1 - `value3`)) IS NULL ASC, exp((1 - `value3`)) ASC
(4 rows)

-- select exp with order by (result)
--Testcase 669:
SELECT value1, exp(1-value3) FROM s3 ORDER BY exp(1-value3);
 value1 |        exp         
--------+--------------------
    0.1 | 3.0041660239464334
    0.2 | 3.3201169227365472
    0.3 | 3.6692966676192444
    1.1 |  8.166169912567652
    2.2 | 24.532530197109352
    3.3 |  73.69979369959579
(6 rows)

-- select exp with order by index (result)
--Testcase 670:
SELECT value1, exp(1-value3) FROM s3 ORDER BY 2,1;
 value1 |        exp         
--------+--------------------
    0.1 | 3.0041660239464334
    0.2 | 3.3201169227365472
    0.3 | 3.6692966676192444
    1.1 |  8.166169912567652
    2.2 | 24.532530197109352
    3.3 |  73.69979369959579
(6 rows)

-- select exp with order by index (result)
--Testcase 671:
SELECT value1, exp(1-value3) FROM s3 ORDER BY 1,2;
 value1 |        exp         
--------+--------------------
    0.1 | 3.0041660239464334
    0.2 | 3.3201169227365472
    0.3 | 3.6692966676192444
    1.1 |  8.166169912567652
    2.2 | 24.532530197109352
    3.3 |  73.69979369959579
(6 rows)

-- select exp with group by (explain)
--Testcase 672:
EXPLAIN VERBOSE
SELECT count(value1), exp(1-value3) FROM s3 GROUP BY exp(1-value3);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (exp(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), exp((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select exp with group by (result)
--Testcase 673:
SELECT count(value1), exp(1-value3) FROM s3 GROUP BY exp(1-value3);
 count |        exp         
-------+--------------------
     1 | 3.0041660284229894
     1 |  3.320116932631267
     1 |  3.669296711360669
     1 |  8.166170107264316
     1 | 24.532531366911574
     1 |  73.69979018531586
(6 rows)

-- select exp with group by index (result)
--Testcase 674:
SELECT value1, exp(1-value3) FROM s3 GROUP BY 2,1;
 value1 |        exp         
--------+--------------------
    0.1 | 3.0041660284229894
    0.2 |  3.320116932631267
    0.3 |  3.669296711360669
    1.1 |  8.166170107264316
    2.2 | 24.532531366911574
    3.3 |  73.69979018531586
(6 rows)

-- select exp with group by index (result)
--Testcase 675:
SELECT value1, exp(1-value3) FROM s3 GROUP BY 1,2;
 value1 |        exp         
--------+--------------------
    0.1 | 3.0041660284229894
    0.2 |  3.320116932631267
    0.3 |  3.669296711360669
    1.1 |  8.166170107264316
    2.2 | 24.532531366911574
    3.3 |  73.69979018531586
(6 rows)

-- select exp with group by having (explain)
--Testcase 676:
EXPLAIN VERBOSE
SELECT count(value1), exp(1-value3) FROM s3 GROUP BY exp(1-value3) HAVING exp(avg(value1)) > 0;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (exp(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), exp((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((exp(avg(`value1`)) > 0))
(5 rows)

-- select exp with group by having (result)
--Testcase 677:
SELECT count(value1), exp(1-value3) FROM s3 GROUP BY exp(1-value3) HAVING exp(avg(value1)) > 0;
 count |        exp         
-------+--------------------
     1 | 3.0041660284229894
     1 |  3.320116932631267
     1 |  3.669296711360669
     1 |  8.166170107264316
     1 | 24.532531366911574
     1 |  73.69979018531586
(6 rows)

-- select exp with group by index having (result)
--Testcase 678:
SELECT value1, exp(1-value3) FROM s3 GROUP BY 2,1 HAVING exp(1-value3) > 0;
 value1 |        exp         
--------+--------------------
    0.1 | 3.0041660284229894
    0.2 |  3.320116932631267
    0.3 |  3.669296711360669
    1.1 |  8.166170107264316
    2.2 | 24.532531366911574
    3.3 |  73.69979018531586
(6 rows)

-- select exp with group by index having (result)
--Testcase 679:
SELECT value1, exp(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |        exp         
--------+--------------------
    1.1 |  8.166170107264316
    2.2 | 24.532531366911574
    3.3 |  73.69979018531586
(3 rows)

-- select exp and as
--Testcase 680:
SELECT exp(value3) as exp1 FROM s3;
         exp1         
----------------------
   0.9048374180359595
   0.8187307530779818
   0.7408182206817179
  0.33287108369807955
  0.11080315836233387
 0.036883167401240015
(6 rows)

-- select floor (builtin function, explain)
--Testcase 681:
EXPLAIN VERBOSE
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=64)
   Output: floor(value1), floor((value2)::double precision), floor(value3), floor((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select floor (builtin function, result)
--Testcase 682:
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3;
 floor | floor | floor | floor | floor 
-------+-------+-------+-------+-------
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
     1 |   200 |    -2 |  -200 |     1
     2 |   200 |    -3 |  -200 |     1
     3 |   200 |    -4 |  -200 |     1
(6 rows)

-- select floor (builtin function, not pushdown constraints, explain)
--Testcase 683:
EXPLAIN VERBOSE
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3 WHERE to_hex(value2) = '64';
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=64)
   Output: floor(value1), floor((value2)::double precision), floor(value3), floor((value4)::double precision), '1'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select floor (builtin function, not pushdown constraints, result)
--Testcase 684:
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3 WHERE to_hex(value2) = '64';
 floor | floor | floor | floor | floor 
-------+-------+-------+-------+-------
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
(3 rows)

-- select floor (builtin function, pushdown constraints, explain)
--Testcase 685:
EXPLAIN VERBOSE
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3 WHERE value2 != 200;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=64)
   Output: floor(value1), floor((value2)::double precision), floor(value3), floor((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select floor (builtin function, pushdown constraints, result)
--Testcase 686:
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3 WHERE value2 != 200;
 floor | floor | floor | floor | floor 
-------+-------+-------+-------+-------
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
(3 rows)

-- select floor (builtin function, floor in constraints, explain)
--Testcase 687:
EXPLAIN VERBOSE
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3 WHERE floor(value1) != 1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=64)
   Output: floor(value1), floor((value2)::double precision), floor(value3), floor((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((floor(`value1`) <> 1))
(4 rows)

-- select floor (builtin function, floor in constraints, result)
--Testcase 688:
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3 WHERE floor(value1) != 1;
 floor | floor | floor | floor | floor 
-------+-------+-------+-------+-------
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
     2 |   200 |    -3 |  -200 |     1
     3 |   200 |    -4 |  -200 |     1
(5 rows)

-- select floor (builtin function, floor in constraints, explain)
--Testcase 689:
EXPLAIN VERBOSE
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3 WHERE floor(1.5) > value1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=64)
   Output: floor(value1), floor((value2)::double precision), floor(value3), floor((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1 > `value1`))
(4 rows)

-- select floor (builtin function, floor in constraints, result)
--Testcase 690:
SELECT floor(value1), floor(value2), floor(value3), floor(value4), floor(1.5) FROM s3 WHERE floor(1.5) > value1;
 floor | floor | floor | floor | floor 
-------+-------+-------+-------+-------
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
     0 |   100 |    -1 |  -100 |     1
(3 rows)

-- select floor as nest function with agg (pushdown, explain)
--Testcase 691:
EXPLAIN VERBOSE
SELECT sum(value3),floor(sum(value3)) FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (floor(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), floor(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select floor as nest function with agg (pushdown, result)
--Testcase 692:
SELECT sum(value3),floor(sum(value3)) FROM s3;
        sum         | floor 
--------------------+-------
 -7.200000040233135 |    -8
(1 row)

-- select floor as nest with log2 (pushdown, explain)
--Testcase 693:
EXPLAIN VERBOSE
SELECT floor(log2(value1)),floor(log2(1/value1)) FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: floor(log2(value1)), floor(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select floor as nest with log2 (pushdown, result)
--Testcase 694:
SELECT floor(log2(value1)),floor(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select floor with non pushdown func and explicit constant (explain)
--Testcase 695:
EXPLAIN VERBOSE
SELECT floor(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: floor(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select floor with non pushdown func and explicit constant (result)
--Testcase 696:
SELECT floor(value3), pi(), 4.1 FROM s3;
 floor |        pi         | ?column? 
-------+-------------------+----------
    -1 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -1 | 3.141592653589793 |      4.1
    -2 | 3.141592653589793 |      4.1
    -3 | 3.141592653589793 |      4.1
    -4 | 3.141592653589793 |      4.1
(6 rows)

-- select floor with order by (explain)
--Testcase 697:
EXPLAIN VERBOSE
SELECT value1, floor(10 - value1) FROM s3 ORDER BY floor(10 - value1);
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, floor(('10'::double precision - value1))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` ORDER BY floor((10 - `value1`)) IS NULL ASC, floor((10 - `value1`)) ASC
(4 rows)

-- select floor with order by (result)
--Testcase 698:
SELECT value1, floor(10 - value1) FROM s3 ORDER BY floor(10 - value1);
 value1 | floor 
--------+-------
    3.3 |     6
    2.2 |     7
    1.1 |     8
    0.1 |     9
    0.2 |     9
    0.3 |     9
(6 rows)

-- select floor with order by index (result)
--Testcase 699:
SELECT value1, floor(10 - value1) FROM s3 ORDER BY 2,1;
 value1 | floor 
--------+-------
    3.3 |     6
    2.2 |     7
    1.1 |     8
    0.1 |     9
    0.2 |     9
    0.3 |     9
(6 rows)

-- select floor with order by index (result)
--Testcase 700:
SELECT value1, floor(10 - value1) FROM s3 ORDER BY 1,2;
 value1 | floor 
--------+-------
    0.1 |     9
    0.2 |     9
    0.3 |     9
    1.1 |     8
    2.2 |     7
    3.3 |     6
(6 rows)

-- select floor with group by (explain)
--Testcase 701:
EXPLAIN VERBOSE
SELECT value1, floor(10 - value1) FROM s3 GROUP BY value1, floor(10 - value1);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: value1, (floor(('10'::double precision - value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, floor((10 - `value1`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select floor with group by (result)
--Testcase 702:
SELECT value1, floor(10 - value1) FROM s3 GROUP BY value1, floor(10 - value1);
 value1 | floor 
--------+-------
    0.1 |     9
    0.2 |     9
    0.3 |     9
    1.1 |     8
    2.2 |     7
    3.3 |     6
(6 rows)

-- select floor with group by index (result)
--Testcase 703:
SELECT value1, floor(10 - value1) FROM s3 GROUP BY 2,1;
 value1 | floor 
--------+-------
    0.1 |     9
    0.2 |     9
    0.3 |     9
    1.1 |     8
    2.2 |     7
    3.3 |     6
(6 rows)

-- select floor with group by index (result)
--Testcase 704:
SELECT value1, floor(10 - value1) FROM s3 GROUP BY 1,2;
 value1 | floor 
--------+-------
    0.1 |     9
    0.2 |     9
    0.3 |     9
    1.1 |     8
    2.2 |     7
    3.3 |     6
(6 rows)

-- select floor with group by having (explain)
--Testcase 705:
EXPLAIN VERBOSE
SELECT value1, floor(10 - value1) FROM s3 GROUP BY value1, floor(10 - value1) HAVING floor(avg(value1)) > 0;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: value1, (floor(('10'::double precision - value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, floor((10 - `value1`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((floor(avg(`value1`)) > 0))
(5 rows)

-- select floor with group by having (result)
--Testcase 706:
SELECT value1, floor(10 - value1) FROM s3 GROUP BY value1, floor(10 - value1) HAVING floor(avg(value1)) > 0;
 value1 | floor 
--------+-------
    1.1 |     8
    2.2 |     7
    3.3 |     6
(3 rows)

-- select floor with group by index having (result)
--Testcase 707:
SELECT value1, floor(10 - value1) FROM s3 GROUP BY 2,1 HAVING floor(10 - value1) > 0;
 value1 | floor 
--------+-------
    0.1 |     9
    0.2 |     9
    0.3 |     9
    1.1 |     8
    2.2 |     7
    3.3 |     6
(6 rows)

-- select floor with group by index having (result)
--Testcase 708:
SELECT value1, floor(10 - value1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | floor 
--------+-------
    1.1 |     8
    2.2 |     7
    3.3 |     6
(3 rows)

-- select floor and as
--Testcase 709:
SELECT floor(value3) as floor1 FROM s3;
 floor1 
--------
     -1
     -1
     -1
     -2
     -3
     -4
(6 rows)

-- select ln as nest function with agg (pushdown, explain)
--Testcase 710:
EXPLAIN VERBOSE
SELECT sum(value3),ln(sum(value1)) FROM s3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (ln(sum(value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), ln(sum(`value1`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ln as nest function with agg (pushdown, result)
--Testcase 711:
SELECT sum(value3),ln(sum(value1)) FROM s3;
        sum         |        ln         
--------------------+-------------------
 -7.200000040233135 | 1.974081031609945
(1 row)

-- select ln as nest with log2 (pushdown, explain)
--Testcase 712:
EXPLAIN VERBOSE
SELECT value1, ln(log2(value1)),ln(log2(1/value1)) FROM s3;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, ln(log2(value1)), ln(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ln as nest with log2 (pushdown, result)
--Testcase 713:
SELECT value1, ln(log2(value1)),ln(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select ln with non pushdown func and explicit constant (explain)
--Testcase 714:
EXPLAIN VERBOSE
SELECT ln(value2), pi(), 4.1 FROM s3;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2925 width=48)
   Output: ln((value2)::double precision), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ln with non pushdown func and explicit constant (result)
--Testcase 715:
SELECT ln(value2), pi(), 4.1 FROM s3;
        ln         |        pi         | ?column? 
-------------------+-------------------+----------
 4.605170185988092 | 3.141592653589793 |      4.1
 4.605170185988092 | 3.141592653589793 |      4.1
 4.605170185988092 | 3.141592653589793 |      4.1
 5.298317366548036 | 3.141592653589793 |      4.1
 5.298317366548036 | 3.141592653589793 |      4.1
 5.298317366548036 | 3.141592653589793 |      4.1
(6 rows)

-- select ln with order by (explain)
--Testcase 716:
EXPLAIN VERBOSE
SELECT value1, ln(1-value3) FROM s3 ORDER BY ln(1-value3);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, ln(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY ln((1 - `value3`)) IS NULL ASC, ln((1 - `value3`)) ASC
(4 rows)

-- select ln with order by (result)
--Testcase 717:
SELECT value1, ln(1-value3) FROM s3 ORDER BY ln(1-value3);
 value1 |         ln          
--------+---------------------
    0.1 | 0.09531017980432493
    0.2 |  0.1823215567939546
    0.3 | 0.26236426446749106
    1.1 |  0.7419373447293773
    2.2 |  1.1631508098056809
    3.3 |  1.4586150226995167
(6 rows)

-- select ln with order by index (result)
--Testcase 718:
SELECT value1, ln(1-value3) FROM s3 ORDER BY 2,1;
 value1 |         ln          
--------+---------------------
    0.1 | 0.09531017980432493
    0.2 |  0.1823215567939546
    0.3 | 0.26236426446749106
    1.1 |  0.7419373447293773
    2.2 |  1.1631508098056809
    3.3 |  1.4586150226995167
(6 rows)

-- select ln with order by index (result)
--Testcase 719:
SELECT value1, ln(1-value3) FROM s3 ORDER BY 1,2;
 value1 |         ln          
--------+---------------------
    0.1 | 0.09531017980432493
    0.2 |  0.1823215567939546
    0.3 | 0.26236426446749106
    1.1 |  0.7419373447293773
    2.2 |  1.1631508098056809
    3.3 |  1.4586150226995167
(6 rows)

-- select ln with group by (explain)
--Testcase 720:
EXPLAIN VERBOSE
SELECT count(value1), ln(1-value3) FROM s3 GROUP BY ln(1-value3);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (ln(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ln((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select ln with group by (result)
--Testcase 721:
SELECT count(value1), ln(1-value3) FROM s3 GROUP BY ln(1-value3);
 count |         ln          
-------+---------------------
     1 | 0.09531018115897588
     1 | 0.18232155927748148
     1 | 0.26236427363743636
     1 |  0.7419373560826429
     1 |  1.1631508247068418
     1 |  1.4586150116102805
(6 rows)

-- select ln with group by index (result)
--Testcase 722:
SELECT value1, ln(1-value3) FROM s3 GROUP BY 2,1;
 value1 |         ln          
--------+---------------------
    0.1 | 0.09531018115897588
    0.2 | 0.18232155927748148
    0.3 | 0.26236427363743636
    1.1 |  0.7419373560826429
    2.2 |  1.1631508247068418
    3.3 |  1.4586150116102805
(6 rows)

-- select ln with group by index (result)
--Testcase 723:
SELECT value1, ln(1-value3) FROM s3 GROUP BY 1,2;
 value1 |         ln          
--------+---------------------
    0.1 | 0.09531018115897588
    0.2 | 0.18232155927748148
    0.3 | 0.26236427363743636
    1.1 |  0.7419373560826429
    2.2 |  1.1631508247068418
    3.3 |  1.4586150116102805
(6 rows)

-- select ln with group by having (explain)
--Testcase 724:
EXPLAIN VERBOSE
SELECT count(value1), ln(1-value3) FROM s3 GROUP BY ln(1-value3) HAVING ln(avg(value1)) > 0;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (ln(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ln((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((ln(avg(`value1`)) > 0))
(5 rows)

-- select ln with group by having (result)
--Testcase 725:
SELECT count(value1), ln(1-value3) FROM s3 GROUP BY ln(1-value3) HAVING ln(avg(value1)) > 0;
 count |         ln         
-------+--------------------
     1 | 0.7419373560826429
     1 | 1.1631508247068418
     1 | 1.4586150116102805
(3 rows)

-- select ln with group by index having (result)
--Testcase 726:
SELECT value1, ln(1-value3) FROM s3 GROUP BY 2,1 HAVING ln(1-value3) < 0;
 value1 | ln 
--------+----
(0 rows)

-- select ln with group by index having (result)
--Testcase 727:
SELECT value1, ln(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |         ln         
--------+--------------------
    1.1 | 0.7419373560826429
    2.2 | 1.1631508247068418
    3.3 | 1.4586150116102805
(3 rows)

-- select ln and as
--Testcase 728:
SELECT ln(value1) as ln1 FROM s3;
         ln1         
---------------------
 -2.3025850929940455
 -1.6094379124341003
 -1.2039728043259361
 0.09531017980432493
  0.7884573603642703
  1.1939224684724346
(6 rows)

-- select ln (builtin function, explain)
--Testcase 729:
EXPLAIN VERBOSE
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..189.09 rows=1861 width=56)
   Output: ln(value1), ln((value2)::double precision), ln((value3 + '10'::double precision)), '-0.6931471805599453'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ln (builtin function, result)
--Testcase 730:
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3;
         ln          |        ln         |         ln         |         ln          
---------------------+-------------------+--------------------+---------------------
 -2.3025850929940455 | 4.605170185988092 | 2.2925347571405443 | -0.6931471805599453
 -1.6094379124341003 | 4.605170185988092 | 2.2823823856765264 | -0.6931471805599453
 -1.2039728043259361 | 4.605170185988092 |  2.272125885509337 | -0.6931471805599453
 0.09531017980432493 | 5.298317366548036 |  2.186051276738094 | -0.6931471805599453
  0.7884573603642703 | 5.298317366548036 | 2.0541237336955462 | -0.6931471805599453
  1.1939224684724346 | 5.298317366548036 | 1.9021075263969205 | -0.6931471805599453
(6 rows)

-- select ln (builtin function, not pushdown constraints, explain)
--Testcase 731:
EXPLAIN VERBOSE
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..138.21 rows=9 width=56)
   Output: ln(value1), ln((value2)::double precision), ln((value3 + '10'::double precision)), '-0.6931471805599453'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ln (builtin function, not pushdown constraints, result)
--Testcase 732:
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3 WHERE to_hex(value2) = '64';
         ln          |        ln         |         ln         |         ln          
---------------------+-------------------+--------------------+---------------------
 -2.3025850929940455 | 4.605170185988092 | 2.2925347571405443 | -0.6931471805599453
 -1.6094379124341003 | 4.605170185988092 | 2.2823823856765264 | -0.6931471805599453
 -1.2039728043259361 | 4.605170185988092 |  2.272125885509337 | -0.6931471805599453
(3 rows)

-- select ln (builtin function, pushdown constraints, explain)
--Testcase 733:
EXPLAIN VERBOSE
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3 WHERE value2 != 200;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.45 rows=1852 width=56)
   Output: ln(value1), ln((value2)::double precision), ln((value3 + '10'::double precision)), '-0.6931471805599453'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select ln (builtin function, pushdown constraints, result)
--Testcase 734:
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3 WHERE value2 != 200;
         ln          |        ln         |         ln         |         ln          
---------------------+-------------------+--------------------+---------------------
 -2.3025850929940455 | 4.605170185988092 | 2.2925347571405443 | -0.6931471805599453
 -1.6094379124341003 | 4.605170185988092 | 2.2823823856765264 | -0.6931471805599453
 -1.2039728043259361 | 4.605170185988092 |  2.272125885509337 | -0.6931471805599453
(3 rows)

-- select ln (builtin function, ln in constraints, explain)
--Testcase 735:
EXPLAIN VERBOSE
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3 WHERE ln(value1) != 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..198.11 rows=1852 width=56)
   Output: ln(value1), ln((value2)::double precision), ln((value3 + '10'::double precision)), '-0.6931471805599453'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE ((ln(`value1`) <> 1))
(4 rows)

-- select ln (builtin function, ln in constraints, result)
--Testcase 736:
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3 WHERE ln(value1) != 1;
         ln          |        ln         |         ln         |         ln          
---------------------+-------------------+--------------------+---------------------
 -2.3025850929940455 | 4.605170185988092 | 2.2925347571405443 | -0.6931471805599453
 -1.6094379124341003 | 4.605170185988092 | 2.2823823856765264 | -0.6931471805599453
 -1.2039728043259361 | 4.605170185988092 |  2.272125885509337 | -0.6931471805599453
 0.09531017980432493 | 5.298317366548036 |  2.186051276738094 | -0.6931471805599453
  0.7884573603642703 | 5.298317366548036 | 2.0541237336955462 | -0.6931471805599453
  1.1939224684724346 | 5.298317366548036 | 1.9021075263969205 | -0.6931471805599453
(6 rows)

-- select ln (builtin function, ln in constraints, explain)
--Testcase 737:
EXPLAIN VERBOSE
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3 WHERE ln(0.5) < value1;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..153.41 rows=620 width=56)
   Output: ln(value1), ln((value2)::double precision), ln((value3 + '10'::double precision)), '-0.6931471805599453'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3` FROM `mysql_fdw_regress`.`s3` WHERE (((-0.6931471805599453) < `value1`))
(4 rows)

-- select ln (builtin function, ln in constraints, result)
--Testcase 738:
SELECT ln(value1), ln(value2), ln(value3 + 10), ln(0.5) FROM s3 WHERE ln(0.5) < value1;
         ln          |        ln         |         ln         |         ln          
---------------------+-------------------+--------------------+---------------------
 -2.3025850929940455 | 4.605170185988092 | 2.2925347571405443 | -0.6931471805599453
 -1.6094379124341003 | 4.605170185988092 | 2.2823823856765264 | -0.6931471805599453
 -1.2039728043259361 | 4.605170185988092 |  2.272125885509337 | -0.6931471805599453
 0.09531017980432493 | 5.298317366548036 |  2.186051276738094 | -0.6931471805599453
  0.7884573603642703 | 5.298317366548036 | 2.0541237336955462 | -0.6931471805599453
  1.1939224684724346 | 5.298317366548036 | 1.9021075263969205 | -0.6931471805599453
(6 rows)

-- select mod (builtin function, explain)
--Testcase 739:
EXPLAIN VERBOSE
SELECT value1, mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.30 rows=1706 width=140)
   Output: value1, mod((value1)::numeric, '2'::numeric), mod((value2)::numeric, '2'::numeric), mod((value3)::numeric, '2'::numeric), mod((value4)::numeric, '2'::numeric), 1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mod (builtin function, result)
--Testcase 740:
SELECT value1, mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3;
 value1 | mod | mod | mod  | mod | mod 
--------+-----+-----+------+-----+-----
    0.1 | 0.1 |   0 | -0.1 |   0 |   1
    0.2 | 0.2 |   0 | -0.2 |   0 |   1
    0.3 | 0.3 |   0 | -0.3 |   0 |   1
    1.1 | 1.1 |   0 | -1.1 |   0 |   1
    2.2 | 0.2 |   0 | -0.2 |   0 |   1
    3.3 | 1.3 |   0 | -1.3 |   0 |   1
(6 rows)

-- select mod (builtin function, not pushdown constraints, explain)
--Testcase 741:
EXPLAIN VERBOSE
SELECT mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3 WHERE to_hex(value2) = '64';
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.95 rows=9 width=132)
   Output: mod((value1)::numeric, '2'::numeric), mod((value2)::numeric, '2'::numeric), mod((value3)::numeric, '2'::numeric), mod((value4)::numeric, '2'::numeric), 1
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select mod (builtin function, not pushdown constraints, result)
--Testcase 742:
SELECT mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3 WHERE to_hex(value2) = '64';
 mod | mod | mod  | mod | mod 
-----+-----+------+-----+-----
 0.1 |   0 | -0.1 |   0 |   1
 0.2 |   0 | -0.2 |   0 |   1
 0.3 |   0 | -0.3 |   0 |   1
(3 rows)

-- select mod (builtin function, pushdown constraints, explain)
--Testcase 743:
EXPLAIN VERBOSE
SELECT mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3 WHERE value2 != 200;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..199.20 rows=1697 width=132)
   Output: mod((value1)::numeric, '2'::numeric), mod((value2)::numeric, '2'::numeric), mod((value3)::numeric, '2'::numeric), mod((value4)::numeric, '2'::numeric), 1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select mod (builtin function, pushdown constraints, result)
--Testcase 744:
SELECT mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3 WHERE value2 != 200;
 mod | mod | mod  | mod | mod 
-----+-----+------+-----+-----
 0.1 |   0 | -0.1 |   0 |   1
 0.2 |   0 | -0.2 |   0 |   1
 0.3 |   0 | -0.3 |   0 |   1
(3 rows)

-- select mod (builtin function, mod in constraints, explain)
--Testcase 745:
EXPLAIN VERBOSE
SELECT value1, mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3 WHERE mod(value1::numeric, 2) != 1;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..207.74 rows=1697 width=140)
   Output: value1, mod((value1)::numeric, '2'::numeric), mod((value2)::numeric, '2'::numeric), mod((value3)::numeric, '2'::numeric), mod((value4)::numeric, '2'::numeric), 1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE (((`value1` mod 2) <> 1))
(4 rows)

-- select mod (builtin function, mod in constraints, result)
--Testcase 746:
SELECT value1, mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3 WHERE mod(value1::numeric, 2) != 1;
 value1 | mod | mod | mod  | mod | mod 
--------+-----+-----+------+-----+-----
    0.1 | 0.1 |   0 | -0.1 |   0 |   1
    0.2 | 0.2 |   0 | -0.2 |   0 |   1
    0.3 | 0.3 |   0 | -0.3 |   0 |   1
    1.1 | 1.1 |   0 | -1.1 |   0 |   1
    2.2 | 0.2 |   0 | -0.2 |   0 |   1
    3.3 | 1.3 |   0 | -1.3 |   0 |   1
(6 rows)

-- select mod (builtin function, mod in constraints, explain)
--Testcase 747:
EXPLAIN VERBOSE
SELECT mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3 WHERE mod(5, 2) > value1;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.08 rows=569 width=132)
   Output: mod((value1)::numeric, '2'::numeric), mod((value2)::numeric, '2'::numeric), mod((value3)::numeric, '2'::numeric), mod((value4)::numeric, '2'::numeric), 1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1 > `value1`))
(4 rows)

-- select mod (builtin function, mod in constraints, result)
--Testcase 748:
SELECT mod(value1::numeric, 2), mod(value2::numeric, 2), mod(value3::numeric, 2), mod(value4::numeric, 2), mod(5, 2) FROM s3 WHERE mod(5, 2) > value1;
 mod | mod | mod  | mod | mod 
-----+-----+------+-----+-----
 0.1 |   0 | -0.1 |   0 |   1
 0.2 |   0 | -0.2 |   0 |   1
 0.3 |   0 | -0.3 |   0 |   1
(3 rows)

-- select mod as nest function with agg (pushdown, explain)
--Testcase 749:
EXPLAIN VERBOSE
SELECT sum(value3),mod(sum(value3)::numeric, 2) FROM s3;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(value3)), (mod((sum(value3))::numeric, '2'::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), (sum(`value3`) mod 2) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select mod as nest function with agg (pushdown, result)
--Testcase 750:
SELECT sum(value3),mod(sum(value3)::numeric, 2) FROM s3;
        sum         |         mod         
--------------------+---------------------
 -7.200000040233135 | -1.2000000402331352
(1 row)

-- select mod as nest with log2 (pushdown, explain)
--Testcase 751:
EXPLAIN VERBOSE
SELECT value1, mod(log2(value1)::numeric, 2),mod(log2(1/value1)::numeric, 2) FROM s3;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..231.60 rows=2560 width=72)
   Output: value1, mod((log2(value1))::numeric, '2'::numeric), mod((log2(('1'::double precision / value1)))::numeric, '2'::numeric)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mod as nest with log2 (pushdown, result)
--Testcase 752:
SELECT value1, mod(log2(value1)::numeric, 2),mod(log2(1/value1)::numeric, 2) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select mod with non pushdown func and explicit constant (explain)
--Testcase 753:
EXPLAIN VERBOSE
SELECT value1, mod(value3::numeric, 2), pi(), 4.1 FROM s3;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..181.68 rows=2048 width=80)
   Output: value1, mod((value3)::numeric, '2'::numeric), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mod with non pushdown func and explicit constant (result)
--Testcase 754:
SELECT value1, mod(value3::numeric, 2), pi(), 4.1 FROM s3;
 value1 | mod  |        pi         | ?column? 
--------+------+-------------------+----------
    0.1 | -0.1 | 3.141592653589793 |      4.1
    0.2 | -0.2 | 3.141592653589793 |      4.1
    0.3 | -0.3 | 3.141592653589793 |      4.1
    1.1 | -1.1 | 3.141592653589793 |      4.1
    2.2 | -0.2 | 3.141592653589793 |      4.1
    3.3 | -1.3 | 3.141592653589793 |      4.1
(6 rows)

-- select mod with order by (explain)
--Testcase 755:
EXPLAIN VERBOSE
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 ORDER BY mod((1-value3)::numeric, 2);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.23 rows=30 width=40)
   Output: value1, mod((('1'::double precision - value3))::numeric, '2'::numeric)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY ((1 - `value3`) mod 2) IS NULL ASC, ((1 - `value3`) mod 2) ASC
(4 rows)

-- select mod with order by (result)
--Testcase 756:
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 ORDER BY mod((1-value3)::numeric, 2);
 value1 | mod 
--------+-----
    1.1 | 0.1
    3.3 | 0.3
    0.1 | 1.1
    0.2 | 1.2
    2.2 | 1.2
    0.3 | 1.3
(6 rows)

-- select mod with order by index (result)
--Testcase 757:
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 ORDER BY 2,1;
 value1 | mod 
--------+-----
    1.1 | 0.1
    3.3 | 0.3
    0.1 | 1.1
    0.2 | 1.2
    2.2 | 1.2
    0.3 | 1.3
(6 rows)

-- select mod with order by index (result)
--Testcase 758:
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 ORDER BY 1,2;
 value1 | mod 
--------+-----
    0.1 | 1.1
    0.2 | 1.2
    0.3 | 1.3
    1.1 | 0.1
    2.2 | 1.2
    3.3 | 0.3
(6 rows)

-- select mod with group by (explain)
--Testcase 759:
EXPLAIN VERBOSE
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 GROUP BY value1, mod((1-value3)::numeric, 2);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=40)
   Output: value1, (mod((('1'::double precision - value3))::numeric, '2'::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, ((1 - `value3`) mod 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select mod with group by (result)
--Testcase 760:
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 GROUP BY value1, mod((1-value3)::numeric, 2);
 value1 |         mod         
--------+---------------------
    0.1 |  1.1000000014901161
    0.2 |  1.2000000029802322
    0.3 |   1.300000011920929
    1.1 | 0.10000002384185791
    2.2 |  1.2000000476837158
    3.3 |  0.2999999523162842
(6 rows)

-- select mod with group by index (result)
--Testcase 761:
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 GROUP BY 2,1;
 value1 |         mod         
--------+---------------------
    0.1 |  1.1000000014901161
    0.2 |  1.2000000029802322
    0.3 |   1.300000011920929
    1.1 | 0.10000002384185791
    2.2 |  1.2000000476837158
    3.3 |  0.2999999523162842
(6 rows)

-- select mod with group by index (result)
--Testcase 762:
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 GROUP BY 1,2;
 value1 |         mod         
--------+---------------------
    0.1 |  1.1000000014901161
    0.2 |  1.2000000029802322
    0.3 |   1.300000011920929
    1.1 | 0.10000002384185791
    2.2 |  1.2000000476837158
    3.3 |  0.2999999523162842
(6 rows)

-- select mod with group by having (explain)
--Testcase 763:
EXPLAIN VERBOSE
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 GROUP BY value1, mod((1-value3)::numeric, 2) HAVING avg(value1) > 0;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=40)
   Output: value1, (mod((('1'::double precision - value3))::numeric, '2'::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, ((1 - `value3`) mod 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((avg(`value1`) > 0))
(5 rows)

-- select mod with group by having (result)
--Testcase 764:
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 GROUP BY value1, mod((1-value3)::numeric, 2) HAVING avg(value1) > 0;
 value1 |         mod         
--------+---------------------
    0.1 |  1.1000000014901161
    0.2 |  1.2000000029802322
    0.3 |   1.300000011920929
    1.1 | 0.10000002384185791
    2.2 |  1.2000000476837158
    3.3 |  0.2999999523162842
(6 rows)

-- select mod with group by index having (result)
--Testcase 765:
SELECT value1, mod((1-value3)::numeric, 2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |         mod         
--------+---------------------
    1.1 | 0.10000002384185791
    2.2 |  1.2000000476837158
    3.3 |  0.2999999523162842
(3 rows)

-- select mod and as
--Testcase 766:
SELECT value1, mod(value3::numeric, 2) as mod1 FROM s3;
 value1 | mod1 
--------+------
    0.1 | -0.1
    0.2 | -0.2
    0.3 | -0.3
    1.1 | -1.1
    2.2 | -0.2
    3.3 | -1.3
(6 rows)

-- select power (builtin function, explain)
--Testcase 767:
EXPLAIN VERBOSE
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=40)
   Output: power(value1, '2'::double precision), power((value2)::double precision, '2'::double precision), power(value3, '2'::double precision), power((value4)::double precision, '2'::double precision), '25'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select power (builtin function, result)
--Testcase 768:
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3;
        power         | power |        power         | power | power 
----------------------+-------+----------------------+-------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000 |    25
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000 |    25
                 0.09 | 10000 |                 0.09 | 10000 |    25
   1.2100000000000002 | 40000 |   1.2100000000000002 | 40000 |    25
    4.840000000000001 | 40000 |    4.840000000000001 | 40000 |    25
   10.889999999999999 | 40000 |   10.889999999999999 | 40000 |    25
(6 rows)

-- select power (builtin function, not pushdown constraints, explain)
--Testcase 769:
EXPLAIN VERBOSE
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3 WHERE to_hex(value2) = '64';
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: power(value1, '2'::double precision), power((value2)::double precision, '2'::double precision), power(value3, '2'::double precision), power((value4)::double precision, '2'::double precision), '25'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select power (builtin function, not pushdown constraints, result)
--Testcase 770:
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3 WHERE to_hex(value2) = '64';
        power         | power |        power         | power | power 
----------------------+-------+----------------------+-------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000 |    25
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000 |    25
                 0.09 | 10000 |                 0.09 | 10000 |    25
(3 rows)

-- select power (builtin function, pushdown constraints, explain)
--Testcase 771:
EXPLAIN VERBOSE
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3 WHERE value2 != 200;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: power(value1, '2'::double precision), power((value2)::double precision, '2'::double precision), power(value3, '2'::double precision), power((value4)::double precision, '2'::double precision), '25'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select power (builtin function, pushdown constraints, result)
--Testcase 772:
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3 WHERE value2 != 200;
        power         | power |        power         | power | power 
----------------------+-------+----------------------+-------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000 |    25
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000 |    25
                 0.09 | 10000 |                 0.09 | 10000 |    25
(3 rows)

-- select power (builtin function, power in constraints, explain)
--Testcase 773:
EXPLAIN VERBOSE
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3 WHERE power(value1, 2) != 1;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=40)
   Output: power(value1, '2'::double precision), power((value2)::double precision, '2'::double precision), power(value3, '2'::double precision), power((value4)::double precision, '2'::double precision), '25'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((power(`value1`, 2) <> 1))
(4 rows)

-- select power (builtin function, power in constraints, result)
--Testcase 774:
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3 WHERE power(value1, 2) != 1;
        power         | power |        power         | power | power 
----------------------+-------+----------------------+-------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000 |    25
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000 |    25
                 0.09 | 10000 |                 0.09 | 10000 |    25
   1.2100000000000002 | 40000 |   1.2100000000000002 | 40000 |    25
    4.840000000000001 | 40000 |    4.840000000000001 | 40000 |    25
   10.889999999999999 | 40000 |   10.889999999999999 | 40000 |    25
(6 rows)

-- select power (builtin function, power in constraints, explain)
--Testcase 775:
EXPLAIN VERBOSE
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3 WHERE power(5, 2) > value1;
                                                                                                            QUERY PLAN                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=40)
   Output: power(value1, '2'::double precision), power((value2)::double precision, '2'::double precision), power(value3, '2'::double precision), power((value4)::double precision, '2'::double precision), '25'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((25 > `value1`))
(4 rows)

-- select power (builtin function, power in constraints, result)
--Testcase 776:
SELECT power(value1, 2), power(value2, 2), power(value3, 2), power(value4, 2), power(5, 2) FROM s3 WHERE power(5, 2) > value1;
        power         | power |        power         | power | power 
----------------------+-------+----------------------+-------+-------
 0.010000000000000002 | 10000 | 0.010000000000000002 | 10000 |    25
  0.04000000000000001 | 10000 |  0.04000000000000001 | 10000 |    25
                 0.09 | 10000 |                 0.09 | 10000 |    25
   1.2100000000000002 | 40000 |   1.2100000000000002 | 40000 |    25
    4.840000000000001 | 40000 |    4.840000000000001 | 40000 |    25
   10.889999999999999 | 40000 |   10.889999999999999 | 40000 |    25
(6 rows)

-- select power as nest function with agg (pushdown, explain)
--Testcase 777:
EXPLAIN VERBOSE
SELECT sum(value3),power(sum(value3), 2) FROM s3;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (power(sum(value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), power(sum(`value3`), 2) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select power as nest function with agg (pushdown, result)
--Testcase 778:
SELECT sum(value3),power(sum(value3), 2) FROM s3;
        sum         |       power       
--------------------+-------------------
 -7.200000040233135 | 51.84000057935715
(1 row)

-- select power as nest with log2 (pushdown, explain)
--Testcase 779:
EXPLAIN VERBOSE
SELECT value1, power(log2(value1), 2),power(log2(1/value1), 2) FROM s3;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, power(log2(value1), '2'::double precision), power(log2(('1'::double precision / value1)), '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select power as nest with log2 (pushdown, result)
--Testcase 780:
SELECT value1, power(log2(value1), 2),power(log2(1/value1), 2) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select power with non pushdown func and explicit constant (explain)
--Testcase 781:
EXPLAIN VERBOSE
SELECT power(value3, 2), pi(), 4.1 FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: power(value3, '2'::double precision), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select power with non pushdown func and explicit constant (result)
--Testcase 782:
SELECT power(value3, 2), pi(), 4.1 FROM s3;
        power         |        pi         | ?column? 
----------------------+-------------------+----------
 0.010000000000000002 | 3.141592653589793 |      4.1
  0.04000000000000001 | 3.141592653589793 |      4.1
                 0.09 | 3.141592653589793 |      4.1
   1.2100000000000002 | 3.141592653589793 |      4.1
    4.840000000000001 | 3.141592653589793 |      4.1
   10.889999999999999 | 3.141592653589793 |      4.1
(6 rows)

-- select power with order by (explain)
--Testcase 783:
EXPLAIN VERBOSE
SELECT value1, power(1-value3, 2) FROM s3 ORDER BY power(1-value3, 2);
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, power(('1'::double precision - value3), '2'::double precision)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY power((1 - `value3`), 2) IS NULL ASC, power((1 - `value3`), 2) ASC
(4 rows)

-- select power with order by (result)
--Testcase 784:
SELECT value1, power(1-value3, 2) FROM s3 ORDER BY power(1-value3, 2);
 value1 |       power        
--------+--------------------
    0.1 | 1.2100000000000002
    0.2 |               1.44
    0.3 | 1.6900000000000002
    1.1 |               4.41
    2.2 | 10.240000000000002
    3.3 |              18.49
(6 rows)

-- select power with order by index (result)
--Testcase 785:
SELECT value1, power(1-value3, 2) FROM s3 ORDER BY 2,1;
 value1 |       power        
--------+--------------------
    0.1 | 1.2100000000000002
    0.2 |               1.44
    0.3 | 1.6900000000000002
    1.1 |               4.41
    2.2 | 10.240000000000002
    3.3 |              18.49
(6 rows)

-- select power with order by index (result)
--Testcase 786:
SELECT value1, power(1-value3, 2) FROM s3 ORDER BY 1,2;
 value1 |       power        
--------+--------------------
    0.1 | 1.2100000000000002
    0.2 |               1.44
    0.3 | 1.6900000000000002
    1.1 |               4.41
    2.2 | 10.240000000000002
    3.3 |              18.49
(6 rows)

-- select power with group by (explain)
--Testcase 787:
EXPLAIN VERBOSE
SELECT count(value1), power(1-value3, 2) FROM s3 GROUP BY power(1-value3, 2);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (power(('1'::double precision - value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), power((1 - `value3`), 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select power with group by (result)
--Testcase 788:
SELECT count(value1), power(1-value3, 2) FROM s3 GROUP BY power(1-value3, 2);
 count |       power        
-------+--------------------
     1 | 1.2100000032782554
     1 | 1.4400000071525574
     1 | 1.6900000309944154
     1 |  4.410000100135804
     1 | 10.240000305175784
     1 | 18.489999589920046
(6 rows)

-- select power with group by index (result)
--Testcase 789:
SELECT value1, power(1-value3, 2) FROM s3 GROUP BY 2,1;
 value1 |       power        
--------+--------------------
    0.1 | 1.2100000032782554
    0.2 | 1.4400000071525574
    0.3 | 1.6900000309944154
    1.1 |  4.410000100135804
    2.2 | 10.240000305175784
    3.3 | 18.489999589920046
(6 rows)

-- select power with group by index (result)
--Testcase 790:
SELECT value1, power(1-value3, 2) FROM s3 GROUP BY 1,2;
 value1 |       power        
--------+--------------------
    0.1 | 1.2100000032782554
    0.2 | 1.4400000071525574
    0.3 | 1.6900000309944154
    1.1 |  4.410000100135804
    2.2 | 10.240000305175784
    3.3 | 18.489999589920046
(6 rows)

-- select power with group by having (explain)
--Testcase 791:
EXPLAIN VERBOSE
SELECT count(value1), power(1-value3, 2) FROM s3 GROUP BY power(1-value3, 2) HAVING power(avg(value1), 2) > 0;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (power(('1'::double precision - value3), '2'::double precision))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), power((1 - `value3`), 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((power(avg(`value1`), 2) > 0))
(5 rows)

-- select power with group by having (result)
--Testcase 792:
SELECT count(value1), power(1-value3, 2) FROM s3 GROUP BY power(1-value3, 2) HAVING power(avg(value1), 2) > 0;
 count |       power        
-------+--------------------
     1 | 1.2100000032782554
     1 | 1.4400000071525574
     1 | 1.6900000309944154
     1 |  4.410000100135804
     1 | 10.240000305175784
     1 | 18.489999589920046
(6 rows)

-- select power with group by index having (result)
--Testcase 793:
SELECT value1, power(1-value3, 2) FROM s3 GROUP BY 2,1 HAVING power(1-value3, 2) > 0;
 value1 |       power        
--------+--------------------
    0.1 | 1.2100000032782554
    0.2 | 1.4400000071525574
    0.3 | 1.6900000309944154
    1.1 |  4.410000100135804
    2.2 | 10.240000305175784
    3.3 | 18.489999589920046
(6 rows)

-- select power with group by index having (result)
--Testcase 794:
SELECT value1, power(1-value3, 2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |       power        
--------+--------------------
    1.1 |  4.410000100135804
    2.2 | 10.240000305175784
    3.3 | 18.489999589920046
(3 rows)

-- select power and as
--Testcase 795:
SELECT power(value3, 2) as power1 FROM s3;
        power1        
----------------------
 0.010000000000000002
  0.04000000000000001
                 0.09
   1.2100000000000002
    4.840000000000001
   10.889999999999999
(6 rows)

-- select radians (builtin function, explain)
--Testcase 796:
EXPLAIN VERBOSE
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=40)
   Output: radians(value1), radians((value2)::double precision), radians(value3), radians((value4)::double precision), '0.008726646259971648'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select radians (builtin function, result)
--Testcase 797:
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3;
        radians        |      radians       |        radians         |       radians       |       radians        
-----------------------+--------------------+------------------------+---------------------+----------------------
 0.0017453292519943296 | 1.7453292519943295 | -0.0017453292519943296 | -1.7453292519943295 | 0.008726646259971648
  0.003490658503988659 | 1.7453292519943295 |  -0.003490658503988659 | -1.7453292519943295 | 0.008726646259971648
  0.005235987755982988 | 1.7453292519943295 |  -0.005235987755982988 | -1.7453292519943295 | 0.008726646259971648
  0.019198621771937627 |  3.490658503988659 |  -0.019198621771937627 |  -3.490658503988659 | 0.008726646259971648
  0.038397243543875255 |  3.490658503988659 |  -0.038397243543875255 |  -3.490658503988659 | 0.008726646259971648
   0.05759586531581287 |  3.490658503988659 |   -0.05759586531581287 |  -3.490658503988659 | 0.008726646259971648
(6 rows)

-- select radians (builtin function, not pushdown constraints, explain)
--Testcase 798:
EXPLAIN VERBOSE
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: radians(value1), radians((value2)::double precision), radians(value3), radians((value4)::double precision), '0.008726646259971648'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select radians (builtin function, not pushdown constraints, result)
--Testcase 799:
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3 WHERE to_hex(value2) = '64';
        radians        |      radians       |        radians         |       radians       |       radians        
-----------------------+--------------------+------------------------+---------------------+----------------------
 0.0017453292519943296 | 1.7453292519943295 | -0.0017453292519943296 | -1.7453292519943295 | 0.008726646259971648
  0.003490658503988659 | 1.7453292519943295 |  -0.003490658503988659 | -1.7453292519943295 | 0.008726646259971648
  0.005235987755982988 | 1.7453292519943295 |  -0.005235987755982988 | -1.7453292519943295 | 0.008726646259971648
(3 rows)

-- select radians (builtin function, pushdown constraints, explain)
--Testcase 800:
EXPLAIN VERBOSE
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3 WHERE value2 != 200;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: radians(value1), radians((value2)::double precision), radians(value3), radians((value4)::double precision), '0.008726646259971648'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select radians (builtin function, pushdown constraints, result)
--Testcase 801:
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3 WHERE value2 != 200;
        radians        |      radians       |        radians         |       radians       |       radians        
-----------------------+--------------------+------------------------+---------------------+----------------------
 0.0017453292519943296 | 1.7453292519943295 | -0.0017453292519943296 | -1.7453292519943295 | 0.008726646259971648
  0.003490658503988659 | 1.7453292519943295 |  -0.003490658503988659 | -1.7453292519943295 | 0.008726646259971648
  0.005235987755982988 | 1.7453292519943295 |  -0.005235987755982988 | -1.7453292519943295 | 0.008726646259971648
(3 rows)

-- select radians (builtin function, radians in constraints, explain)
--Testcase 802:
EXPLAIN VERBOSE
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3 WHERE radians(value1) != 1;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=40)
   Output: radians(value1), radians((value2)::double precision), radians(value3), radians((value4)::double precision), '0.008726646259971648'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((radians(`value1`) <> 1))
(4 rows)

-- select radians (builtin function, radians in constraints, result)
--Testcase 803:
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3 WHERE radians(value1) != 1;
        radians        |      radians       |        radians         |       radians       |       radians        
-----------------------+--------------------+------------------------+---------------------+----------------------
 0.0017453292519943296 | 1.7453292519943295 | -0.0017453292519943296 | -1.7453292519943295 | 0.008726646259971648
  0.003490658503988659 | 1.7453292519943295 |  -0.003490658503988659 | -1.7453292519943295 | 0.008726646259971648
  0.005235987755982988 | 1.7453292519943295 |  -0.005235987755982988 | -1.7453292519943295 | 0.008726646259971648
  0.019198621771937627 |  3.490658503988659 |  -0.019198621771937627 |  -3.490658503988659 | 0.008726646259971648
  0.038397243543875255 |  3.490658503988659 |  -0.038397243543875255 |  -3.490658503988659 | 0.008726646259971648
   0.05759586531581287 |  3.490658503988659 |   -0.05759586531581287 |  -3.490658503988659 | 0.008726646259971648
(6 rows)

-- select radians (builtin function, radians in constraints, explain)
--Testcase 804:
EXPLAIN VERBOSE
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3 WHERE radians(0.5) < value1;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=40)
   Output: radians(value1), radians((value2)::double precision), radians(value3), radians((value4)::double precision), '0.008726646259971648'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((0.008726646259971648 < `value1`))
(4 rows)

-- select radians (builtin function, radians in constraints, result)
--Testcase 805:
SELECT radians(value1), radians(value2), radians(value3), radians(value4), radians(0.5) FROM s3 WHERE radians(0.5) < value1;
        radians        |      radians       |        radians         |       radians       |       radians        
-----------------------+--------------------+------------------------+---------------------+----------------------
 0.0017453292519943296 | 1.7453292519943295 | -0.0017453292519943296 | -1.7453292519943295 | 0.008726646259971648
  0.003490658503988659 | 1.7453292519943295 |  -0.003490658503988659 | -1.7453292519943295 | 0.008726646259971648
  0.005235987755982988 | 1.7453292519943295 |  -0.005235987755982988 | -1.7453292519943295 | 0.008726646259971648
  0.019198621771937627 |  3.490658503988659 |  -0.019198621771937627 |  -3.490658503988659 | 0.008726646259971648
  0.038397243543875255 |  3.490658503988659 |  -0.038397243543875255 |  -3.490658503988659 | 0.008726646259971648
   0.05759586531581287 |  3.490658503988659 |   -0.05759586531581287 |  -3.490658503988659 | 0.008726646259971648
(6 rows)

-- select radians as nest function with agg (pushdown, explain)
--Testcase 806:
EXPLAIN VERBOSE
SELECT sum(value3),radians(sum(value3)) FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (radians(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), radians(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select radians as nest function with agg (pushdown, result)
--Testcase 807:
SELECT sum(value3),radians(sum(value3)) FROM s3;
        sum         |       radians       
--------------------+---------------------
 -7.200000040233135 | -0.1256637068457924
(1 row)

-- select radians as nest with log2 (pushdown, explain)
--Testcase 808:
EXPLAIN VERBOSE
SELECT radians(log2(value1)),radians(log2(1/value1)) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: radians(log2(value1)), radians(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select radians as nest with log2 (pushdown, result)
--Testcase 809:
SELECT radians(log2(value1)),radians(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select radians with non pushdown func and explicit constant (explain)
--Testcase 810:
EXPLAIN VERBOSE
SELECT radians(value3), pi(), 4.1 FROM s3;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: radians(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select radians with non pushdown func and explicit constant (result)
--Testcase 811:
SELECT radians(value3), pi(), 4.1 FROM s3;
        radians         |        pi         | ?column? 
------------------------+-------------------+----------
 -0.0017453292519943296 | 3.141592653589793 |      4.1
  -0.003490658503988659 | 3.141592653589793 |      4.1
  -0.005235987755982988 | 3.141592653589793 |      4.1
  -0.019198621771937627 | 3.141592653589793 |      4.1
  -0.038397243543875255 | 3.141592653589793 |      4.1
   -0.05759586531581287 | 3.141592653589793 |      4.1
(6 rows)

-- select radians with order by (explain)
--Testcase 812:
EXPLAIN VERBOSE
SELECT value1, radians(1-value3) FROM s3 ORDER BY radians(1-value3);
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, radians(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY radians((1 - `value3`)) IS NULL ASC, radians((1 - `value3`)) ASC
(4 rows)

-- select radians with order by (result)
--Testcase 813:
SELECT value1, radians(1-value3) FROM s3 ORDER BY radians(1-value3);
 value1 |       radians        
--------+----------------------
    0.1 | 0.019198621771937627
    0.2 | 0.020943951023931952
    0.3 | 0.022689280275926284
    1.1 |  0.03665191429188092
    2.2 |  0.05585053606381855
    3.3 |  0.07504915783575616
(6 rows)

-- select radians with order by index (result)
--Testcase 814:
SELECT value1, radians(1-value3) FROM s3 ORDER BY 2,1;
 value1 |       radians        
--------+----------------------
    0.1 | 0.019198621771937627
    0.2 | 0.020943951023931952
    0.3 | 0.022689280275926284
    1.1 |  0.03665191429188092
    2.2 |  0.05585053606381855
    3.3 |  0.07504915783575616
(6 rows)

-- select radians with order by index (result)
--Testcase 815:
SELECT value1, radians(1-value3) FROM s3 ORDER BY 1,2;
 value1 |       radians        
--------+----------------------
    0.1 | 0.019198621771937627
    0.2 | 0.020943951023931952
    0.3 | 0.022689280275926284
    1.1 |  0.03665191429188092
    2.2 |  0.05585053606381855
    3.3 |  0.07504915783575616
(6 rows)

-- select radians with group by (explain)
--Testcase 816:
EXPLAIN VERBOSE
SELECT count(value1), radians(1-value3) FROM s3 GROUP BY radians(1-value3);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (radians(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), radians((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select radians with group by (result)
--Testcase 817:
SELECT count(value1), radians(1-value3) FROM s3 GROUP BY radians(1-value3);
 count |       radians        
-------+----------------------
     1 | 0.019198621797945056
     1 |  0.02094395107594682
     1 | 0.022689280483985743
     1 |  0.03665191470799984
     1 |  0.05585053689605639
     1 |  0.07504915700351833
(6 rows)

-- select radians with group by index (result)
--Testcase 818:
SELECT value1, radians(1-value3) FROM s3 GROUP BY 2,1;
 value1 |       radians        
--------+----------------------
    0.1 | 0.019198621797945056
    0.2 |  0.02094395107594682
    0.3 | 0.022689280483985743
    1.1 |  0.03665191470799984
    2.2 |  0.05585053689605639
    3.3 |  0.07504915700351833
(6 rows)

-- select radians with group by index (result)
--Testcase 819:
SELECT value1, radians(1-value3) FROM s3 GROUP BY 1,2;
 value1 |       radians        
--------+----------------------
    0.1 | 0.019198621797945056
    0.2 |  0.02094395107594682
    0.3 | 0.022689280483985743
    1.1 |  0.03665191470799984
    2.2 |  0.05585053689605639
    3.3 |  0.07504915700351833
(6 rows)

-- select radians with group by having (explain)
--Testcase 820:
EXPLAIN VERBOSE
SELECT count(value1), radians(1-value3) FROM s3 GROUP BY radians(1-value3) HAVING radians(avg(value1)) > 0;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (radians(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), radians((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((radians(avg(`value1`)) > 0))
(5 rows)

-- select radians with group by having (result)
--Testcase 821:
SELECT count(value1), radians(1-value3) FROM s3 GROUP BY radians(1-value3) HAVING radians(avg(value1)) > 0;
 count |       radians        
-------+----------------------
     1 | 0.019198621797945056
     1 |  0.02094395107594682
     1 | 0.022689280483985743
     1 |  0.03665191470799984
     1 |  0.05585053689605639
     1 |  0.07504915700351833
(6 rows)

-- select radians with group by index having (result)
--Testcase 822:
SELECT value1, radians(1-value3) FROM s3 GROUP BY 2,1 HAVING radians(1-value3) > 0;
 value1 |       radians        
--------+----------------------
    0.1 | 0.019198621797945056
    0.2 |  0.02094395107594682
    0.3 | 0.022689280483985743
    1.1 |  0.03665191470799984
    2.2 |  0.05585053689605639
    3.3 |  0.07504915700351833
(6 rows)

-- select radians with group by index having (result)
--Testcase 823:
SELECT value1, radians(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |       radians       
--------+---------------------
    1.1 | 0.03665191470799984
    2.2 | 0.05585053689605639
    3.3 | 0.07504915700351833
(3 rows)

-- select radians and as
--Testcase 824:
SELECT radians(value3) as radians1 FROM s3;
        radians1        
------------------------
 -0.0017453292519943296
  -0.003490658503988659
  -0.005235987755982988
  -0.019198621771937627
  -0.038397243543875255
   -0.05759586531581287
(6 rows)

-- select sign (builtin function, explain)
--Testcase 825:
EXPLAIN VERBOSE
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.77 rows=1706 width=64)
   Output: sign(value1), sign((value2)::double precision), sign(value3), sign((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sign (builtin function, result)
--Testcase 826:
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3;
 sign | sign | sign | sign | sign 
------+------+------+------+------
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
(6 rows)

-- select sign (builtin function, not pushdown constraints, explain)
--Testcase 827:
EXPLAIN VERBOSE
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=64)
   Output: sign(value1), sign((value2)::double precision), sign(value3), sign((value4)::double precision), '1'::numeric
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select sign (builtin function, not pushdown constraints, result)
--Testcase 828:
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3 WHERE to_hex(value2) = '64';
 sign | sign | sign | sign | sign 
------+------+------+------+------
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
(3 rows)

-- select sign (builtin function, pushdown constraints, explain)
--Testcase 829:
EXPLAIN VERBOSE
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3 WHERE value2 != 200;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=64)
   Output: sign(value1), sign((value2)::double precision), sign(value3), sign((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select sign (builtin function, pushdown constraints, result)
--Testcase 830:
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3 WHERE value2 != 200;
 sign | sign | sign | sign | sign 
------+------+------+------+------
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
(3 rows)

-- select sign (builtin function, sign in constraints, explain)
--Testcase 831:
EXPLAIN VERBOSE
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3 WHERE sign(value1) != -1;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..194.99 rows=1697 width=64)
   Output: sign(value1), sign((value2)::double precision), sign(value3), sign((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((sign(`value1`) <> (-1)))
(4 rows)

-- select sign (builtin function, sign in constraints, result)
--Testcase 832:
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3 WHERE sign(value1) != -1;
 sign | sign | sign | sign | sign 
------+------+------+------+------
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
(6 rows)

-- select sign (builtin function, sign in constraints, explain)
--Testcase 833:
EXPLAIN VERBOSE
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3 WHERE sign(0.5) > value1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=64)
   Output: sign(value1), sign((value2)::double precision), sign(value3), sign((value4)::double precision), '1'::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((1 > `value1`))
(4 rows)

-- select sign (builtin function, sign in constraints, result)
--Testcase 834:
SELECT sign(value1), sign(value2), sign(value3), sign(value4), sign(0.5) FROM s3 WHERE sign(0.5) > value1;
 sign | sign | sign | sign | sign 
------+------+------+------+------
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
    1 |    1 |   -1 |   -1 |    1
(3 rows)

-- select sign as nest function with agg (pushdown, explain)
--Testcase 835:
EXPLAIN VERBOSE
SELECT sum(value3),sign(sum(value3)) FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (sign(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), sign(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select sign as nest function with agg (pushdown, result)
--Testcase 836:
SELECT sum(value3),sign(sum(value3)) FROM s3;
        sum         | sign 
--------------------+------
 -7.200000040233135 |   -1
(1 row)

-- select sign as nest with log2 (pushdown, explain)
--Testcase 837:
EXPLAIN VERBOSE
SELECT sign(log2(value1)),sign(log2(1/value1)) FROM s3;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=16)
   Output: sign(log2(value1)), sign(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sign as nest with log2 (pushdown, result)
--Testcase 838:
SELECT sign(log2(value1)),sign(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select sign with non pushdown func and explicit constant (explain)
--Testcase 839:
EXPLAIN VERBOSE
SELECT sign(value3), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=48)
   Output: sign(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sign with non pushdown func and explicit constant (result)
--Testcase 840:
SELECT sign(value3), pi(), 4.1 FROM s3;
 sign |        pi         | ?column? 
------+-------------------+----------
   -1 | 3.141592653589793 |      4.1
   -1 | 3.141592653589793 |      4.1
   -1 | 3.141592653589793 |      4.1
   -1 | 3.141592653589793 |      4.1
   -1 | 3.141592653589793 |      4.1
   -1 | 3.141592653589793 |      4.1
(6 rows)

-- select sign with order by (explain)
--Testcase 841:
EXPLAIN VERBOSE
SELECT value1, sign(1-value3) FROM s3 ORDER BY sign(1-value3);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, sign(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY sign((1 - `value3`)) IS NULL ASC, sign((1 - `value3`)) ASC
(4 rows)

-- select sign with order by (result)
--Testcase 842:
SELECT value1, sign(1-value3) FROM s3 ORDER BY sign(1-value3);
 value1 | sign 
--------+------
    0.1 |    1
    0.2 |    1
    0.3 |    1
    1.1 |    1
    2.2 |    1
    3.3 |    1
(6 rows)

-- select sign with order by index (result)
--Testcase 843:
SELECT value1, sign(1-value3) FROM s3 ORDER BY 2,1;
 value1 | sign 
--------+------
    0.1 |    1
    0.2 |    1
    0.3 |    1
    1.1 |    1
    2.2 |    1
    3.3 |    1
(6 rows)

-- select sign with order by index (result)
--Testcase 844:
SELECT value1, sign(1-value3) FROM s3 ORDER BY 1,2;
 value1 | sign 
--------+------
    0.1 |    1
    0.2 |    1
    0.3 |    1
    1.1 |    1
    2.2 |    1
    3.3 |    1
(6 rows)

-- select sign with group by (explain)
--Testcase 845:
EXPLAIN VERBOSE
SELECT count(value1), sign(1-value3) FROM s3 GROUP BY sign(1-value3);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (sign(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), sign((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select sign with group by (result)
--Testcase 846:
SELECT count(value1), sign(1-value3) FROM s3 GROUP BY sign(1-value3);
 count | sign 
-------+------
     6 |    1
(1 row)

-- select sign with group by index (result)
--Testcase 847:
SELECT value1, sign(1-value3) FROM s3 GROUP BY 2,1;
 value1 | sign 
--------+------
    0.1 |    1
    0.2 |    1
    0.3 |    1
    1.1 |    1
    2.2 |    1
    3.3 |    1
(6 rows)

-- select sign with group by index (result)
--Testcase 848:
SELECT value1, sign(1-value3) FROM s3 GROUP BY 1,2;
 value1 | sign 
--------+------
    0.1 |    1
    0.2 |    1
    0.3 |    1
    1.1 |    1
    2.2 |    1
    3.3 |    1
(6 rows)

-- select sign with group by having (explain)
--Testcase 849:
EXPLAIN VERBOSE
SELECT count(value1), sign(1-value3) FROM s3 GROUP BY sign(1-value3) HAVING sign(avg(value1)) > 0;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (sign(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), sign((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((sign(avg(`value1`)) > 0))
(5 rows)

-- select sign with group by having (result)
--Testcase 850:
SELECT count(value1), sign(1-value3) FROM s3 GROUP BY sign(1-value3) HAVING sign(avg(value1)) > 0;
 count | sign 
-------+------
     6 |    1
(1 row)

-- select sign with group by index having (result)
--Testcase 851:
SELECT value1, sign(1-value3) FROM s3 GROUP BY 2,1 HAVING sign(1-value3) > 0;
 value1 | sign 
--------+------
    0.1 |    1
    0.2 |    1
    0.3 |    1
    1.1 |    1
    2.2 |    1
    3.3 |    1
(6 rows)

-- select sign with group by index having (result)
--Testcase 852:
SELECT value1, sign(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | sign 
--------+------
    1.1 |    1
    2.2 |    1
    3.3 |    1
(3 rows)

-- select sign and as
--Testcase 853:
SELECT sign(value3) as sign1 FROM s3;
 sign1 
-------
    -1
    -1
    -1
    -1
    -1
    -1
(6 rows)

-- select sin (builtin function, explain)
--Testcase 854:
EXPLAIN VERBOSE
SELECT value1, sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..182.50 rows=1706 width=40)
   Output: value1, sin((value2)::double precision), sin(value3), sin((value4)::double precision), '0.479425538604203'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sin (builtin function, result)
--Testcase 855:
SELECT value1, sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3;
 value1 |         sin         |         sin          |        sin         |        sin        
--------+---------------------+----------------------+--------------------+-------------------
    0.1 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588 | 0.479425538604203
    0.2 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588 | 0.479425538604203
    0.3 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588 | 0.479425538604203
    1.1 | -0.8732972972139946 |  -0.8912073600614354 | 0.8732972972139946 | 0.479425538604203
    2.2 | -0.8732972972139946 |  -0.8084964038195901 | 0.8732972972139946 | 0.479425538604203
    3.3 | -0.8732972972139946 |   0.1577456941432482 | 0.8732972972139946 | 0.479425538604203
(6 rows)

-- select sin (builtin function, not pushdown constraints, explain)
--Testcase 856:
EXPLAIN VERBOSE
SELECT sin(value1), sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: sin(value1), sin((value2)::double precision), sin(value3), sin((value4)::double precision), '0.479425538604203'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select sin (builtin function, not pushdown constraints, result)
--Testcase 857:
SELECT sin(value1), sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3 WHERE to_hex(value2) = '64';
         sin         |         sin         |         sin          |        sin         |        sin        
---------------------+---------------------+----------------------+--------------------+-------------------
 0.09983341664682815 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588 | 0.479425538604203
 0.19866933079506122 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588 | 0.479425538604203
 0.29552020666133955 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588 | 0.479425538604203
(3 rows)

-- select sin (builtin function, pushdown constraints, explain)
--Testcase 858:
EXPLAIN VERBOSE
SELECT sin(value1), sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3 WHERE value2 != 200;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: sin(value1), sin((value2)::double precision), sin(value3), sin((value4)::double precision), '0.479425538604203'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select sin (builtin function, pushdown constraints, result)
--Testcase 859:
SELECT sin(value1), sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3 WHERE value2 != 200;
         sin         |         sin         |         sin          |        sin         |        sin        
---------------------+---------------------+----------------------+--------------------+-------------------
 0.09983341664682815 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588 | 0.479425538604203
 0.19866933079506122 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588 | 0.479425538604203
 0.29552020666133955 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588 | 0.479425538604203
(3 rows)

-- select sin (builtin function, sin in constraints, explain)
--Testcase 860:
EXPLAIN VERBOSE
SELECT value1, sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3 WHERE sin(value1) != 1;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.74 rows=1697 width=40)
   Output: value1, sin((value2)::double precision), sin(value3), sin((value4)::double precision), '0.479425538604203'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((sin(`value1`) <> 1))
(4 rows)

-- select sin (builtin function, sin in constraints, result)
--Testcase 861:
SELECT value1, sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3 WHERE sin(value1) != 1;
 value1 |         sin         |         sin          |        sin         |        sin        
--------+---------------------+----------------------+--------------------+-------------------
    0.1 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588 | 0.479425538604203
    0.2 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588 | 0.479425538604203
    0.3 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588 | 0.479425538604203
    1.1 | -0.8732972972139946 |  -0.8912073600614354 | 0.8732972972139946 | 0.479425538604203
    2.2 | -0.8732972972139946 |  -0.8084964038195901 | 0.8732972972139946 | 0.479425538604203
    3.3 | -0.8732972972139946 |   0.1577456941432482 | 0.8732972972139946 | 0.479425538604203
(6 rows)

-- select sin (builtin function, sin in constraints, explain)
--Testcase 862:
EXPLAIN VERBOSE
SELECT sin(value1), sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3 WHERE sin(0.5) > value1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=40)
   Output: sin(value1), sin((value2)::double precision), sin(value3), sin((value4)::double precision), '0.479425538604203'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((0.479425538604203 > `value1`))
(4 rows)

-- select sin (builtin function, sin in constraints, result)
--Testcase 863:
SELECT sin(value1), sin(value2), sin(value3), sin(value4), sin(0.5) FROM s3 WHERE sin(0.5) > value1;
         sin         |         sin         |         sin          |        sin         |        sin        
---------------------+---------------------+----------------------+--------------------+-------------------
 0.09983341664682815 | -0.5063656411097588 | -0.09983341664682815 | 0.5063656411097588 | 0.479425538604203
 0.19866933079506122 | -0.5063656411097588 | -0.19866933079506122 | 0.5063656411097588 | 0.479425538604203
 0.29552020666133955 | -0.5063656411097588 | -0.29552020666133955 | 0.5063656411097588 | 0.479425538604203
(3 rows)

-- select sin as nest function with agg (pushdown, explain)
--Testcase 864:
EXPLAIN VERBOSE
SELECT sum(value3),sin(sum(value3)) FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (sin(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), sin(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select sin as nest function with agg (pushdown, result)
--Testcase 865:
SELECT sum(value3),sin(sum(value3)) FROM s3;
        sum         |         sin         
--------------------+---------------------
 -7.200000040233135 | -0.7936678883250331
(1 row)

-- select sin as nest with log2 (pushdown, explain)
--Testcase 866:
EXPLAIN VERBOSE
SELECT value1, sin(log2(value1)),sin(log2(1/value1)) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, sin(log2(value1)), sin(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sin as nest with log2 (pushdown, result)
--Testcase 867:
SELECT value1, sin(log2(value1)),sin(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select sin with non pushdown func and explicit constant (explain)
--Testcase 868:
EXPLAIN VERBOSE
SELECT value1, sin(value3), pi(), 4.1 FROM s3;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..176.56 rows=2048 width=56)
   Output: value1, sin(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sin with non pushdown func and explicit constant (result)
--Testcase 869:
SELECT value1, sin(value3), pi(), 4.1 FROM s3;
 value1 |         sin          |        pi         | ?column? 
--------+----------------------+-------------------+----------
    0.1 | -0.09983341664682815 | 3.141592653589793 |      4.1
    0.2 | -0.19866933079506122 | 3.141592653589793 |      4.1
    0.3 | -0.29552020666133955 | 3.141592653589793 |      4.1
    1.1 |  -0.8912073600614354 | 3.141592653589793 |      4.1
    2.2 |  -0.8084964038195901 | 3.141592653589793 |      4.1
    3.3 |   0.1577456941432482 | 3.141592653589793 |      4.1
(6 rows)

-- select sin with order by (explain)
--Testcase 870:
EXPLAIN VERBOSE
SELECT value1, sin(1-value3) FROM s3 ORDER BY sin(1-value3);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, sin(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY sin((1 - `value3`)) IS NULL ASC, sin((1 - `value3`)) ASC
(4 rows)

-- select sin with order by (result)
--Testcase 871:
SELECT value1, sin(1-value3) FROM s3 ORDER BY sin(1-value3);
 value1 |          sin          
--------+-----------------------
    3.3 |   -0.9161659367494549
    2.2 | -0.058374143427580086
    1.1 |    0.8632093666488737
    0.1 |    0.8912073600614354
    0.2 |    0.9320390859672263
    0.3 |     0.963558185417193
(6 rows)

-- select sin with order by index (result)
--Testcase 872:
SELECT value1, sin(1-value3) FROM s3 ORDER BY 2,1;
 value1 |          sin          
--------+-----------------------
    3.3 |   -0.9161659367494549
    2.2 | -0.058374143427580086
    1.1 |    0.8632093666488737
    0.1 |    0.8912073600614354
    0.2 |    0.9320390859672263
    0.3 |     0.963558185417193
(6 rows)

-- select sin with order by index (result)
--Testcase 873:
SELECT value1, sin(1-value3) FROM s3 ORDER BY 1,2;
 value1 |          sin          
--------+-----------------------
    0.1 |    0.8912073600614354
    0.2 |    0.9320390859672263
    0.3 |     0.963558185417193
    1.1 |    0.8632093666488737
    2.2 | -0.058374143427580086
    3.3 |   -0.9161659367494549
(6 rows)

-- select sin with group by (explain)
--Testcase 874:
EXPLAIN VERBOSE
SELECT value1, sin(1-value3) FROM s3 GROUP BY value1, sin(1-value3);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=16)
   Output: value1, (sin(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, sin((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select sin with group by (result)
--Testcase 875:
SELECT value1, sin(1-value3) FROM s3 GROUP BY value1, sin(1-value3);
 value1 |          sin          
--------+-----------------------
    0.1 |    0.8912073607373462
    0.2 |    0.9320390870471366
    0.3 |    0.9635581886060274
    1.1 |    0.8632093546124044
    2.2 | -0.058374191029984236
    3.3 |   -0.9161659176378601
(6 rows)

-- select sin with group by index (result)
--Testcase 876:
SELECT value1, sin(1-value3) FROM s3 GROUP BY 2,1;
 value1 |          sin          
--------+-----------------------
    0.1 |    0.8912073607373462
    0.2 |    0.9320390870471366
    0.3 |    0.9635581886060274
    1.1 |    0.8632093546124044
    2.2 | -0.058374191029984236
    3.3 |   -0.9161659176378601
(6 rows)

-- select sin with group by index (result)
--Testcase 877:
SELECT value1, sin(1-value3) FROM s3 GROUP BY 1,2;
 value1 |          sin          
--------+-----------------------
    0.1 |    0.8912073607373462
    0.2 |    0.9320390870471366
    0.3 |    0.9635581886060274
    1.1 |    0.8632093546124044
    2.2 | -0.058374191029984236
    3.3 |   -0.9161659176378601
(6 rows)

-- select sin with group by having (explain)
--Testcase 878:
EXPLAIN VERBOSE
SELECT value1, sin(1-value3) FROM s3 GROUP BY value1, sin(1-value3) HAVING sin(avg(value1)) > 0;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=16)
   Output: value1, (sin(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, sin((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((sin(avg(`value1`)) > 0))
(5 rows)

-- select sin with group by having (result)
--Testcase 879:
SELECT value1, sin(1-value3) FROM s3 GROUP BY value1, sin(1-value3) HAVING sin(avg(value1)) > 0;
 value1 |          sin          
--------+-----------------------
    0.1 |    0.8912073607373462
    0.2 |    0.9320390870471366
    0.3 |    0.9635581886060274
    1.1 |    0.8632093546124044
    2.2 | -0.058374191029984236
(5 rows)

-- select sin with group by index having (result)
--Testcase 880:
SELECT value1, sin(1-value3) FROM s3 GROUP BY 2,1 HAVING sin(1-value3) > 0;
 value1 |        sin         
--------+--------------------
    0.1 | 0.8912073607373462
    0.2 | 0.9320390870471366
    0.3 | 0.9635581886060274
    1.1 | 0.8632093546124044
(4 rows)

-- select sin with group by index having (result)
--Testcase 881:
SELECT value1, sin(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |          sin          
--------+-----------------------
    1.1 |    0.8632093546124044
    2.2 | -0.058374191029984236
    3.3 |   -0.9161659176378601
(3 rows)

-- select sin and as
--Testcase 882:
SELECT value1, sin(value3) as sin1 FROM s3;
 value1 |         sin1         
--------+----------------------
    0.1 | -0.09983341664682815
    0.2 | -0.19866933079506122
    0.3 | -0.29552020666133955
    1.1 |  -0.8912073600614354
    2.2 |  -0.8084964038195901
    3.3 |   0.1577456941432482
(6 rows)

-- select sqrt (builtin function, explain)
--Testcase 883:
EXPLAIN VERBOSE
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.31 rows=2275 width=48)
   Output: sqrt(value1), sqrt((value2)::double precision), 0.70710678118654752
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sqrt (builtin function, result)
--Testcase 884:
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3;
        sqrt         |        sqrt        |        sqrt         
---------------------+--------------------+---------------------
 0.31622776601683794 |                 10 | 0.70710678118654752
  0.4472135954999579 |                 10 | 0.70710678118654752
  0.5477225575051661 |                 10 | 0.70710678118654752
  1.0488088481701516 | 14.142135623730951 | 0.70710678118654752
  1.4832396974191326 | 14.142135623730951 | 0.70710678118654752
   1.816590212458495 | 14.142135623730951 | 0.70710678118654752
(6 rows)

-- select sqrt (builtin function, not pushdown constraints, explain)
--Testcase 885:
EXPLAIN VERBOSE
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..144.43 rows=11 width=48)
   Output: sqrt(value1), sqrt((value2)::double precision), 0.70710678118654752
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select sqrt (builtin function, not pushdown constraints, result)
--Testcase 886:
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3 WHERE to_hex(value2) = '64';
        sqrt         | sqrt |        sqrt         
---------------------+------+---------------------
 0.31622776601683794 |   10 | 0.70710678118654752
  0.4472135954999579 |   10 | 0.70710678118654752
  0.5477225575051661 |   10 | 0.70710678118654752
(3 rows)

-- select sqrt (builtin function, pushdown constraints, explain)
--Testcase 887:
EXPLAIN VERBOSE
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3 WHERE value2 != 200;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..200.70 rows=2264 width=48)
   Output: sqrt(value1), sqrt((value2)::double precision), 0.70710678118654752
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select sqrt (builtin function, pushdown constraints, result)
--Testcase 888:
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3 WHERE value2 != 200;
        sqrt         | sqrt |        sqrt         
---------------------+------+---------------------
 0.31622776601683794 |   10 | 0.70710678118654752
  0.4472135954999579 |   10 | 0.70710678118654752
  0.5477225575051661 |   10 | 0.70710678118654752
(3 rows)

-- select sqrt (builtin function, sqrt in constraints, explain)
--Testcase 889:
EXPLAIN VERBOSE
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3 WHERE sqrt(value1) != 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..206.38 rows=2264 width=48)
   Output: sqrt(value1), sqrt((value2)::double precision), 0.70710678118654752
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((sqrt(`value1`) <> 1))
(4 rows)

-- select sqrt (builtin function, sqrt in constraints, result)
--Testcase 890:
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3 WHERE sqrt(value1) != 1;
        sqrt         |        sqrt        |        sqrt         
---------------------+--------------------+---------------------
 0.31622776601683794 |                 10 | 0.70710678118654752
  0.4472135954999579 |                 10 | 0.70710678118654752
  0.5477225575051661 |                 10 | 0.70710678118654752
  1.0488088481701516 | 14.142135623730951 | 0.70710678118654752
  1.4832396974191326 | 14.142135623730951 | 0.70710678118654752
   1.816590212458495 | 14.142135623730951 | 0.70710678118654752
(6 rows)

-- select sqrt (builtin function, sqrt in constraints, explain)
--Testcase 891:
EXPLAIN VERBOSE
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3 WHERE sqrt(0.5) > value1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..159.28 rows=758 width=48)
   Output: sqrt(value1), sqrt((value2)::double precision), 0.70710678118654752
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((0.7071067811865476 > `value1`))
(4 rows)

-- select sqrt (builtin function, sqrt in constraints, result)
--Testcase 892:
SELECT sqrt(value1), sqrt(value2), sqrt(0.5) FROM s3 WHERE sqrt(0.5) > value1;
        sqrt         | sqrt |        sqrt         
---------------------+------+---------------------
 0.31622776601683794 |   10 | 0.70710678118654752
  0.4472135954999579 |   10 | 0.70710678118654752
  0.5477225575051661 |   10 | 0.70710678118654752
(3 rows)

-- select sqrt as nest function with agg (pushdown, explain)
--Testcase 893:
EXPLAIN VERBOSE
SELECT sum(value3),sqrt(sum(value1)) FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (sqrt(sum(value1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), sqrt(sum(`value1`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select sqrt as nest function with agg (pushdown, result)
--Testcase 894:
SELECT sum(value3),sqrt(sum(value1)) FROM s3;
        sum         |       sqrt       
--------------------+------------------
 -7.200000040233135 | 2.68328158049675
(1 row)

-- select sqrt as nest with log2 (pushdown, explain)
--Testcase 895:
EXPLAIN VERBOSE
SELECT value1, sqrt(log2(value1)),sqrt(log2(1/value1)) FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, sqrt(log2(value1)), sqrt(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sqrt as nest with log2 (pushdown, result)
--Testcase 896:
SELECT value1, sqrt(log2(value1)),sqrt(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select sqrt with non pushdown func and explicit constant (explain)
--Testcase 897:
EXPLAIN VERBOSE
SELECT sqrt(value2), pi(), 4.1 FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2925 width=48)
   Output: sqrt((value2)::double precision), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select sqrt with non pushdown func and explicit constant (result)
--Testcase 898:
SELECT sqrt(value2), pi(), 4.1 FROM s3;
        sqrt        |        pi         | ?column? 
--------------------+-------------------+----------
                 10 | 3.141592653589793 |      4.1
                 10 | 3.141592653589793 |      4.1
                 10 | 3.141592653589793 |      4.1
 14.142135623730951 | 3.141592653589793 |      4.1
 14.142135623730951 | 3.141592653589793 |      4.1
 14.142135623730951 | 3.141592653589793 |      4.1
(6 rows)

-- select sqrt with order by (explain)
--Testcase 899:
EXPLAIN VERBOSE
SELECT value1, sqrt(1-value3) FROM s3 ORDER BY sqrt(1-value3);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, sqrt(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY sqrt((1 - `value3`)) IS NULL ASC, sqrt((1 - `value3`)) ASC
(4 rows)

-- select sqrt with order by (result)
--Testcase 900:
SELECT value1, sqrt(1-value3) FROM s3 ORDER BY sqrt(1-value3);
 value1 |        sqrt        
--------+--------------------
    0.1 | 1.0488088481701516
    0.2 | 1.0954451150103321
    0.3 |  1.140175425099138
    1.1 |  1.449137674618944
    2.2 | 1.7888543819998317
    3.3 |  2.073644135332772
(6 rows)

-- select sqrt with order by index (result)
--Testcase 901:
SELECT value1, sqrt(1-value3) FROM s3 ORDER BY 2,1;
 value1 |        sqrt        
--------+--------------------
    0.1 | 1.0488088481701516
    0.2 | 1.0954451150103321
    0.3 |  1.140175425099138
    1.1 |  1.449137674618944
    2.2 | 1.7888543819998317
    3.3 |  2.073644135332772
(6 rows)

-- select sqrt with order by index (result)
--Testcase 902:
SELECT value1, sqrt(1-value3) FROM s3 ORDER BY 1,2;
 value1 |        sqrt        
--------+--------------------
    0.1 | 1.0488088481701516
    0.2 | 1.0954451150103321
    0.3 |  1.140175425099138
    1.1 |  1.449137674618944
    2.2 | 1.7888543819998317
    3.3 |  2.073644135332772
(6 rows)

-- select sqrt with group by (explain)
--Testcase 903:
EXPLAIN VERBOSE
SELECT count(value1), sqrt(1-value3) FROM s3 GROUP BY sqrt(1-value3);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (sqrt(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), sqrt((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select sqrt with group by (result)
--Testcase 904:
SELECT count(value1), sqrt(1-value3) FROM s3 GROUP BY sqrt(1-value3);
 count |        sqrt        
-------+--------------------
     1 | 1.0488088488805365
     1 | 1.0954451163706158
     1 | 1.1401754303268112
     1 | 1.4491376828451663
     1 | 1.7888543953278355
     1 | 2.0736441238352072
(6 rows)

-- select sqrt with group by index (result)
--Testcase 905:
SELECT value1, sqrt(1-value3) FROM s3 GROUP BY 2,1;
 value1 |        sqrt        
--------+--------------------
    0.1 | 1.0488088488805365
    0.2 | 1.0954451163706158
    0.3 | 1.1401754303268112
    1.1 | 1.4491376828451663
    2.2 | 1.7888543953278355
    3.3 | 2.0736441238352072
(6 rows)

-- select sqrt with group by index (result)
--Testcase 906:
SELECT value1, sqrt(1-value3) FROM s3 GROUP BY 1,2;
 value1 |        sqrt        
--------+--------------------
    0.1 | 1.0488088488805365
    0.2 | 1.0954451163706158
    0.3 | 1.1401754303268112
    1.1 | 1.4491376828451663
    2.2 | 1.7888543953278355
    3.3 | 2.0736441238352072
(6 rows)

-- select sqrt with group by having (explain)
--Testcase 907:
EXPLAIN VERBOSE
SELECT count(value1), sqrt(1-value3) FROM s3 GROUP BY sqrt(1-value3) HAVING sqrt(avg(value1)) > 0;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=16)
   Output: (count(value1)), (sqrt(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), sqrt((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2 HAVING ((sqrt(avg(`value1`)) > 0))
(5 rows)

-- select sqrt with group by having (result)
--Testcase 908:
SELECT count(value1), sqrt(1-value3) FROM s3 GROUP BY sqrt(1-value3) HAVING sqrt(avg(value1)) > 0;
 count |        sqrt        
-------+--------------------
     1 | 1.0488088488805365
     1 | 1.0954451163706158
     1 | 1.1401754303268112
     1 | 1.4491376828451663
     1 | 1.7888543953278355
     1 | 2.0736441238352072
(6 rows)

-- select sqrt with group by index having (result)
--Testcase 909:
SELECT value1, sqrt(1-value3) FROM s3 GROUP BY 2,1 HAVING sqrt(1-value3) > 0;
 value1 |        sqrt        
--------+--------------------
    0.1 | 1.0488088488805365
    0.2 | 1.0954451163706158
    0.3 | 1.1401754303268112
    1.1 | 1.4491376828451663
    2.2 | 1.7888543953278355
    3.3 | 2.0736441238352072
(6 rows)

-- select sqrt with group by index having (result)
--Testcase 910:
SELECT value1, sqrt(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |        sqrt        
--------+--------------------
    1.1 | 1.4491376828451663
    2.2 | 1.7888543953278355
    3.3 | 2.0736441238352072
(3 rows)

-- select sqrt and as (return null with negative number)
--Testcase 911:
SELECT value1, value3 + 1, sqrt(value1 + 1) as sqrt1 FROM s3;
 value1 |       ?column?       |       sqrt1        
--------+----------------------+--------------------
    0.1 |                  0.9 | 1.0488088481701516
    0.2 |                  0.8 | 1.0954451150103321
    0.3 |                  0.7 |  1.140175425099138
    1.1 | -0.10000000000000009 |  1.449137674618944
    2.2 |  -1.2000000000000002 | 1.7888543819998317
    3.3 |                 -2.3 |  2.073644135332772
(6 rows)

-- select tan (builtin function, explain)
--Testcase 912:
EXPLAIN VERBOSE
SELECT value1, tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..182.50 rows=1706 width=40)
   Output: value1, tan((value2)::double precision), tan(value3), tan((value4)::double precision), '0.5463024898437905'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select tan (builtin function, result)
--Testcase 913:
SELECT value1, tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3;
 value1 |         tan         |         tan          |        tan         |        tan         
--------+---------------------+----------------------+--------------------+--------------------
    0.1 | -0.5872139151569291 | -0.10033467208545055 | 0.5872139151569291 | 0.5463024898437905
    0.2 | -0.5872139151569291 |  -0.2027100355086725 | 0.5872139151569291 | 0.5463024898437905
    0.3 | -0.5872139151569291 | -0.30933624960962325 | 0.5872139151569291 | 0.5463024898437905
    1.1 | -1.7925274837903817 |  -1.9647596572486523 | 1.7925274837903817 | 0.5463024898437905
    2.2 | -1.7925274837903817 |   1.3738230567687946 | 1.7925274837903817 | 0.5463024898437905
    3.3 | -1.7925274837903817 | -0.15974574766003222 | 1.7925274837903817 | 0.5463024898437905
(6 rows)

-- select tan (builtin function, not pushdown constraints, explain)
--Testcase 914:
EXPLAIN VERBOSE
SELECT tan(value1), tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3 WHERE to_hex(value2) = '64';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.91 rows=9 width=40)
   Output: tan(value1), tan((value2)::double precision), tan(value3), tan((value4)::double precision), '0.5463024898437905'::double precision
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select tan (builtin function, not pushdown constraints, result)
--Testcase 915:
SELECT tan(value1), tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3 WHERE to_hex(value2) = '64';
         tan         |         tan         |         tan          |        tan         |        tan         
---------------------+---------------------+----------------------+--------------------+--------------------
 0.10033467208545055 | -0.5872139151569291 | -0.10033467208545055 | 0.5872139151569291 | 0.5463024898437905
  0.2027100355086725 | -0.5872139151569291 |  -0.2027100355086725 | 0.5872139151569291 | 0.5463024898437905
 0.30933624960962325 | -0.5872139151569291 | -0.30933624960962325 | 0.5872139151569291 | 0.5463024898437905
(3 rows)

-- select tan (builtin function, pushdown constraints, explain)
--Testcase 916:
EXPLAIN VERBOSE
SELECT tan(value1), tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3 WHERE value2 != 200;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.72 rows=1697 width=40)
   Output: tan(value1), tan((value2)::double precision), tan(value3), tan((value4)::double precision), '0.5463024898437905'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select tan (builtin function, pushdown constraints, result)
--Testcase 917:
SELECT tan(value1), tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3 WHERE value2 != 200;
         tan         |         tan         |         tan          |        tan         |        tan         
---------------------+---------------------+----------------------+--------------------+--------------------
 0.10033467208545055 | -0.5872139151569291 | -0.10033467208545055 | 0.5872139151569291 | 0.5463024898437905
  0.2027100355086725 | -0.5872139151569291 |  -0.2027100355086725 | 0.5872139151569291 | 0.5463024898437905
 0.30933624960962325 | -0.5872139151569291 | -0.30933624960962325 | 0.5872139151569291 | 0.5463024898437905
(3 rows)

-- select tan (builtin function, tan in constraints, explain)
--Testcase 918:
EXPLAIN VERBOSE
SELECT value1, tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3 WHERE tan(value1) != 1;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..190.74 rows=1697 width=40)
   Output: value1, tan((value2)::double precision), tan(value3), tan((value4)::double precision), '0.5463024898437905'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((tan(`value1`) <> 1))
(4 rows)

-- select tan (builtin function, tan in constraints, result)
--Testcase 919:
SELECT value1, tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3 WHERE tan(value1) != 1;
 value1 |         tan         |         tan          |        tan         |        tan         
--------+---------------------+----------------------+--------------------+--------------------
    0.1 | -0.5872139151569291 | -0.10033467208545055 | 0.5872139151569291 | 0.5463024898437905
    0.2 | -0.5872139151569291 |  -0.2027100355086725 | 0.5872139151569291 | 0.5463024898437905
    0.3 | -0.5872139151569291 | -0.30933624960962325 | 0.5872139151569291 | 0.5463024898437905
    1.1 | -1.7925274837903817 |  -1.9647596572486523 | 1.7925274837903817 | 0.5463024898437905
    2.2 | -1.7925274837903817 |   1.3738230567687946 | 1.7925274837903817 | 0.5463024898437905
    3.3 | -1.7925274837903817 | -0.15974574766003222 | 1.7925274837903817 | 0.5463024898437905
(6 rows)

-- select tan (builtin function, tan in constraints, explain)
--Testcase 920:
EXPLAIN VERBOSE
SELECT tan(value1), tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3 WHERE tan(0.5) > value1;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..151.24 rows=569 width=40)
   Output: tan(value1), tan((value2)::double precision), tan(value3), tan((value4)::double precision), '0.5463024898437905'::double precision
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((0.5463024898437905 > `value1`))
(4 rows)

-- select tan (builtin function, tan in constraints, result)
--Testcase 921:
SELECT tan(value1), tan(value2), tan(value3), tan(value4), tan(0.5) FROM s3 WHERE tan(0.5) > value1;
         tan         |         tan         |         tan          |        tan         |        tan         
---------------------+---------------------+----------------------+--------------------+--------------------
 0.10033467208545055 | -0.5872139151569291 | -0.10033467208545055 | 0.5872139151569291 | 0.5463024898437905
  0.2027100355086725 | -0.5872139151569291 |  -0.2027100355086725 | 0.5872139151569291 | 0.5463024898437905
 0.30933624960962325 | -0.5872139151569291 | -0.30933624960962325 | 0.5872139151569291 | 0.5463024898437905
(3 rows)

-- select tan as nest function with agg (pushdown, explain)
--Testcase 922:
EXPLAIN VERBOSE
SELECT sum(value3),tan(sum(value3)) FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (sum(value3)), (tan(sum(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), tan(sum(`value3`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select tan as nest function with agg (pushdown, result)
--Testcase 923:
SELECT sum(value3),tan(sum(value3)) FROM s3;
        sum         |         tan         
--------------------+---------------------
 -7.200000040233135 | -1.3046210487670151
(1 row)

-- select tan as nest with log2 (pushdown, explain)
--Testcase 924:
EXPLAIN VERBOSE
SELECT value1, tan(log2(value1)),tan(log2(1/value1)) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.80 rows=2560 width=24)
   Output: value1, tan(log2(value1)), tan(log2(('1'::double precision / value1)))
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select tan as nest with log2 (pushdown, result)
--Testcase 925:
SELECT value1, tan(log2(value1)),tan(log2(1/value1)) FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select tan with non pushdown func and explicit constant (explain)
--Testcase 926:
EXPLAIN VERBOSE
SELECT value1, tan(value3), pi(), 4.1 FROM s3;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..176.56 rows=2048 width=56)
   Output: value1, tan(value3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select tan with non pushdown func and explicit constant (result)
--Testcase 927:
SELECT value1, tan(value3), pi(), 4.1 FROM s3;
 value1 |         tan          |        pi         | ?column? 
--------+----------------------+-------------------+----------
    0.1 | -0.10033467208545055 | 3.141592653589793 |      4.1
    0.2 |  -0.2027100355086725 | 3.141592653589793 |      4.1
    0.3 | -0.30933624960962325 | 3.141592653589793 |      4.1
    1.1 |  -1.9647596572486523 | 3.141592653589793 |      4.1
    2.2 |   1.3738230567687946 | 3.141592653589793 |      4.1
    3.3 | -0.15974574766003222 | 3.141592653589793 |      4.1
(6 rows)

-- select tan with order by (explain)
--Testcase 928:
EXPLAIN VERBOSE
SELECT value1, tan(1-value3) FROM s3 ORDER BY tan(1-value3);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=16)
   Output: value1, tan(('1'::double precision - value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3` ORDER BY tan((1 - `value3`)) IS NULL ASC, tan((1 - `value3`)) ASC
(4 rows)

-- select tan with order by (result)
--Testcase 929:
SELECT value1, tan(1-value3) FROM s3 ORDER BY tan(1-value3);
 value1 |         tan          
--------+----------------------
    1.1 |  -1.7098465429045073
    2.2 | 0.058473854459578645
    0.1 |   1.9647596572486523
    3.3 |     2.28584787736698
    0.2 |   2.5721516221263188
    0.3 |   3.6021024479679786
(6 rows)

-- select tan with order by index (result)
--Testcase 930:
SELECT value1, tan(1-value3) FROM s3 ORDER BY 2,1;
 value1 |         tan          
--------+----------------------
    1.1 |  -1.7098465429045073
    2.2 | 0.058473854459578645
    0.1 |   1.9647596572486523
    3.3 |     2.28584787736698
    0.2 |   2.5721516221263188
    0.3 |   3.6021024479679786
(6 rows)

-- select tan with order by index (result)
--Testcase 931:
SELECT value1, tan(1-value3) FROM s3 ORDER BY 1,2;
 value1 |         tan          
--------+----------------------
    0.1 |   1.9647596572486523
    0.2 |   2.5721516221263188
    0.3 |   3.6021024479679786
    1.1 |  -1.7098465429045073
    2.2 | 0.058473854459578645
    3.3 |     2.28584787736698
(6 rows)

-- select tan with group by (explain)
--Testcase 932:
EXPLAIN VERBOSE
SELECT value1, tan(1-value3) FROM s3 GROUP BY value1, tan(1-value3);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=16)
   Output: value1, (tan(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, tan((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select tan with group by (result)
--Testcase 933:
SELECT value1, tan(1-value3) FROM s3 GROUP BY value1, tan(1-value3);
 value1 |         tan         
--------+---------------------
    0.1 |  1.9647596644910343
    0.2 |  2.5721516448236605
    0.3 |   3.602102614564661
    1.1 | -1.7098464493591892
    2.2 | 0.05847390230633418
    3.3 |  2.2858475805310894
(6 rows)

-- select tan with group by index (result)
--Testcase 934:
SELECT value1, tan(1-value3) FROM s3 GROUP BY 2,1;
 value1 |         tan         
--------+---------------------
    0.1 |  1.9647596644910343
    0.2 |  2.5721516448236605
    0.3 |   3.602102614564661
    1.1 | -1.7098464493591892
    2.2 | 0.05847390230633418
    3.3 |  2.2858475805310894
(6 rows)

-- select tan with group by index (result)
--Testcase 935:
SELECT value1, tan(1-value3) FROM s3 GROUP BY 1,2;
 value1 |         tan         
--------+---------------------
    0.1 |  1.9647596644910343
    0.2 |  2.5721516448236605
    0.3 |   3.602102614564661
    1.1 | -1.7098464493591892
    2.2 | 0.05847390230633418
    3.3 |  2.2858475805310894
(6 rows)

-- select tan with group by having (explain)
--Testcase 936:
EXPLAIN VERBOSE
SELECT value1, tan(1-value3) FROM s3 GROUP BY value1, tan(1-value3) HAVING tan(avg(value1)) > 0;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=16)
   Output: value1, (tan(('1'::double precision - value3)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, tan((1 - `value3`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2 HAVING ((tan(avg(`value1`)) > 0))
(5 rows)

-- select tan with group by having (result)
--Testcase 937:
SELECT value1, tan(1-value3) FROM s3 GROUP BY value1, tan(1-value3) HAVING tan(avg(value1)) > 0;
 value1 |         tan         
--------+---------------------
    0.1 |  1.9647596644910343
    0.2 |  2.5721516448236605
    0.3 |   3.602102614564661
    1.1 | -1.7098464493591892
    3.3 |  2.2858475805310894
(5 rows)

-- select tan with group by index having (result)
--Testcase 938:
SELECT value1, tan(1-value3) FROM s3 GROUP BY 2,1 HAVING tan(1-value3) > 0;
 value1 |         tan         
--------+---------------------
    0.1 |  1.9647596644910343
    0.2 |  2.5721516448236605
    0.3 |   3.602102614564661
    2.2 | 0.05847390230633418
    3.3 |  2.2858475805310894
(5 rows)

-- select tan with group by index having (result)
--Testcase 939:
SELECT value1, tan(1-value3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |         tan         
--------+---------------------
    1.1 | -1.7098464493591892
    2.2 | 0.05847390230633418
    3.3 |  2.2858475805310894
(3 rows)

-- select tan and as
--Testcase 940:
SELECT value1, tan(value3) as tan1 FROM s3;
 value1 |         tan1         
--------+----------------------
    0.1 | -0.10033467208545055
    0.2 |  -0.2027100355086725
    0.3 | -0.30933624960962325
    1.1 |  -1.9647596572486523
    2.2 |   1.3738230567687946
    3.3 | -0.15974574766003222
(6 rows)

-- round()
--Testcase 941:
EXPLAIN VERBOSE
SELECT round(value1), round(value3) FROM s3;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..181.68 rows=2048 width=16)
   Output: round(value1), round(value3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

--Testcase 942:
SELECT round(value1), round(value3) FROM s3;
 round | round 
-------+-------
     0 |    -0
     0 |    -0
     0 |    -0
     1 |    -1
     2 |    -2
     3 |    -3
(6 rows)

--Testcase 943:
EXPLAIN VERBOSE
SELECT round(value1), round(abs(value3)) FROM s3;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..186.80 rows=2048 width=16)
   Output: round(value1), round(abs(value3))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value3` FROM `mysql_fdw_regress`.`s3`
(4 rows)

--Testcase 944:
SELECT round(value1), round(abs(value3)) FROM s3;
 round | round 
-------+-------
     0 |     0
     0 |     0
     0 |     0
     1 |     1
     2 |     2
     3 |     3
(6 rows)

--Testcase 945:
EXPLAIN VERBOSE
SELECT round(abs(value2), 2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..219.69 rows=2925 width=32)
   Output: round((abs(value2))::numeric, 2)
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

--Testcase 946:
SELECT round(abs(value2), 2) FROM s3;
 round  
--------
 100.00
 100.00
 100.00
 200.00
 200.00
 200.00
(6 rows)

--Testcase 947:
EXPLAIN VERBOSE
SELECT * FROM s3 WHERE round(abs(value2), 2) = 100.00;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..121.12 rows=3 width=124)
   Output: id, tag1, value1, value2, value3, value4, str1, str2
   Local server startup cost: 10
   Remote query: SELECT `id`, `tag1`, `value1`, `value2`, `value3`, `value4`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((round(abs(`value2`), 2) = 100.00))
(4 rows)

--Testcase 948:
SELECT * FROM s3 WHERE round(abs(value2), 2) = 100.00;
 id | tag1 | value1 | value2 | value3 | value4 |   str1    |   str2    
----+------+--------+--------+--------+--------+-----------+-----------
  0 | a    |    0.1 |    100 |   -0.1 |   -100 | ---XYZ--- |    XYZ   
  1 | a    |    0.2 |    100 |   -0.2 |   -100 | ---XYZ--- |    XYZ   
  2 | a    |    0.3 |    100 |   -0.3 |   -100 | ---XYZ--- |    XYZ   
(3 rows)

--Testcase 949:
EXPLAIN VERBOSE
SELECT * FROM s3 WHERE round(value1) = 1;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..118.36 rows=3 width=124)
   Output: id, tag1, value1, value2, value3, value4, str1, str2
   Local server startup cost: 10
   Remote query: SELECT `id`, `tag1`, `value1`, `value2`, `value3`, `value4`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((round(`value1`) = 1))
(4 rows)

--Testcase 950:
SELECT * FROM s3 WHERE round(value1) = 1;
 id | tag1 | value1 | value2 | value3 | value4 |   str1    |   str2    
----+------+--------+--------+--------+--------+-----------+-----------
  3 | b    |    1.1 |    200 |   -1.1 |   -200 | ---XYZ--- |    XYZ   
(1 row)

--Testcase 951:
EXPLAIN VERBOSE
SELECT * FROM s3 WHERE round(value3) = -1;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..118.36 rows=3 width=124)
   Output: id, tag1, value1, value2, value3, value4, str1, str2
   Local server startup cost: 10
   Remote query: SELECT `id`, `tag1`, `value1`, `value2`, `value3`, `value4`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((round(`value3`) = (-1)))
(4 rows)

--Testcase 952:
SELECT * FROM s3 WHERE round(value3) = -1;
 id | tag1 | value1 | value2 | value3 | value4 |   str1    |   str2    
----+------+--------+--------+--------+--------+-----------+-----------
  3 | b    |    1.1 |    200 |   -1.1 |   -200 | ---XYZ--- |    XYZ   
(1 row)

-- select convert (stub function, explain)
--Testcase 953:
EXPLAIN VERBOSE
SELECT convert(value1, 'decimal(1)'), convert(value2, 'decimal(10, 2)'), convert(id, 'YEAR'), convert(value4, 'binary(1)')::bytea FROM s3;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.75 rows=1861 width=128)
   Output: convert(value1, 'decimal(1)'::text), convert(value2, 'decimal(10, 2)'::text), convert(id, 'YEAR'::text), (convert(value4, 'binary(1)'::text))::bytea
   Local server startup cost: 10
   Remote query: SELECT `id`, `value1`, `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select convert (stub function, result)
--Testcase 954:
SELECT convert(value1, 'decimal(1)'), convert(value2, 'decimal(10, 2)'), convert(id, 'YEAR'), convert(value4, 'binary(1)')::bytea FROM s3;
ERROR:  stub convert(anyelement, text) is called
CONTEXT:  PL/pgSQL function convert(anyelement,text) line 3 at RAISE
-- select convert (stub function, not pushdown constraints, explain)
--Testcase 955:
EXPLAIN VERBOSE
SELECT convert(value1, 'decimal(1)'), convert(value2, 'decimal(10, 2)'), convert(id, 'YEAR'), convert(value4, 'binary(1)')::bytea FROM s3 WHERE to_hex(value2) != '64';
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..202.74 rows=1852 width=128)
   Output: convert(value1, 'decimal(1)'::text), convert(value2, 'decimal(10, 2)'::text), convert(id, 'YEAR'::text), (convert(value4, 'binary(1)'::text))::bytea
   Filter: (to_hex(s3.value2) <> '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value1`, `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select convert (stub function, not pushdown constraints, result)
--Testcase 956:
SELECT convert(value1, 'decimal(1)'), convert(value2, 'decimal(10, 2)'), convert(id, 'YEAR'), convert(value4, 'binary(1)')::bytea FROM s3 WHERE to_hex(value2) != '64';
ERROR:  stub convert(anyelement, text) is called
CONTEXT:  PL/pgSQL function convert(anyelement,text) line 3 at RAISE
-- select convert (stub function, pushdown constraints, explain)
--Testcase 957:
EXPLAIN VERBOSE
SELECT convert(value1, 'decimal(1)'), convert(value2, 'decimal(10, 2)'), convert(id, 'YEAR'), convert(value4, 'binary(1)')::bytea FROM s3 WHERE value2 != 200;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..198.08 rows=1852 width=128)
   Output: convert(value1, 'decimal(1)'::text), convert(value2, 'decimal(10, 2)'::text), convert(id, 'YEAR'::text), (convert(value4, 'binary(1)'::text))::bytea
   Local server startup cost: 10
   Remote query: SELECT `id`, `value1`, `value2`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select convert (stub function, pushdown constraints, result)
--Testcase 958:
SELECT convert(value1, 'decimal(1)'), convert(value2, 'decimal(10, 2)'), convert(id, 'YEAR'), convert(value4, 'binary(1)')::bytea FROM s3 WHERE value2 != 200;
ERROR:  stub convert(anyelement, text) is called
CONTEXT:  PL/pgSQL function convert(anyelement,text) line 3 at RAISE
-- select convert as nest function with agg (pushdown, explain)
--Testcase 959:
EXPLAIN VERBOSE
SELECT sum(id), convert(sum(id), 'YEAR') FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (convert(sum(id), 'YEAR'::text))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), convert(sum(`id`),YEAR) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select convert as nest function with agg (pushdown, result)
--Testcase 960:
SELECT sum(id), convert(sum(id), 'YEAR') FROM s3;
 sum | convert 
-----+---------
  15 | 2015
(1 row)

-- select convert as nest with log2 (pushdown, explain)
--Testcase 961:
EXPLAIN VERBOSE
SELECT convert(log2(value1), 'decimal(12,4)')::numeric, convert(log2(1/value1), 'decimal(12,4)')::numeric FROM s3;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..244.40 rows=2560 width=64)
   Output: (convert(log2(value1), 'decimal(12,4)'::text))::numeric, (convert(log2(('1'::double precision / value1)), 'decimal(12,4)'::text))::numeric
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select convert as nest with log2 (pushdown, result)
--Testcase 962:
SELECT convert(log2(value1), 'decimal(12,4)')::numeric, convert(log2(1/value1), 'decimal(12,4)')::numeric FROM s3;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select cast json_extract with type modifier (explain)
--Testcase 963:
EXPLAIN VERBOSE
SELECT convert(json_extract('{"a": "2000-01-01 12:02:01.123456"}', '$.a'), 'datetime(3)')::timestamp, convert(json_extract('{"a": "2000-01-01 12:02:01.123456"}', '$.a'), 'datetime(3)')::timestamptz, convert(json_extract('{"a": "12:10:20.123456"}', '$.a'), 'time(3)')::time, convert(json_extract('{"a": "12:10:20.123456"}', '$.a'), 'time(3)')::timetz FROM s3;
                                                                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..348.91 rows=3413 width=36)
   Output: (convert(json_extract('{"a": "2000-01-01 12:02:01.123456"}'::json, VARIADIC '{$.a}'::text[]), 'datetime(3)'::text))::timestamp without time zone, (convert(json_extract('{"a": "2000-01-01 12:02:01.123456"}'::json, VARIADIC '{$.a}'::text[]), 'datetime(3)'::text))::timestamp with time zone, (convert(json_extract('{"a": "12:10:20.123456"}'::json, VARIADIC '{$.a}'::text[]), 'time(3)'::text))::time without time zone, (convert(json_extract('{"a": "12:10:20.123456"}'::json, VARIADIC '{$.a}'::text[]), 'time(3)'::text))::time with time zone
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select cast json_extract with type modifier (result)
--Testcase 964:
SELECT convert(json_extract('{"a": "2000-01-01 12:02:01.123456"}', '$.a'), 'datetime(3)')::timestamp, convert(json_extract('{"a": "2000-01-01 12:02:01.123456"}', '$.a'), 'datetime(3)')::timestamptz, convert(json_extract('{"a": "12:10:20.123456"}', '$.a'), 'time(3)')::time, convert(json_extract('{"a": "12:10:20.123456"}', '$.a'), 'time(3)')::timetz FROM s3;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select cast json_extract with type modifier (explain)
--Testcase 965:
EXPLAIN VERBOSE
SELECT convert(json_extract('{"a": 100}', '$.a'), 'decimal(10,2)')::numeric, convert(json_extract('{"a": 10}', '$.a'), 'YEAR')::decimal, convert(json_unquote(json_extract('{"a": "1.123456"}', '$.a')), 'decimal(10, 3)')::numeric FROM s3;
                                                                                                                                                                QUERY PLAN                                                                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..323.31 rows=3413 width=96)
   Output: (convert(json_extract('{"a": 100}'::json, VARIADIC '{$.a}'::text[]), 'decimal(10,2)'::text))::numeric, (convert(json_extract('{"a": 10}'::json, VARIADIC '{$.a}'::text[]), 'YEAR'::text))::numeric, (convert(json_unquote(json_extract('{"a": "1.123456"}'::json, VARIADIC '{$.a}'::text[])), 'decimal(10, 3)'::text))::numeric
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select cast json_extract with type modifier (result)
--Testcase 966:
SELECT convert(json_extract('{"a": 100}', '$.a'), 'decimal(10,2)')::numeric, convert(json_extract('{"a": 10}', '$.a'), 'YEAR')::decimal, convert(json_unquote(json_extract('{"a": "1.123456"}', '$.a')), 'decimal(10, 3)')::numeric FROM s3;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select convert with non pushdown func and explicit constant (explain)
--Testcase 967:
EXPLAIN VERBOSE
SELECT convert(id, 'YEAR'), pi(), 4.1 FROM s3;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..205.06 rows=2925 width=72)
   Output: convert(id, 'YEAR'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select convert with non pushdown func and explicit constant (result)
--Testcase 968:
SELECT convert(id, 'YEAR'), pi(), 4.1 FROM s3;
ERROR:  stub convert(anyelement, text) is called
CONTEXT:  PL/pgSQL function convert(anyelement,text) line 3 at RAISE
-- select convert with order by index (result)
--Testcase 969:
SELECT value1, convert(1.123456 - value1,'char(3)') FROM s3 order by 2,1;
ERROR:  stub convert(anyelement, text) is called
CONTEXT:  PL/pgSQL function convert(anyelement,text) line 3 at RAISE
-- select convert with order by index (result)
--Testcase 970:
SELECT value1, convert(1.123456 - value1,'char(3)') FROM s3 order by 1,2;
ERROR:  stub convert(anyelement, text) is called
CONTEXT:  PL/pgSQL function convert(anyelement,text) line 3 at RAISE
-- select convert and as
--Testcase 971:
SELECT convert(id, 'YEAR') as convert1 FROM s3;
ERROR:  stub convert(anyelement, text) is called
CONTEXT:  PL/pgSQL function convert(anyelement,text) line 3 at RAISE
--Testcase 972:
DROP FOREIGN TABLE s3;
--Testcase 973:
DROP FOREIGN TABLE s4;
-- full text search table
--Testcase 974:
CREATE FOREIGN TABLE ftextsearch(id int, content text) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 'ftextsearch');
-- text search (pushdown, explain)
--Testcase 975:
EXPLAIN VERBOSE
SELECT MATCH_AGAINST(content, 'success catches') AS score, content FROM ftextsearch WHERE MATCH_AGAINST(content, 'success catches','IN BOOLEAN MODE') != 0;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ftextsearch  (cost=100.00..164.67 rows=1455 width=40)
   Output: match_against(VARIADIC ARRAY[content, 'success catches'::text]), content
   Local server startup cost: 10
   Remote query: SELECT `content` FROM `mysql_fdw_regress`.`ftextsearch` WHERE ((MATCH (`content`) AGAINST ( 'success catches' IN BOOLEAN MODE) <> 0))
(4 rows)

-- text search (pushdown, result)
--Testcase 976:
SELECT content FROM (
SELECT MATCH_AGAINST(content, 'success catches') AS score, content FROM ftextsearch WHERE MATCH_AGAINST(content, 'success catches','IN BOOLEAN MODE') != 0) AS t;
             content              
----------------------------------
 Failure teaches success.
 The early bird catches the worm.
(2 rows)

--Testcase 977:
DROP FOREIGN TABLE ftextsearch;
--Testcase 978:
CREATE FOREIGN TABLE s7(id int, tag1 text, value1 float, value2 int, value3 float, value4 int, value5 bit(16), str1 text, str2 text) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 's7');
-- ===================================================================
-- test BIT_XOR()
-- ===================================================================
-- select bit_xor (explain)
--Testcase 979:
EXPLAIN VERBOSE
SELECT bit_xor(id), bit_xor(tag1), bit_xor(value1), bit_xor(value2), bit_xor(value3), bit_xor(value4), bit_xor(value5), bit_xor(str1) FROM s7;
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=172)
   Output: (bit_xor(id)), (bit_xor(tag1)), (bit_xor(value1)), (bit_xor(value2)), (bit_xor(value3)), (bit_xor(value4)), (bit_xor(value5)), (bit_xor(str1))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT bit_xor(`id`), bit_xor(`tag1`), bit_xor(`value1`), bit_xor(`value2`), bit_xor(`value3`), bit_xor(`value4`), bit_xor(`value5`), bit_xor(`str1`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

-- select bit_xor (result)
--Testcase 980:
SELECT bit_xor(id), bit_xor(tag1), bit_xor(value1), bit_xor(value2), bit_xor(value3), bit_xor(value4), bit_xor(value5), bit_xor(str1) FROM s7;
 bit_xor | bit_xor | bit_xor | bit_xor |       bit_xor        | bit_xor |     bit_xor     | bit_xor 
---------+---------+---------+---------+----------------------+---------+-----------------+---------
       1 |       0 |       0 |     172 | 18446744073709551612 |     175 | 111000100110100 |       0
(1 row)

-- select bit_xor with group by (explain)
--Testcase 981:
EXPLAIN VERBOSE
SELECT tag1, bit_xor(value5) FROM s7 GROUP BY tag1;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=64)
   Output: tag1, (bit_xor(value5))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, bit_xor(`value5`) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select bit_xor with group by (result)
--Testcase 982:
SELECT tag1, bit_xor(value5) FROM s7 GROUP BY tag1;
 tag1 |     bit_xor      
------+------------------
 a    | 1110110100000000
 b    | 1001110000110100
(2 rows)

-- select bit_xor with group by having (explain)
--Testcase 983:
EXPLAIN VERBOSE
SELECT id, bit_xor(value5) FROM s7 GROUP BY id, str1 HAVING bit_xor(value5) > 0::bit;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=67 width=68)
   Output: id, (bit_xor(value5)), str1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, bit_xor(`value5`), `str1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((bit_xor(`value5`) > B'0'))
(5 rows)

-- select bit_xor with group by having (result)
--Testcase 984:
SELECT id, bit_xor(value5) FROM s7 GROUP BY id, str1 HAVING bit_xor(value5) > 0::bit;
 id |     bit_xor      
----+------------------
  0 | 1001000110100
  1 | 1111111100110100
  3 | 1111101000110100
  4 | 1100110100110100
  5 | 1010101100110100
(5 rows)

-- ===================================================================
-- test GROUP_CONCAT()
-- ===================================================================
-- select group_concat (explain)
--Testcase 985:
EXPLAIN VERBOSE
SELECT group_concat(id), group_concat(tag1), group_concat(value1), group_concat(value2), group_concat(value3), group_concat(str2) FROM s7;
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=192)
   Output: (group_concat(id)), (group_concat(tag1)), (group_concat(value1)), (group_concat(value2)), (group_concat(value3)), (group_concat(str2))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(`id`), group_concat(`tag1`), group_concat(`value1`), group_concat(`value2`), group_concat(`value3`), group_concat(`str2`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

-- select group_concat (result)
--Testcase 986:
SELECT group_concat(id), group_concat(tag1), group_concat(value1), group_concat(value2), group_concat(value3), group_concat(str2) FROM s7;
 group_concat | group_concat |      group_concat       |      group_concat       |         group_concat          |                        group_concat                         
--------------+--------------+-------------------------+-------------------------+-------------------------------+-------------------------------------------------------------
 0,1,2,3,4,5  | a,a,a,b,b,b  | 0.1,0.2,0.3,1.1,2.2,3.3 | 100,100,100,200,200,200 | -0.1,-0.2,-0.3,-1.1,-2.2,-3.3 |    XYZ   ,   XYZ   ,   XYZ   ,   XYZ   ,   XYZ   ,   XYZ   
(1 row)

-- select group_concat (explain)
--Testcase 987:
EXPLAIN VERBOSE
SELECT group_concat(value1 + 1) FROM s7;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=32)
   Output: (group_concat((value1 + '1'::double precision)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat((`value1` + 1)) FROM `mysql_fdw_regress`.`s7`
(5 rows)

-- select group_concat with group by (result)
--Testcase 988:
SELECT group_concat(value1 + 1) FROM s7;
                                                 group_concat                                                  
---------------------------------------------------------------------------------------------------------------
 1.1000000014901161,1.2000000029802322,1.300000011920929,2.100000023841858,3.200000047683716,4.299999952316284
(1 row)

-- select group_concat with stub function (explain)
--Testcase 989:
EXPLAIN VERBOSE
SELECT id, group_concat(sqrt(value1)) FROM s7 GROUP BY id;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=36)
   Output: id, (group_concat(sqrt(value1)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(sqrt(`value1`)) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select group_concat with stub function (result)
--Testcase 990:
SELECT id, group_concat(sqrt(value1)) FROM s7 GROUP BY id;
 id |    group_concat    
----+--------------------
  0 | 0.3162277683729184
  1 | 0.4472135988319589
  2 | 0.5477225683874355
  3 | 1.0488088595363112
  4 | 1.4832397134933097
  5 | 1.8165901993339841
(6 rows)

-- select group_concat with group by (explain)
--Testcase 991:
EXPLAIN VERBOSE
SELECT id, group_concat(value3) FROM s7 GROUP BY 1;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=36)
   Output: id, (group_concat(value3))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(`value3`) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select group_concat with group by(explain)
--Testcase 992:
SELECT id, group_concat(value3) FROM s7 GROUP BY 1;
 id | group_concat 
----+--------------
  0 | -0.1
  1 | -0.2
  2 | -0.3
  3 | -1.1
  4 | -2.2
  5 | -3.3
(6 rows)

-- select group_concat with group by having (explain)
--Testcase 993:
EXPLAIN VERBOSE
SELECT id, group_concat(value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(value3) IS NOT NULL;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=44)
   Output: id, (group_concat(value3)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(`value3`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((group_concat(`value3`) IS NOT NULL))
(5 rows)

-- select group_concat with group by having (result)
--Testcase 994:
SELECT id, group_concat(value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(value3) IS NOT NULL;
 id | group_concat 
----+--------------
  0 | -0.1
  1 | -0.2
  2 | -0.3
  3 | -1.1
  4 | -2.2
  5 | -3.3
(6 rows)

-- select group_concat with group by having (explain)
--Testcase 995:
EXPLAIN VERBOSE
SELECT id, group_concat(value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(value3 + 1) IS NOT NULL;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=44)
   Output: id, (group_concat(value3)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(`value3`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((group_concat((`value3` + 1)) IS NOT NULL))
(5 rows)

-- select group_concat with group by having (result)
--Testcase 996:
SELECT id, group_concat(value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(value3 + 1) IS NOT NULL;
 id | group_concat 
----+--------------
  0 | -0.1
  1 | -0.2
  2 | -0.3
  3 | -1.1
  4 | -2.2
  5 | -3.3
(6 rows)

-- select group_concat with group by having (explain)
--Testcase 997:
EXPLAIN VERBOSE
SELECT id, group_concat(value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(abs(value3)) IS NOT NULL;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=44)
   Output: id, (group_concat(value3)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(`value3`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((group_concat(abs(`value3`)) IS NOT NULL))
(5 rows)

-- select group_concat with group by having (result)
--Testcase 998:
SELECT id, group_concat(value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(abs(value3)) IS NOT NULL;
 id | group_concat 
----+--------------
  0 | -0.1
  1 | -0.2
  2 | -0.3
  3 | -1.1
  4 | -2.2
  5 | -3.3
(6 rows)

-- select group_concat with multiple argument by ROW() expression.
--Testcase 999:
EXPLAIN VERBOSE
SELECT group_concat((id, tag1, value2, str1, value5)) FROM s7;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=32)
   Output: (group_concat(ROW(id, tag1, value2, str1, value5)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(`id`, `tag1`, `value2`, `str1`, `value5`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1000:
SELECT group_concat((id, tag1, value2, str1, value5)) FROM s7;
                                    group_concat                                     
-------------------------------------------------------------------------------------
 0a100---XYZ---\x124,1a100---XYZ---4,3b200---XYZ---4,4b200---XYZ---4,5b200---XYZ---4
(1 row)

-- select group_concat with multiple argument by ROW() expression and GROUP BY
--Testcase 1001:
EXPLAIN VERBOSE
SELECT group_concat((id, tag1, value2, str1, value5)) FROM s7 GROUP BY value2;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=36)
   Output: (group_concat(ROW(id, tag1, value2, str1, value5))), value2
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(`id`, `tag1`, `value2`, `str1`, `value5`), `value2` FROM `mysql_fdw_regress`.`s7` GROUP BY 2
(5 rows)

--Testcase 1002:
SELECT group_concat((id, tag1, value2, str1, value5)) FROM s7 GROUP BY value2;
                  group_concat                   
-------------------------------------------------
 0a100---XYZ---\x124,1a100---XYZ---4
 3b200---XYZ---4,4b200---XYZ---4,5b200---XYZ---4
(2 rows)

-- select group_concat with single argument
--Testcase 1003:
EXPLAIN VERBOSE
SELECT group_concat(value1 ORDER BY value1) FROM s7;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=32)
   Output: (group_concat(value1 ORDER BY value1))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(`value1` ORDER BY `value1` ASC) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1004:
SELECT group_concat(value1 ORDER BY value1) FROM s7;
      group_concat       
-------------------------
 0.1,0.2,0.3,1.1,2.2,3.3
(1 row)

-- select group_concat with single argument and ORDER BY
--Testcase 1005:
EXPLAIN VERBOSE
SELECT group_concat(value1 ORDER BY value1 ASC) FROM s7;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=32)
   Output: (group_concat(value1 ORDER BY value1))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(`value1` ORDER BY `value1` ASC) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1006:
SELECT group_concat(value1 ORDER BY value1 ASC) FROM s7;
      group_concat       
-------------------------
 0.1,0.2,0.3,1.1,2.2,3.3
(1 row)

-- select group_concat with single argument and ORDER BY
--Testcase 1007:
EXPLAIN VERBOSE
SELECT group_concat(value1 ORDER BY value1 DESC) FROM s7;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=32)
   Output: (group_concat(value1 ORDER BY value1 DESC))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(`value1` ORDER BY `value1` DESC) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1008:
SELECT group_concat(value1 ORDER BY value1 DESC) FROM s7;
      group_concat       
-------------------------
 3.3,2.2,1.1,0.3,0.2,0.1
(1 row)

-- ===================================================================
-- test GROUP_CONCAT(DISTINCT)
-- ===================================================================
-- select group_concat(DISTINCT) (explain)
--Testcase 1009:
EXPLAIN VERBOSE
SELECT group_concat(DISTINCT id), group_concat(DISTINCT tag1), group_concat(DISTINCT value1), group_concat(DISTINCT value2), group_concat(DISTINCT value3), group_concat(DISTINCT value5), group_concat(DISTINCT str2) FROM s7;
                                                                                                                                     QUERY PLAN                                                                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=224)
   Output: (group_concat(DISTINCT id)), (group_concat(DISTINCT tag1)), (group_concat(DISTINCT value1)), (group_concat(DISTINCT value2)), (group_concat(DISTINCT value3)), (group_concat(DISTINCT value5)), (group_concat(DISTINCT str2))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(DISTINCT `id`), group_concat(DISTINCT `tag1`), group_concat(DISTINCT `value1`), group_concat(DISTINCT `value2`), group_concat(DISTINCT `value3`), group_concat(DISTINCT `value5`), group_concat(DISTINCT `str2`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

-- select group_concat(DISTINCT) (result)
--Testcase 1010:
SELECT group_concat(DISTINCT id), group_concat(DISTINCT tag1), group_concat(DISTINCT value1), group_concat(DISTINCT value2), group_concat(DISTINCT value3), group_concat(DISTINCT value5), group_concat(DISTINCT str2) FROM s7;
 group_concat | group_concat |      group_concat       | group_concat |         group_concat          |         group_concat         | group_concat 
--------------+--------------+-------------------------+--------------+-------------------------------+------------------------------+--------------
 0,1,2,3,4,5  | a,b          | 0.1,0.2,0.3,1.1,2.2,3.3 | 100,200      | -3.3,-2.2,-1.1,-0.3,-0.2,-0.1 | 4660,43828,52532,64052,65332 |    XYZ   
(1 row)

-- select group_concat(DISTINCT) (explain)
--Testcase 1011:
EXPLAIN VERBOSE
SELECT group_concat(DISTINCT (value1 + 1)) FROM s7;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=32)
   Output: (group_concat(DISTINCT (value1 + '1'::double precision)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(DISTINCT (`value1` + 1)) FROM `mysql_fdw_regress`.`s7`
(5 rows)

-- select group_concat(DISTINCT) (result)
--Testcase 1012:
SELECT group_concat(DISTINCT (value1 + 1)) FROM s7;
                                                 group_concat                                                  
---------------------------------------------------------------------------------------------------------------
 1.1000000014901161,1.2000000029802322,1.300000011920929,2.100000023841858,3.200000047683716,4.299999952316284
(1 row)

-- select group_concat(DISTINCT) with group by (explain)
--Testcase 1013:
EXPLAIN VERBOSE
SELECT value2, group_concat(DISTINCT value3) FROM s7 GROUP BY value2;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=36)
   Output: value2, (group_concat(DISTINCT value3))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `value2`, group_concat(DISTINCT `value3`) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select group_concat(DISTINCT) with group by (result)
--Testcase 1014:
SELECT value2, group_concat(DISTINCT value3) FROM s7 GROUP BY value2;
 value2 |  group_concat  
--------+----------------
    100 | -0.3,-0.2,-0.1
    200 | -3.3,-2.2,-1.1
(2 rows)

--Testcase 1015:
EXPLAIN VERBOSE
SELECT group_concat(DISTINCT (id, tag1, value2, str1, value5)) FROM s7;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=32)
   Output: (group_concat(DISTINCT ROW(id, tag1, value2, str1, value5)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(DISTINCT `id`, `tag1`, `value2`, `str1`, `value5`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1016:
SELECT group_concat(DISTINCT (id, tag1, value2, str1, value5)) FROM s7;
                                            group_concat                                            
----------------------------------------------------------------------------------------------------
 0a100---XYZ---4660,1a100---XYZ---65332,3b200---XYZ---64052,4b200---XYZ---52532,5b200---XYZ---43828
(1 row)

--Testcase 1017:
EXPLAIN VERBOSE
SELECT group_concat(DISTINCT (tag1, value2)) FROM s7;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=32)
   Output: (group_concat(DISTINCT ROW(tag1, value2)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT group_concat(DISTINCT `tag1`, `value2`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1018:
SELECT group_concat(DISTINCT (tag1, value2)) FROM s7;
 group_concat 
--------------
 a100,b200
(1 row)

-- select group_concat(DISTINCT) multiple argument with group by (result)
--Testcase 1019:
SELECT value2, group_concat(DISTINCT (tag1, value3, value2)) FROM s7 GROUP BY value2;
 value2 |        group_concat        
--------+----------------------------
    100 | a-0.3100,a-0.2100,a-0.1100
    200 | b-3.3200,b-2.2200,b-1.1200
(2 rows)

-- select group_concat(DISTINCT) with stub function (explain)
--Testcase 1020:
EXPLAIN VERBOSE
SELECT id, group_concat(DISTINCT sqrt(value1)) FROM s7 GROUP BY id;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=36)
   Output: id, (group_concat(DISTINCT sqrt(value1)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(DISTINCT sqrt(`value1`)) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select group_concat(DISTINCT) with stub function (result)
--Testcase 1021:
SELECT id, group_concat(DISTINCT sqrt(value1)) FROM s7 GROUP BY id;
 id |    group_concat    
----+--------------------
  0 | 0.3162277683729184
  1 | 0.4472135988319589
  2 | 0.5477225683874355
  3 | 1.0488088595363112
  4 | 1.4832397134933097
  5 | 1.8165901993339841
(6 rows)

-- select group_concat(DISTINCT) with group by having (explain)
--Testcase 1022:
EXPLAIN VERBOSE
SELECT id, group_concat(DISTINCT value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(DISTINCT value3) IS NOT NULL;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=44)
   Output: id, (group_concat(DISTINCT value3)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(DISTINCT `value3`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((group_concat(DISTINCT `value3`) IS NOT NULL))
(5 rows)

-- select group_concat(DISTINCT) with group by having (result)
--Testcase 1023:
SELECT id, group_concat(DISTINCT value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(DISTINCT value3) IS NOT NULL;
 id | group_concat 
----+--------------
  0 | -0.1
  1 | -0.2
  2 | -0.3
  3 | -1.1
  4 | -2.2
  5 | -3.3
(6 rows)

-- select group_concat(DISTINCT) with group by having (explain)
--Testcase 1024:
EXPLAIN VERBOSE
SELECT id, group_concat(DISTINCT value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(DISTINCT (value3 + 1)) IS NOT NULL;
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=44)
   Output: id, (group_concat(DISTINCT value3)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(DISTINCT `value3`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((group_concat(DISTINCT (`value3` + 1)) IS NOT NULL))
(5 rows)

-- select group_concat(DISTINCT) with group by having (result)
--Testcase 1025:
SELECT id, group_concat(DISTINCT value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(DISTINCT (value3 + 1)) IS NOT NULL;
 id | group_concat 
----+--------------
  0 | -0.1
  1 | -0.2
  2 | -0.3
  3 | -1.1
  4 | -2.2
  5 | -3.3
(6 rows)

-- select group_concat(DISTINCT) with group by having (explain)
--Testcase 1026:
EXPLAIN VERBOSE
SELECT id, group_concat(DISTINCT value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(DISTINCT abs(value3)) IS NOT NULL;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=44)
   Output: id, (group_concat(DISTINCT value3)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, group_concat(DISTINCT `value3`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((group_concat(DISTINCT abs(`value3`)) IS NOT NULL))
(5 rows)

-- select group_concat(DISTINCT) with group by having (result)
--Testcase 1027:
SELECT id, group_concat(DISTINCT value3) FROM s7 GROUP BY 1, value1 HAVING group_concat(DISTINCT abs(value3)) IS NOT NULL;
 id | group_concat 
----+--------------
  0 | -0.1
  1 | -0.2
  2 | -0.3
  3 | -1.1
  4 | -2.2
  5 | -3.3
(6 rows)

-- ===================================================================
-- test COUNT()
-- ===================================================================
-- select count(*)
--Testcase 1028:
EXPLAIN VERBOSE
SELECT COUNT(*) FROM s7;
                          QUERY PLAN                           
---------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=8)
   Output: (count(*))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT count(*) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1029:
SELECT COUNT(*) FROM s7;
 count 
-------
     6
(1 row)

-- select COUNT(expr) [over_clause]
--Testcase 1030:
EXPLAIN VERBOSE
SELECT COUNT(tag1) FROM s7;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=8)
   Output: (count(tag1))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT count(`tag1`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1031:
SELECT COUNT(tag1) FROM s7;
 count 
-------
     6
(1 row)

-- select COUNT(expr) [over_clause]
--Testcase 1032:
EXPLAIN VERBOSE
SELECT COUNT(tag1) FROM s7 GROUP BY tag1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=40)
   Output: (count(tag1)), tag1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT count(`tag1`), `tag1` FROM `mysql_fdw_regress`.`s7` GROUP BY 2
(5 rows)

--Testcase 1033:
SELECT COUNT(tag1) FROM s7 GROUP BY tag1;
 count 
-------
     3
     3
(2 rows)

-- select COUNT(DISTINCT expr,[expr...])
--Testcase 1034:
EXPLAIN VERBOSE
SELECT COUNT(DISTINCT tag1) FROM s7;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=8)
   Output: (count(DISTINCT tag1))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT count(DISTINCT `tag1`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1035:
SELECT COUNT(tag1) FROM s7 GROUP BY tag1;
 count 
-------
     3
     3
(2 rows)

-- select COUNT(DISTINCT expr,[expr...])
--Testcase 1036:
EXPLAIN VERBOSE
SELECT COUNT(DISTINCT (id, tag1, value2, str1, value5)) FROM s7;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=8)
   Output: (count(DISTINCT ROW(id, tag1, value2, str1, value5)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT count(DISTINCT `id`, `tag1`, `value2`, `str1`, `value5`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1037:
SELECT COUNT(DISTINCT (id, tag1, value2, str1, value5)) FROM s7;
 count 
-------
     5
(1 row)

-- select COUNT(DISTINCT expr,[expr...])
--Testcase 1038:
EXPLAIN VERBOSE
SELECT COUNT(DISTINCT (tag1, value2)) FROM s7;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=8)
   Output: (count(DISTINCT ROW(tag1, value2)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT count(DISTINCT `tag1`, `value2`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

--Testcase 1039:
SELECT COUNT(DISTINCT (tag1, value2)) FROM s7;
 count 
-------
     2
(1 row)

-- ===================================================================
-- test JSON_ARRAYAGG()
-- ===================================================================
-- select json_agg (explain)
--Testcase 1040:
EXPLAIN VERBOSE
SELECT json_agg(id), json_agg(tag1), json_agg(value1), json_agg(value2), json_agg(value3), json_agg(value5), json_agg(str1) FROM s7;
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=224)
   Output: (json_agg(id)), (json_agg(tag1)), (json_agg(value1)), (json_agg(value2)), (json_agg(value3)), (json_agg(value5)), (json_agg(str1))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT json_arrayagg(`id`), json_arrayagg(`tag1`), json_arrayagg(`value1`), json_arrayagg(`value2`), json_arrayagg(`value3`), json_arrayagg(`value5`), json_arrayagg(`str1`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

-- select json_agg (result)
--Testcase 1041:
SELECT json_agg(id), json_agg(tag1), json_agg(value1), json_agg(value2), json_agg(value3), json_agg(value5), json_agg(str1) FROM s7;
      json_agg      |            json_agg            |                                                         json_agg                                                         |            json_agg            |                                                            json_agg                                                            |                                                       json_agg                                                       |                                    json_agg                                    
--------------------+--------------------------------+--------------------------------------------------------------------------------------------------------------------------+--------------------------------+--------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------
 [0, 1, 2, 3, 4, 5] | ["a", "a", "a", "b", "b", "b"] | [0.10000000149011612, 0.20000000298023224, 0.30000001192092896, 1.100000023841858, 2.200000047683716, 3.299999952316284] | [100, 100, 100, 200, 200, 200] | [-0.10000000149011612, -0.20000000298023224, -0.30000001192092896, -1.100000023841858, -2.200000047683716, -3.299999952316284] | ["base64:type16:EjQ=", "base64:type16:/zQ=", null, "base64:type16:+jQ=", "base64:type16:zTQ=", "base64:type16:qzQ="] | ["---XYZ---", "---XYZ---", "---XYZ---", "---XYZ---", "---XYZ---", "---XYZ---"]
(1 row)

-- select json_agg with group by (explain)
--Testcase 1042:
EXPLAIN VERBOSE
SELECT tag1, json_agg(value3) FROM s7 GROUP BY tag1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=64)
   Output: tag1, (json_agg(value3))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, json_arrayagg(`value3`) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select json_agg with group by (result)
--Testcase 1043:
SELECT tag1, json_agg(value3) FROM s7 GROUP BY tag1;
 tag1 |                              json_agg                              
------+--------------------------------------------------------------------
 a    | [-0.10000000149011612, -0.20000000298023224, -0.30000001192092896]
 b    | [-1.100000023841858, -2.200000047683716, -3.299999952316284]
(2 rows)

-- select json_agg with group by (explain)
--Testcase 1044:
EXPLAIN VERBOSE
SELECT tag1, json_agg(value3 + 1) FROM s7 GROUP BY tag1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=64)
   Output: tag1, (json_agg((value3 + '1'::double precision)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, json_arrayagg((`value3` + 1)) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select json_agg with group by (result)
--Testcase 1045:
SELECT tag1, json_agg(value3 + 1) FROM s7 GROUP BY tag1;
 tag1 |                            json_agg                             
------+-----------------------------------------------------------------
 a    | [0.8999999985098839, 0.7999999970197678, 0.699999988079071]
 b    | [-0.10000002384185792, -1.2000000476837158, -2.299999952316284]
(2 rows)

-- select json_agg with stub function (explain)
--Testcase 1046:
EXPLAIN VERBOSE
SELECT tag1, json_agg(abs(value3)) FROM s7 GROUP BY tag1;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=64)
   Output: tag1, (json_agg(abs(value3)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, json_arrayagg(abs(`value3`)) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select json_agg with stub function (result)
--Testcase 1047:
SELECT tag1, json_agg(abs(value3)) FROM s7 GROUP BY tag1;
 tag1 |                            json_agg                             
------+-----------------------------------------------------------------
 a    | [0.10000000149011612, 0.20000000298023224, 0.30000001192092896]
 b    | [1.100000023841858, 2.200000047683716, 3.299999952316284]
(2 rows)

-- select json_agg with group by having (explain)
--Testcase 1048:
EXPLAIN VERBOSE
SELECT tag1, json_agg(value3) FROM s7 GROUP BY 1, value1 HAVING json_agg(value3) IS NOT NULL;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=72)
   Output: tag1, (json_agg(value3)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, json_arrayagg(`value3`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((json_arrayagg(`value3`) IS NOT NULL))
(5 rows)

-- select json_agg with group by having (result)
--Testcase 1049:
SELECT tag1, json_agg(value3) FROM s7 GROUP BY 1, value1 HAVING json_agg(value3) IS NOT NULL;
 tag1 |        json_agg        
------+------------------------
 a    | [-0.10000000149011612]
 a    | [-0.20000000298023224]
 a    | [-0.30000001192092896]
 b    | [-1.100000023841858]
 b    | [-2.200000047683716]
 b    | [-3.299999952316284]
(6 rows)

-- select json_agg with group by having (explain)
--Testcase 1050:
EXPLAIN VERBOSE
SELECT tag1, json_agg(value3 + 1) FROM s7 GROUP BY 1, value1 HAVING json_agg(value3 + 1) IS NOT NULL;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=72)
   Output: tag1, (json_agg((value3 + '1'::double precision))), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, json_arrayagg((`value3` + 1)), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((json_arrayagg((`value3` + 1)) IS NOT NULL))
(5 rows)

-- select json_agg with group by having (result)
--Testcase 1051:
SELECT tag1, json_agg(value3 + 1) FROM s7 GROUP BY 1, value1 HAVING json_agg(value3 + 1) IS NOT NULL;
 tag1 |        json_agg        
------+------------------------
 a    | [0.8999999985098839]
 a    | [0.7999999970197678]
 a    | [0.699999988079071]
 b    | [-0.10000002384185792]
 b    | [-1.2000000476837158]
 b    | [-2.299999952316284]
(6 rows)

-- select json_agg with group by having (explain)
--Testcase 1052:
EXPLAIN VERBOSE
SELECT tag1, json_agg(abs(value3)) FROM s7 GROUP BY 1, value1 HAVING json_agg(abs(value3)) IS NOT NULL;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=72)
   Output: tag1, (json_agg(abs(value3))), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, json_arrayagg(abs(`value3`)), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((json_arrayagg(abs(`value3`)) IS NOT NULL))
(5 rows)

-- select json_agg with group by having (result)
--Testcase 1053:
SELECT tag1, json_agg(abs(value3)) FROM s7 GROUP BY 1, value1 HAVING json_agg(abs(value3)) IS NOT NULL;
 tag1 |       json_agg        
------+-----------------------
 a    | [0.10000000149011612]
 a    | [0.20000000298023224]
 a    | [0.30000001192092896]
 b    | [1.100000023841858]
 b    | [2.200000047683716]
 b    | [3.299999952316284]
(6 rows)

-- ===================================================================
-- test JSON_OBJECTAGG()
-- ===================================================================
-- select json_objectagg (explain)
--Testcase 1054:
EXPLAIN VERBOSE
SELECT json_object_agg(tag1, str1), json_object_agg(id, value4) FROM s7;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=64)
   Output: (json_object_agg(tag1, str1)), (json_object_agg(id, value4))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT json_objectagg(`tag1`, `str1`), json_objectagg(`id`, `value4`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

-- select json_objectagg (result)
--Testcase 1055:
SELECT json_object_agg(tag1, str1), json_object_agg(id, value4) FROM s7;
           json_object_agg            |                          json_object_agg                           
--------------------------------------+--------------------------------------------------------------------
 {"a": "---XYZ---", "b": "---XYZ---"} | {"0": -100, "1": -101, "2": -102, "3": -200, "4": -210, "5": -220}
(1 row)

-- select json_objectagg with group by (explain)
--Testcase 1056:
EXPLAIN VERBOSE
SELECT id, json_object_agg(tag1, str1) FROM s7 GROUP BY id;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=36)
   Output: id, (json_object_agg(tag1, str1))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, json_objectagg(`tag1`, `str1`) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select json_objectagg with group by (result)
--Testcase 1057:
SELECT id, json_object_agg(tag1, str1) FROM s7 GROUP BY id;
 id |  json_object_agg   
----+--------------------
  0 | {"a": "---XYZ---"}
  1 | {"a": "---XYZ---"}
  2 | {"a": "---XYZ---"}
  3 | {"b": "---XYZ---"}
  4 | {"b": "---XYZ---"}
  5 | {"b": "---XYZ---"}
(6 rows)

-- select json_objectagg with group by (explain)
--Testcase 1058:
EXPLAIN VERBOSE
SELECT id, json_object_agg(tag1, value2 + 1) FROM s7 GROUP BY id;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=36)
   Output: id, (json_object_agg(tag1, (value2 + 1)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, json_objectagg(`tag1`, (`value2` + 1)) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select json_objectagg with group by (result)
--Testcase 1059:
SELECT id, json_object_agg(tag1, value2 + 1) FROM s7 GROUP BY id;
 id | json_object_agg 
----+-----------------
  0 | {"a": 101}
  1 | {"a": 101}
  2 | {"a": 101}
  3 | {"b": 201}
  4 | {"b": 201}
  5 | {"b": 201}
(6 rows)

-- select json_objectagg with stub function (explain)
--Testcase 1060:
EXPLAIN VERBOSE
SELECT id, json_object_agg(tag1, abs(value2)) FROM s7 GROUP BY id;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=36)
   Output: id, (json_object_agg(tag1, abs(value2)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, json_objectagg(`tag1`, abs(`value2`)) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select json_objectagg with stub function (result)
--Testcase 1061:
SELECT id, json_object_agg(tag1, abs(value2)) FROM s7 GROUP BY id;
 id | json_object_agg 
----+-----------------
  0 | {"a": 100}
  1 | {"a": 100}
  2 | {"a": 100}
  3 | {"b": 200}
  4 | {"b": 200}
  5 | {"b": 200}
(6 rows)

-- select json_objectagg with group by having (explain)
--Testcase 1062:
EXPLAIN VERBOSE
SELECT id, json_object_agg(tag1, str1) FROM s7 GROUP BY 1, value1 HAVING json_object_agg(tag1, str1) IS NOT NULL;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=44)
   Output: id, (json_object_agg(tag1, str1)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, json_objectagg(`tag1`, `str1`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((json_objectagg(`tag1`, `str1`) IS NOT NULL))
(5 rows)

-- select json_objectagg with group by having (result)
--Testcase 1063:
SELECT id, json_object_agg(tag1, str1) FROM s7 GROUP BY 1, value1 HAVING json_object_agg(tag1, str1) IS NOT NULL;
 id |  json_object_agg   
----+--------------------
  0 | {"a": "---XYZ---"}
  1 | {"a": "---XYZ---"}
  2 | {"a": "---XYZ---"}
  3 | {"b": "---XYZ---"}
  4 | {"b": "---XYZ---"}
  5 | {"b": "---XYZ---"}
(6 rows)

-- select json_objectagg with group by having (explain)
--Testcase 1064:
EXPLAIN VERBOSE
SELECT id, json_object_agg(tag1, str1) FROM s7 GROUP BY 1, value1 HAVING json_object_agg(tag1, abs(value2 + 1)) IS NOT NULL;
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=44)
   Output: id, (json_object_agg(tag1, str1)), value1
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `id`, json_objectagg(`tag1`, `str1`), `value1` FROM `mysql_fdw_regress`.`s7` GROUP BY 1, 3 HAVING ((json_objectagg(`tag1`, abs((`value2` + 1))) IS NOT NULL))
(5 rows)

-- select json_objectagg with group by having (result)
--Testcase 1065:
SELECT id, json_object_agg(tag1, str1) FROM s7 GROUP BY 1, value1 HAVING json_object_agg(tag1, abs(value2 + 1)) IS NOT NULL;
 id |  json_object_agg   
----+--------------------
  0 | {"a": "---XYZ---"}
  1 | {"a": "---XYZ---"}
  2 | {"a": "---XYZ---"}
  3 | {"b": "---XYZ---"}
  4 | {"b": "---XYZ---"}
  5 | {"b": "---XYZ---"}
(6 rows)

-- ===================================================================
-- test STD()
-- ===================================================================
-- select std (explain)
--Testcase 1066:
EXPLAIN VERBOSE
SELECT std(id), std(tag1), std(value1), std(value2), std(value3), std(str1) FROM s7;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=48)
   Output: (std(id)), (std(tag1)), (std(value1)), (std(value2)), (std(value3)), (std(str1))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT std(`id`), std(`tag1`), std(`value1`), std(`value2`), std(`value3`), std(`str1`) FROM `mysql_fdw_regress`.`s7`
(5 rows)

-- select std (result)
--Testcase 1067:
SELECT std(id), std(tag1), std(value1), std(value2), std(value3), std(str1) FROM s7;
        std        | std |        std        | std |        std        | std 
-------------------+-----+-------------------+-----+-------------------+-----
 1.707825127659933 |   0 | 1.186029781781151 |  50 | 1.186029781781151 |   0
(1 row)

-- select std with group by (explain)
--Testcase 1068:
EXPLAIN VERBOSE
SELECT tag1, std(value4) FROM s7 GROUP BY tag1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=40)
   Output: tag1, (std(value4))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, std(`value4`) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select std with group by (result)
--Testcase 1069:
SELECT tag1, std(value4) FROM s7 GROUP BY tag1;
 tag1 |        std        
------+-------------------
 a    | 0.816496580927726
 b    |  8.16496580927726
(2 rows)

-- select std with group by (explain)
--Testcase 1070:
EXPLAIN VERBOSE
SELECT tag1, std(value4 + 1) FROM s7 GROUP BY tag1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=200 width=40)
   Output: tag1, (std((value4 + 1)))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, std((`value4` + 1)) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select std with group by (result)
--Testcase 1071:
SELECT tag1, std(value4 + 1) FROM s7 GROUP BY tag1;
 tag1 |        std        
------+-------------------
 a    | 0.816496580927726
 b    |  8.16496580927726
(2 rows)

-- select std with stub function (explain)
--Testcase 1072:
EXPLAIN VERBOSE
SELECT tag1, std(abs(value4 + 1)) FROM s7 GROUP BY tag1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: tag1, (std(abs((value4 + 1))))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, std(abs((`value4` + 1))) FROM `mysql_fdw_regress`.`s7` GROUP BY 1
(5 rows)

-- select std with stub function (result)
--Testcase 1073:
SELECT tag1, std(abs(value4 + 1)) FROM s7 GROUP BY tag1;
 tag1 |        std        
------+-------------------
 a    | 0.816496580927726
 b    |  8.16496580927726
(2 rows)

-- select std with group by having (explain)
--Testcase 1074:
EXPLAIN VERBOSE
SELECT tag1, std(value4) FROM s7 GROUP BY 1 HAVING std(value4) > 0;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=67 width=40)
   Output: tag1, (std(value4))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, std(`value4`) FROM `mysql_fdw_regress`.`s7` GROUP BY 1 HAVING ((std(`value4`) > 0))
(5 rows)

-- select std with group by having (result)
--Testcase 1075:
SELECT tag1, std(value4) FROM s7 GROUP BY 1 HAVING std(value4) > 0;
 tag1 |        std        
------+-------------------
 a    | 0.816496580927726
 b    |  8.16496580927726
(2 rows)

-- select std with group by having (explain)
--Testcase 1076:
EXPLAIN VERBOSE
SELECT tag1, std(value4) FROM s7 GROUP BY 1 HAVING std(abs(value4 + 1)) > 0;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=67 width=40)
   Output: tag1, (std(value4))
   Relations: Aggregate on (mysql_fdw_regress.s7)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, std(`value4`) FROM `mysql_fdw_regress`.`s7` GROUP BY 1 HAVING ((std(abs((`value4` + 1))) > 0))
(5 rows)

-- select std with group by having (result)
--Testcase 1077:
SELECT tag1, std(value4) FROM s7 GROUP BY 1 HAVING std(abs(value4 + 1)) > 0;
 tag1 |        std        
------+-------------------
 a    | 0.816496580927726
 b    |  8.16496580927726
(2 rows)

--Testcase 1078:
DROP FOREIGN TABLE s7;
--Testcase 1079:
CREATE FOREIGN TABLE s5(id int, b bit, b8 bit(8), b64 bit(64)) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 's5');
--Testcase 1080:
SELECT * FROM s5;
 id | b |    b8    |                               b64                                
----+---+----------+------------------------------------------------------------------
  0 | 1 | 00001101 | 0111111111111111111111111111111111111111111111111100000000000001
  1 | 0 | 00001001 | 0111111111111111111111111111111111111111111000001100000111000001
  2 | 1 | 00001110 | 0111111111111111111111111111111111101010101111111100000000000001
(3 rows)

-- select bit_and, bit_or (pushdown, explain)
--Testcase 1081:
EXPLAIN VERBOSE
SELECT bit_and(b), bit_and(b8), bit_or(b), bit_or(b8), bit_and(b64), bit_or(b64) FROM s5;
                                                                                                                 QUERY PLAN                                                                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=1 width=192)
   Output: (bit_and(b)), (bit_and(b8)), (bit_or(b)), (bit_or(b8)), (bit_and(b64)), (bit_or(b64))
   Relations: Aggregate on (mysql_fdw_regress.s5)
   Local server startup cost: 10
   Remote query: SELECT CAST(bit_and(`b`) AS SIGNED), CAST(bit_and(`b8`) AS SIGNED), CAST(bit_or(`b`) AS SIGNED), CAST(bit_or(`b8`) AS SIGNED), CAST(bit_and(`b64`) AS SIGNED), CAST(bit_or(`b64`) AS SIGNED) FROM `mysql_fdw_regress`.`s5`
(5 rows)

-- select bit_and, bit_or (pushdown, result)
--Testcase 1082:
SELECT bit_and(b), bit_and(b8), bit_or(b), bit_or(b8), bit_and(b64), bit_or(b64) FROM s5;
 bit_and | bit_and | bit_or | bit_or |                             bit_and                             |                             bit_or                              
---------+---------+--------+--------+-----------------------------------------------------------------+-----------------------------------------------------------------
 0       | 1000    | 1      | 1111   | 111111111111111111111111111111111101010101000001100000000000001 | 111111111111111111111111111111111111111111111111100000111000001
(1 row)

--Testcase 1083:
CREATE FOREIGN TABLE s3(id int, tag1 text, value1 float, value2 int, value3 float, value4 int, str1 text, str2 text) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 's3');
-- ===============================================================================
-- test ascii()
-- ===============================================================================
-- select ascii (stub function, explain)
--Testcase 1084:
EXPLAIN VERBOSE
SELECT ascii(tag1), ascii(str1), ascii(str2) FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.57 rows=682 width=12)
   Output: ascii(tag1), ascii(str1), ascii(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ascii (stub function, result)
--Testcase 1085:
SELECT ascii(tag1), ascii(str1), ascii(str2) FROM s3;
 ascii | ascii | ascii 
-------+-------+-------
    97 |    45 |    32
    97 |    45 |    32
    97 |    45 |    32
    98 |    45 |    32
    98 |    45 |    32
    98 |    45 |    32
(6 rows)

-- select ascii (stub function, pushdown constraints, explain)
--Testcase 1086:
EXPLAIN VERBOSE
SELECT ascii(tag1), ascii(str1), ascii(str2) FROM s3 WHERE value2 != 100;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..137.20 rows=679 width=12)
   Output: ascii(tag1), ascii(str1), ascii(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 100))
(4 rows)

-- select ascii (stub function, pushdown constraints, result)
--Testcase 1087:
SELECT ascii(tag1), ascii(str1), ascii(str2) FROM s3 WHERE value2 != 100;
 ascii | ascii | ascii 
-------+-------+-------
    98 |    45 |    32
    98 |    45 |    32
    98 |    45 |    32
(3 rows)

-- select ascii (stub function, ascii in constraints, explain)
--Testcase 1088:
EXPLAIN VERBOSE
SELECT ascii(tag1), ascii(str1), ascii(str2) FROM s3 WHERE ascii(str1) <= 97;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..126.47 rows=227 width=12)
   Output: ascii(tag1), ascii(str1), ascii(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((ascii(`str1`) <= 97))
(4 rows)

-- select ascii (stub function, ascii in constraints, explain)
--Testcase 1089:
SELECT ascii(tag1), ascii(str1), ascii(str2) FROM s3 WHERE ascii(str1) <= 97;
 ascii | ascii | ascii 
-------+-------+-------
    97 |    45 |    32
    97 |    45 |    32
    97 |    45 |    32
    98 |    45 |    32
    98 |    45 |    32
    98 |    45 |    32
(6 rows)

-- select ascii with non pushdown func and explicit constant (explain)
--Testcase 1090:
EXPLAIN VERBOSE
SELECT ascii(str1), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: ascii(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ascii with non pushdown func and explicit constant (result)
--Testcase 1091:
SELECT ascii(str1), pi(), 4.1 FROM s3;
 ascii |        pi         | ?column? 
-------+-------------------+----------
    45 | 3.141592653589793 |      4.1
    45 | 3.141592653589793 |      4.1
    45 | 3.141592653589793 |      4.1
    45 | 3.141592653589793 |      4.1
    45 | 3.141592653589793 |      4.1
    45 | 3.141592653589793 |      4.1
(6 rows)

-- select ascii with order by (explain)
--Testcase 1092:
EXPLAIN VERBOSE
SELECT value1, ascii(str2) FROM s3 ORDER BY ascii(str2);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, ascii(str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY ascii(`str2`) IS NULL ASC, ascii(`str2`) ASC
(4 rows)

-- select ascii with order by (result)
--Testcase 1093:
SELECT value1, ascii(str2) FROM s3 ORDER BY ascii(str2);
 value1 | ascii 
--------+-------
    0.1 |    32
    0.2 |    32
    0.3 |    32
    1.1 |    32
    2.2 |    32
    3.3 |    32
(6 rows)

-- select ascii with order by index (result)
--Testcase 1094:
SELECT value1, ascii(str2) FROM s3 ORDER BY 2,1;
 value1 | ascii 
--------+-------
    0.1 |    32
    0.2 |    32
    0.3 |    32
    1.1 |    32
    2.2 |    32
    3.3 |    32
(6 rows)

-- select ascii with group by (explain)
--Testcase 1095:
EXPLAIN VERBOSE
SELECT count(value1), ascii(str1) FROM s3 GROUP BY ascii(str1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (ascii(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ascii(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select ascii with group by (result)
--Testcase 1096:
SELECT count(value1), ascii(str1) FROM s3 GROUP BY ascii(str1);
 count | ascii 
-------+-------
     6 |    45
(1 row)

-- select ascii with group by index (result)
--Testcase 1097:
SELECT value1, ascii(str1) FROM s3 GROUP BY 2,1;
 value1 | ascii 
--------+-------
    0.1 |    45
    0.2 |    45
    0.3 |    45
    1.1 |    45
    2.2 |    45
    3.3 |    45
(6 rows)

-- select ascii with group by having (explain)
--Testcase 1098:
EXPLAIN VERBOSE
SELECT count(value1), ascii(str1) FROM s3 GROUP BY ascii(str1) HAVING ascii(str1) IS NOT NULL;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (ascii(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ascii(`str1`) FROM `mysql_fdw_regress`.`s3` WHERE ((ascii(`str1`) IS NOT NULL)) GROUP BY 2
(5 rows)

-- select ascii with group by having (explain)
--Testcase 1099:
SELECT count(value1), ascii(str1) FROM s3 GROUP BY ascii(str1) HAVING ascii(str1) IS NOT NULL;
 count | ascii 
-------+-------
     6 |    45
(1 row)

-- select ascii with group by index having (result)
--Testcase 1100:
SELECT value1, ascii(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | ascii 
--------+-------
    1.1 |    45
    2.2 |    45
    3.3 |    45
(3 rows)

-- ===============================================================================
-- test bin()
-- ===============================================================================
-- select bin (stub function, explain)
--Testcase 1101:
EXPLAIN VERBOSE
SELECT id, bin(id), bin(value2), bin(value4) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2275 width=100)
   Output: id, bin((id)::numeric), bin((value2)::numeric), bin((value4)::numeric)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select bin (stub function, result)
--Testcase 1102:
SELECT id, bin(id), bin(value2), bin(value4) FROM s3;
ERROR:  stub bin(numeric) is called
CONTEXT:  PL/pgSQL function bin(numeric) line 3 at RAISE
-- select bin (stub function, pushdown constraints, explain)
--Testcase 1103:
EXPLAIN VERBOSE
SELECT bin(id), bin(value2) FROM s3 WHERE value2 != 200;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..218.41 rows=2547 width=64)
   Output: bin((id)::numeric), bin((value2)::numeric)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select bin (stub function, pushdown constraints, result)
--Testcase 1104:
SELECT bin(id), bin(value2) FROM s3 WHERE value2 != 200;
ERROR:  stub bin(numeric) is called
CONTEXT:  PL/pgSQL function bin(numeric) line 3 at RAISE
-- select bin (stub function, bin in constraints, explain)
--Testcase 1105:
EXPLAIN VERBOSE
SELECT bin(id), bin(value2) FROM s3 WHERE bin(value2) != '1100100';
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..231.21 rows=2547 width=64)
   Output: bin((id)::numeric), bin((value2)::numeric)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((bin(`value2`) <> '1100100'))
(4 rows)

-- select bin (stub function, bin in constraints, explain)
--Testcase 1106:
SELECT bin(id), bin(value2) FROM s3 WHERE bin(value2) != '1100100';
ERROR:  stub bin(numeric) is called
CONTEXT:  PL/pgSQL function bin(numeric) line 3 at RAISE
--select bin as nest function with agg (explain)
--Testcase 1107:
EXPLAIN VERBOSE
SELECT sum(id), bin(sum(value2)) FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (bin((sum(value2))::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), bin(sum(`value2`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

--select bin as nest function with agg (result)
--Testcase 1108:
SELECT sum(id), bin(sum(value2)) FROM s3;
 sum |    bin     
-----+------------
  15 | 1110000100
(1 row)

-- select bin with non pushdown func and explicit constant (explain)
--Testcase 1109:
EXPLAIN VERBOSE
SELECT bin(value2), pi(), 4.1 FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2925 width=72)
   Output: bin((value2)::numeric), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select bin with non pushdown func and explicit constant (explain)
--Testcase 1110:
SELECT bin(value2), pi(), 4.1 FROM s3;
ERROR:  stub bin(numeric) is called
CONTEXT:  PL/pgSQL function bin(numeric) line 3 at RAISE
-- select bin with order by (explain)
--Testcase 1111:
EXPLAIN VERBOSE
SELECT id, bin(value2) FROM s3 ORDER BY bin(value2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=36)
   Output: id, bin((value2)::numeric)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value2` FROM `mysql_fdw_regress`.`s3` ORDER BY bin(`value2`) IS NULL ASC, bin(`value2`) ASC
(4 rows)

-- select bin with order by (result)
--Testcase 1112:
SELECT id, bin(value2) FROM s3 ORDER BY bin(value2);
ERROR:  stub bin(numeric) is called
CONTEXT:  PL/pgSQL function bin(numeric) line 3 at RAISE
-- select bin with order by index (result)
--Testcase 1113:
SELECT value1, bin(value2) FROM s3 ORDER BY 2,1;
ERROR:  stub bin(numeric) is called
CONTEXT:  PL/pgSQL function bin(numeric) line 3 at RAISE
-- select bin with order by index (result)
--Testcase 1114:
SELECT value1, bin(value2) FROM s3 ORDER BY 1,2;
ERROR:  stub bin(numeric) is called
CONTEXT:  PL/pgSQL function bin(numeric) line 3 at RAISE
-- select bin with group by (explain)
--Testcase 1115:
EXPLAIN VERBOSE
SELECT count(value1), bin(value2) FROM s3 GROUP BY bin(value2);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (bin((value2)::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), bin(`value2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select bin with group by (result)
--Testcase 1116:
SELECT count(value1), bin(value2) FROM s3 GROUP BY bin(value2);
 count |   bin    
-------+----------
     3 | 1100100
     3 | 11001000
(2 rows)

-- select bin with group by index (result)
--Testcase 1117:
SELECT value1, bin(value2) FROM s3 GROUP BY 2,1;
 value1 |   bin    
--------+----------
    0.1 | 1100100
    0.2 | 1100100
    0.3 | 1100100
    1.1 | 11001000
    2.2 | 11001000
    3.3 | 11001000
(6 rows)

-- select bin with group by having (explain)
--Testcase 1118:
EXPLAIN VERBOSE
SELECT value1, bin(value2 - 1) FROM s3 GROUP BY 1, bin(value2 - 1) HAVING value1 > 1;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=224 width=40)
   Output: value1, (bin(((value2 - 1))::numeric))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, bin((`value2` - 1)) FROM `mysql_fdw_regress`.`s3` WHERE ((`value1` > 1)) GROUP BY 1, 2
(5 rows)

-- select bin with group by having (result)
--Testcase 1119:
SELECT value1, bin(value2 - 1) FROM s3 GROUP BY 1, bin(value2 - 1) HAVING value1 > 1;
 value1 |   bin    
--------+----------
    1.1 | 11000111
    2.2 | 11000111
    3.3 | 11000111
(3 rows)

-- select bin with group by index having (result)
--Testcase 1120:
SELECT value1, bin(value2 - 1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |   bin    
--------+----------
    1.1 | 11000111
    2.2 | 11000111
    3.3 | 11000111
(3 rows)

-- ===============================================================================
-- test bit_length()
-- ===============================================================================
-- select bit_length (stub function, explain)
--Testcase 1121:
EXPLAIN VERBOSE
SELECT bit_length(tag1), bit_length(str1), bit_length(str2) FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.69 rows=682 width=12)
   Output: (octet_length(tag1) * 8), (octet_length(str1) * 8), (octet_length(str2) * 8)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select bit_length (stub function, result)
--Testcase 1122:
SELECT bit_length(tag1), bit_length(str1), bit_length(str2) FROM s3;
 bit_length | bit_length | bit_length 
------------+------------+------------
          8 |         72 |         72
          8 |         72 |         72
          8 |         72 |         72
          8 |         72 |         72
          8 |         72 |         72
          8 |         72 |         72
(6 rows)

-- select bit_length (stub function, pushdown constraints, explain)
--Testcase 1123:
EXPLAIN VERBOSE
SELECT bit_length(tag1), bit_length(str1), bit_length(str2) FROM s3 WHERE value2 != 100;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.29 rows=679 width=12)
   Output: (octet_length(tag1) * 8), (octet_length(str1) * 8), (octet_length(str2) * 8)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 100))
(4 rows)

-- select bit_length (stub function, pushdown constraints, result)
--Testcase 1124:
SELECT bit_length(tag1), bit_length(str1), bit_length(str2) FROM s3 WHERE value2 != 100;
 bit_length | bit_length | bit_length 
------------+------------+------------
          8 |         72 |         72
          8 |         72 |         72
          8 |         72 |         72
(3 rows)

-- select bit_length (stub function, bit_length in constraints, explain)
--Testcase 1125:
EXPLAIN VERBOSE
SELECT bit_length(tag1), bit_length(str1), bit_length(str2) FROM s3 WHERE value2 != 200;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.29 rows=679 width=12)
   Output: (octet_length(tag1) * 8), (octet_length(str1) * 8), (octet_length(str2) * 8)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select bit_length (stub function, bit_length in constraints, explain)
--Testcase 1126:
SELECT bit_length(tag1), bit_length(str1), bit_length(str2) FROM s3 WHERE value2 != 200;
 bit_length | bit_length | bit_length 
------------+------------+------------
          8 |         72 |         72
          8 |         72 |         72
          8 |         72 |         72
(3 rows)

-- select bit_length with non pushdown func and explicit constant (explain)
--Testcase 1127:
EXPLAIN VERBOSE
SELECT bit_length(str1), pi(), 4.1 FROM s3;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..161.17 rows=1462 width=44)
   Output: (octet_length(str1) * 8), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select bit_length with non pushdown func and explicit constant (result)
--Testcase 1128:
SELECT bit_length(str1), pi(), 4.1 FROM s3;
 bit_length |        pi         | ?column? 
------------+-------------------+----------
         72 | 3.141592653589793 |      4.1
         72 | 3.141592653589793 |      4.1
         72 | 3.141592653589793 |      4.1
         72 | 3.141592653589793 |      4.1
         72 | 3.141592653589793 |      4.1
         72 | 3.141592653589793 |      4.1
(6 rows)

-- select bit_length with order by (explain)
--Testcase 1129:
EXPLAIN VERBOSE
SELECT value1, bit_length(str2) FROM s3 ORDER BY bit_length(str2);
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=12)
   Output: value1, (octet_length(str2) * 8)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY (octet_length(`str2`) * 8) IS NULL ASC, (octet_length(`str2`) * 8) ASC
(4 rows)

-- select bit_length with order by (result)
--Testcase 1130:
SELECT value1, bit_length(str2) FROM s3 ORDER BY bit_length(str2);
 value1 | bit_length 
--------+------------
    0.1 |         72
    0.2 |         72
    0.3 |         72
    1.1 |         72
    2.2 |         72
    3.3 |         72
(6 rows)

-- select bit_length with order by index (result)
--Testcase 1131:
SELECT value1, bit_length(str2) FROM s3 ORDER BY 2,1;
 value1 | bit_length 
--------+------------
    0.1 |         72
    0.2 |         72
    0.3 |         72
    1.1 |         72
    2.2 |         72
    3.3 |         72
(6 rows)

-- select bit_length with group by (explain)
--Testcase 1132:
EXPLAIN VERBOSE
SELECT count(value1), bit_length(str1) FROM s3 GROUP BY bit_length(str1);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), ((octet_length(str1) * 8))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), (octet_length(`str1`) * 8) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select bit_length with group by (result)
--Testcase 1133:
SELECT count(value1), bit_length(str1) FROM s3 GROUP BY bit_length(str1);
 count | bit_length 
-------+------------
     6 |         72
(1 row)

-- select bit_length with group by index (result)
--Testcase 1134:
SELECT value1, bit_length(str1) FROM s3 GROUP BY 2,1;
 value1 | bit_length 
--------+------------
    0.1 |         72
    0.2 |         72
    0.3 |         72
    1.1 |         72
    2.2 |         72
    3.3 |         72
(6 rows)

-- select bit_length with group by having (explain)
--Testcase 1135:
EXPLAIN VERBOSE
SELECT count(value1), bit_length(str1) FROM s3 GROUP BY bit_length(str1), str1 HAVING bit_length(str1) IS NOT NULL;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=44)
   Output: (count(value1)), ((octet_length(str1) * 8)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), (octet_length(`str1`) * 8), `str1` FROM `mysql_fdw_regress`.`s3` WHERE (((octet_length(`str1`) * 8) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select bit_length with group by having (explain)
--Testcase 1136:
SELECT count(value1), bit_length(str1) FROM s3 GROUP BY bit_length(str1), str1 HAVING bit_length(str1) IS NOT NULL;
 count | bit_length 
-------+------------
     6 |         72
(1 row)

-- select bit_length with group by index having (result)
--Testcase 1137:
SELECT value1, bit_length(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | bit_length 
--------+------------
    1.1 |         72
    2.2 |         72
    3.3 |         72
(3 rows)

-- ===============================================================================
-- test char()
-- ===============================================================================
-- select char (stub function, explain)
--Testcase 1138:
EXPLAIN VERBOSE
SELECT mysql_char(value2), mysql_char(value4) FROM s3;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.40 rows=2560 width=64)
   Output: mysql_char((value2)::bigint), mysql_char((value4)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select char (stub function, result)
--Testcase 1139:
SELECT mysql_char(value2), mysql_char(value4) FROM s3;
ERROR:  stub mysql_char(bigint) is called
CONTEXT:  PL/pgSQL function mysql_char(bigint) line 3 at RAISE
-- select char (stub function, not pushdown constraints, explain)
--Testcase 1140:
EXPLAIN VERBOSE
SELECT value1, mysql_char(value2) FROM s3 WHERE to_hex(value2) = '64';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..144.40 rows=11 width=40)
   Output: value1, mysql_char((value2)::bigint)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select char (stub function, not pushdown constraints, result)
--Testcase 1141:
SELECT value1, mysql_char(value2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub mysql_char(bigint) is called
CONTEXT:  PL/pgSQL function mysql_char(bigint) line 3 at RAISE
-- select char (stub function, pushdown constraints, explain)
--Testcase 1142:
EXPLAIN VERBOSE
SELECT value1, mysql_char(value2) FROM s3 WHERE value2 != 200;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.04 rows=2264 width=40)
   Output: value1, mysql_char((value2)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select char (stub function, pushdown constraints, result)
--Testcase 1143:
SELECT value1, mysql_char(value2) FROM s3 WHERE value2 != 200;
ERROR:  stub mysql_char(bigint) is called
CONTEXT:  PL/pgSQL function mysql_char(bigint) line 3 at RAISE
-- select char with non pushdown func and explicit constant (explain)
--Testcase 1144:
EXPLAIN VERBOSE
SELECT mysql_char(value2), pi(), 4.1 FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2925 width=72)
   Output: mysql_char((value2)::bigint), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select char with non pushdown func and explicit constant (result)
--Testcase 1145:
SELECT mysql_char(value2), pi(), 4.1 FROM s3;
ERROR:  stub mysql_char(bigint) is called
CONTEXT:  PL/pgSQL function mysql_char(bigint) line 3 at RAISE
-- select char with order by (explain)
--Testcase 1146:
EXPLAIN VERBOSE
SELECT value1, mysql_char(value2) FROM s3 ORDER BY mysql_char(value2);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=40)
   Output: value1, mysql_char((value2)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3` ORDER BY char(`value2`) IS NULL ASC, char(`value2`) ASC
(4 rows)

-- select char with order by (result)
--Testcase 1147:
SELECT value1, mysql_char(value2) FROM s3 ORDER BY mysql_char(value2);
ERROR:  stub mysql_char(bigint) is called
CONTEXT:  PL/pgSQL function mysql_char(bigint) line 3 at RAISE
-- select char with order by index (result)
--Testcase 1148:
SELECT value1, mysql_char(value2) FROM s3 ORDER BY 1,2;
ERROR:  stub mysql_char(bigint) is called
CONTEXT:  PL/pgSQL function mysql_char(bigint) line 3 at RAISE
-- select char with group by (explain)
--Testcase 1149:
EXPLAIN VERBOSE
SELECT value1, mysql_char(value2) FROM s3 GROUP BY value1, mysql_char(value2);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=40)
   Output: value1, (mysql_char((value2)::bigint))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, char(`value2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select char with group by (result)
--Testcase 1150:
SELECT value1, mysql_char(value2) FROM s3 GROUP BY value1, mysql_char(value2);
 value1 | mysql_char 
--------+------------
    0.1 | d
    0.2 | d
    0.3 | d
    1.1 | 
    2.2 | 
    3.3 | 
(6 rows)

-- select char with group by index (result)
--Testcase 1151:
SELECT value1, mysql_char(value2) FROM s3 GROUP BY 2,1;
 value1 | mysql_char 
--------+------------
    0.1 | d
    0.2 | d
    0.3 | d
    1.1 | 
    2.2 | 
    3.3 | 
(6 rows)

-- select char with group by having (explain)
--Testcase 1152:
EXPLAIN VERBOSE
SELECT value1, mysql_char(value2) FROM s3 GROUP BY mysql_char(value2), value2, value1 HAVING mysql_char(value2) IS NOT NULL;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=227 width=44)
   Output: value1, (mysql_char((value2)::bigint)), value2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, char(`value2`), `value2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 1 HAVING ((char(`value2`) IS NOT NULL))
(5 rows)

-- select char with group by having (result)
--Testcase 1153:
SELECT value1, mysql_char(value2) FROM s3 GROUP BY mysql_char(value2), value2, value1 HAVING mysql_char(value2) IS NOT NULL;
 value1 | mysql_char 
--------+------------
    0.1 | d
    0.2 | d
    0.3 | d
    1.1 | 
    2.2 | 
    3.3 | 
(6 rows)

-- select char with group by index having (result)
--Testcase 1154:
SELECT value1, mysql_char(value2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | mysql_char 
--------+------------
    1.1 | 
    2.2 | 
    3.3 | 
(3 rows)

-- ===============================================================================
-- test char_length()
-- ===============================================================================
-- select char_length (stub function, explain)
--Testcase 1155:
EXPLAIN VERBOSE
SELECT char_length(tag1), char_length(str1), char_length(str2) FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.57 rows=682 width=12)
   Output: char_length(tag1), char_length(str1), char_length(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select char_length (stub function, result)
--Testcase 1156:
SELECT char_length(tag1), char_length(str1), char_length(str2) FROM s3;
 char_length | char_length | char_length 
-------------+-------------+-------------
           1 |           9 |           9
           1 |           9 |           9
           1 |           9 |           9
           1 |           9 |           9
           1 |           9 |           9
           1 |           9 |           9
(6 rows)

-- select char_length (stub function, not pushdown constraints, explain)
--Testcase 1157:
EXPLAIN VERBOSE
SELECT id, char_length(str1) FROM s3 WHERE to_hex(value2) = '64';
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..130.63 rows=7 width=8)
   Output: id, char_length(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select char_length (stub function, not pushdown constraints, explain)
--Testcase 1158:
SELECT id, char_length(str1) FROM s3 WHERE to_hex(value2) = '64';
 id | char_length 
----+-------------
  0 |           9
  1 |           9
  2 |           9
(3 rows)

-- select char_length (stub function, char_length in constraints, explain)
--Testcase 1159:
EXPLAIN VERBOSE
SELECT id, char_length(str1) FROM s3 WHERE char_length(str1) > 0;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.71 rows=455 width=8)
   Output: id, char_length(str1)
   Local server startup cost: 10
   Remote query: SELECT `id`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((char_length(`str1`) > 0))
(4 rows)

-- select char_length (stub function, char_length in constraints, result)
--Testcase 1160:
SELECT id, char_length(str1) FROM s3 WHERE char_length(str1) > 0;
 id | char_length 
----+-------------
  0 |           9
  1 |           9
  2 |           9
  3 |           9
  4 |           9
  5 |           9
(6 rows)

-- select char_length with non pushdown func and explicit constant (explain)
--Testcase 1161:
EXPLAIN VERBOSE
SELECT char_length(str1), pi(), 4.1 FROM s3;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: char_length(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select char_length with non pushdown func and explicit constant (result)
--Testcase 1162:
SELECT char_length(str1), pi(), 4.1 FROM s3;
 char_length |        pi         | ?column? 
-------------+-------------------+----------
           9 | 3.141592653589793 |      4.1
           9 | 3.141592653589793 |      4.1
           9 | 3.141592653589793 |      4.1
           9 | 3.141592653589793 |      4.1
           9 | 3.141592653589793 |      4.1
           9 | 3.141592653589793 |      4.1
(6 rows)

-- select char_length with order by (explain)
--Testcase 1163:
EXPLAIN VERBOSE
SELECT value1, char_length(str1) FROM s3 ORDER BY char_length(str1), 1 DESC;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, char_length(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY char_length(`str1`) IS NULL ASC, char_length(`str1`) ASC, `value1` IS NULL DESC, `value1` DESC
(4 rows)

-- select char_length with order by (result)
--Testcase 1164:
SELECT value1, char_length(str1) FROM s3 ORDER BY char_length(str1), 1 DESC;
 value1 | char_length 
--------+-------------
    3.3 |           9
    2.2 |           9
    1.1 |           9
    0.3 |           9
    0.2 |           9
    0.1 |           9
(6 rows)

-- select char_length with group by (explain)
--Testcase 1165:
EXPLAIN VERBOSE
SELECT count(value1), char_length(str1) FROM s3 GROUP BY char_length(str1);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (char_length(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), char_length(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select char_length with group by (result)
--Testcase 1166:
SELECT count(value1), char_length(str1) FROM s3 GROUP BY char_length(str1);
 count | char_length 
-------+-------------
     6 |           9
(1 row)

-- select char_length with group by index (result)
--Testcase 1167:
SELECT value1, char_length(str1) FROM s3 GROUP BY 2,1;
 value1 | char_length 
--------+-------------
    0.1 |           9
    0.2 |           9
    0.3 |           9
    1.1 |           9
    2.2 |           9
    3.3 |           9
(6 rows)

-- select char_length with group by having (explain)
--Testcase 1168:
EXPLAIN VERBOSE
SELECT count(value1), char_length(str1) FROM s3 GROUP BY char_length(str1), str1 HAVING char_length(str1) > 0;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=185 width=44)
   Output: (count(value1)), (char_length(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), char_length(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((char_length(`str1`) > 0)) GROUP BY 2, 3
(5 rows)

-- select char_length with group by having (result)
--Testcase 1169:
SELECT count(value1), char_length(str1) FROM s3 GROUP BY char_length(str1), str1 HAVING char_length(str1) > 0;
 count | char_length 
-------+-------------
     6 |           9
(1 row)

-- select char_length with group by index having (result)
--Testcase 1170:
SELECT value1, char_length(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | char_length 
--------+-------------
    1.1 |           9
    2.2 |           9
    3.3 |           9
(3 rows)

-- ===============================================================================
-- test character_length()
-- ===============================================================================
-- select character_length (stub function, explain)
--Testcase 1171:
EXPLAIN VERBOSE
SELECT character_length(tag1), character_length(str1), character_length(str2) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.57 rows=682 width=12)
   Output: character_length(tag1), character_length(str1), character_length(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select character_length (stub function, result)
--Testcase 1172:
SELECT character_length(tag1), character_length(str1), character_length(str2) FROM s3;
 character_length | character_length | character_length 
------------------+------------------+------------------
                1 |                9 |                9
                1 |                9 |                9
                1 |                9 |                9
                1 |                9 |                9
                1 |                9 |                9
                1 |                9 |                9
(6 rows)

-- select character_length (stub function, not pushdown constraints, explain)
--Testcase 1173:
EXPLAIN VERBOSE
SELECT id, character_length(str1) FROM s3 WHERE to_hex(value2) = '64';
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..130.63 rows=7 width=8)
   Output: id, character_length(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select character_length (stub function, not pushdown constraints, explain)
--Testcase 1174:
SELECT id, character_length(str1) FROM s3 WHERE to_hex(value2) = '64';
 id | character_length 
----+------------------
  0 |                9
  1 |                9
  2 |                9
(3 rows)

-- select character_length (stub function, character_length in constraints, explain)
--Testcase 1175:
EXPLAIN VERBOSE
SELECT id, character_length(str1) FROM s3 WHERE character_length(str1) > 0;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.71 rows=455 width=8)
   Output: id, character_length(str1)
   Local server startup cost: 10
   Remote query: SELECT `id`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((character_length(`str1`) > 0))
(4 rows)

-- select character_length (stub function, character_length in constraints, result)
--Testcase 1176:
SELECT id, character_length(str1) FROM s3 WHERE character_length(str1) > 0;
 id | character_length 
----+------------------
  0 |                9
  1 |                9
  2 |                9
  3 |                9
  4 |                9
  5 |                9
(6 rows)

-- select character_length with non pushdown func and explicit constant (explain)
--Testcase 1177:
EXPLAIN VERBOSE
SELECT character_length(str1), pi(), 4.1 FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: character_length(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select character_length with non pushdown func and explicit constant (result)
--Testcase 1178:
SELECT character_length(str1), pi(), 4.1 FROM s3;
 character_length |        pi         | ?column? 
------------------+-------------------+----------
                9 | 3.141592653589793 |      4.1
                9 | 3.141592653589793 |      4.1
                9 | 3.141592653589793 |      4.1
                9 | 3.141592653589793 |      4.1
                9 | 3.141592653589793 |      4.1
                9 | 3.141592653589793 |      4.1
(6 rows)

-- select character_length with order by (explain)
--Testcase 1179:
EXPLAIN VERBOSE
SELECT value1, character_length(str1) FROM s3 ORDER BY character_length(str1), 1 DESC;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, character_length(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY character_length(`str1`) IS NULL ASC, character_length(`str1`) ASC, `value1` IS NULL DESC, `value1` DESC
(4 rows)

-- select character_length with order by (result)
--Testcase 1180:
SELECT value1, character_length(str1) FROM s3 ORDER BY character_length(str1), 1 DESC;
 value1 | character_length 
--------+------------------
    3.3 |                9
    2.2 |                9
    1.1 |                9
    0.3 |                9
    0.2 |                9
    0.1 |                9
(6 rows)

-- select character_length with group by (explain)
--Testcase 1181:
EXPLAIN VERBOSE
SELECT count(value1), character_length(str1) FROM s3 GROUP BY character_length(str1);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (character_length(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), character_length(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select character_length with group by (result)
--Testcase 1182:
SELECT count(value1), character_length(str1) FROM s3 GROUP BY character_length(str1);
 count | character_length 
-------+------------------
     6 |                9
(1 row)

-- select character_length with group by index (result)
--Testcase 1183:
SELECT value1, character_length(str1) FROM s3 GROUP BY 2,1;
 value1 | character_length 
--------+------------------
    0.1 |                9
    0.2 |                9
    0.3 |                9
    1.1 |                9
    2.2 |                9
    3.3 |                9
(6 rows)

-- select character_length with group by having (explain)
--Testcase 1184:
EXPLAIN VERBOSE
SELECT count(value1), character_length(str1) FROM s3 GROUP BY character_length(str1), str1 HAVING character_length(str1) > 0;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=185 width=44)
   Output: (count(value1)), (character_length(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), character_length(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((character_length(`str1`) > 0)) GROUP BY 2, 3
(5 rows)

-- select character_length with group by having (result)
--Testcase 1185:
SELECT count(value1), character_length(str1) FROM s3 GROUP BY character_length(str1), str1 HAVING character_length(str1) > 0;
 count | character_length 
-------+------------------
     6 |                9
(1 row)

-- select character_length with group by index having (result)
--Testcase 1186:
SELECT value1, character_length(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | character_length 
--------+------------------
    1.1 |                9
    2.2 |                9
    3.3 |                9
(3 rows)

-- ===============================================================================
-- test concat()
-- ===============================================================================
-- select concat (stub function, explain)
--Testcase 1187:
EXPLAIN VERBOSE
SELECT concat(id), concat(tag1), concat(value1), concat(value2), concat(str1) FROM s3;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..143.45 rows=787 width=160)
   Output: concat(id), concat(tag1), concat(value1), concat(value2), concat(str1)
   Local server startup cost: 10
   Remote query: SELECT `id`, `tag1`, `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select concat (stub function, result)
--Testcase 1188:
SELECT concat(id), concat(tag1), concat(value1), concat(value2), concat(str1) FROM s3;
 concat | concat | concat | concat |  concat   
--------+--------+--------+--------+-----------
 0      | a      | 0.1    | 100    | ---XYZ---
 1      | a      | 0.2    | 100    | ---XYZ---
 2      | a      | 0.3    | 100    | ---XYZ---
 3      | b      | 1.1    | 200    | ---XYZ---
 4      | b      | 2.2    | 200    | ---XYZ---
 5      | b      | 3.3    | 200    | ---XYZ---
(6 rows)

-- select concat (stub function, pushdown constraints, explain)
--Testcase 1189:
EXPLAIN VERBOSE
SELECT id, concat(str1, str2) FROM s3 WHERE value2 != 100;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..141.06 rows=886 width=36)
   Output: id, concat(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `id`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 100))
(4 rows)

-- select concat (stub function, pushdown constraints, result)
--Testcase 1190:
SELECT id, concat(str1, str2) FROM s3 WHERE value2 != 100;
 id |       concat       
----+--------------------
  3 | ---XYZ---   XYZ   
  4 | ---XYZ---   XYZ   
  5 | ---XYZ---   XYZ   
(3 rows)

-- select concat (stub function, concat in constraints, explain)
--Testcase 1191:
EXPLAIN VERBOSE
SELECT id, concat(str1, str2) FROM s3 WHERE concat(str1, str2) != 'XYZ';
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..143.28 rows=886 width=36)
   Output: id, concat(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `id`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((concat(`str1`, `str2`) <> 'XYZ'))
(4 rows)

-- select concat (stub function, concat in constraints, explain)
--Testcase 1192:
SELECT id, concat(str1, str2) FROM s3 WHERE concat(str1, str2) != 'XYZ';
 id |       concat       
----+--------------------
  0 | ---XYZ---   XYZ   
  1 | ---XYZ---   XYZ   
  2 | ---XYZ---   XYZ   
  3 | ---XYZ---   XYZ   
  4 | ---XYZ---   XYZ   
  5 | ---XYZ---   XYZ   
(6 rows)

-- select concat as nest function with agg (pushdown, explain)
--Testcase 1193:
EXPLAIN VERBOSE
SELECT id, concat(sum(value1), str1) FROM s3 GROUP BY id, str1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=68)
   Output: id, (concat(sum(value1), str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `id`, concat(sum(`value1`), `str1`), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 3
(5 rows)

-- select concat as nest function with agg (pushdown, result)
--Testcase 1194:
SELECT id, concat(sum(value1), str1) FROM s3 GROUP BY id, str1;
 id |            concat            
----+------------------------------
  0 | 0.10000000149011612---XYZ---
  1 | 0.20000000298023224---XYZ---
  2 | 0.30000001192092896---XYZ---
  3 | 1.100000023841858---XYZ---
  4 | 2.200000047683716---XYZ---
  5 | 3.299999952316284---XYZ---
(6 rows)

-- select concat with non pushdown func and explicit constant (explain)
--Testcase 1195:
EXPLAIN VERBOSE
SELECT concat(str1, str2), pi(), 4.1 FROM s3;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=72)
   Output: concat(str1, str2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select concat with non pushdown func and explicit constant (result)
--Testcase 1196:
SELECT concat(str1, str2), pi(), 4.1 FROM s3;
       concat       |        pi         | ?column? 
--------------------+-------------------+----------
 ---XYZ---   XYZ    | 3.141592653589793 |      4.1
 ---XYZ---   XYZ    | 3.141592653589793 |      4.1
 ---XYZ---   XYZ    | 3.141592653589793 |      4.1
 ---XYZ---   XYZ    | 3.141592653589793 |      4.1
 ---XYZ---   XYZ    | 3.141592653589793 |      4.1
 ---XYZ---   XYZ    | 3.141592653589793 |      4.1
(6 rows)

-- select concat with order by (explain)
--Testcase 1197:
EXPLAIN VERBOSE
SELECT value1, concat(value2, str2) FROM s3 ORDER BY concat(value2, str2);
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, concat(value2, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY concat(`value2`, `str2`) IS NULL ASC, concat(`value2`, `str2`) ASC
(4 rows)

-- select concat with order by (result)
--Testcase 1198:
SELECT value1, concat(value2, str2) FROM s3 ORDER BY concat(value2, str2);
 value1 |    concat    
--------+--------------
    0.1 | 100   XYZ   
    0.2 | 100   XYZ   
    0.3 | 100   XYZ   
    1.1 | 200   XYZ   
    2.2 | 200   XYZ   
    3.3 | 200   XYZ   
(6 rows)

-- select concat with order by index (result)
--Testcase 1199:
SELECT value1, concat(value2, str2) FROM s3 ORDER BY 2,1;
 value1 |    concat    
--------+--------------
    0.1 | 100   XYZ   
    0.2 | 100   XYZ   
    0.3 | 100   XYZ   
    1.1 | 200   XYZ   
    2.2 | 200   XYZ   
    3.3 | 200   XYZ   
(6 rows)

-- select concat with group by (explain)
--Testcase 1200:
EXPLAIN VERBOSE
SELECT count(value1), concat(str1, str2) FROM s3 GROUP BY concat(str1, str2);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (concat(str1, str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), concat(`str1`, `str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select concat with group by (result)
--Testcase 1201:
SELECT count(value1), concat(str1, str2) FROM s3 GROUP BY concat(str1, str2);
 count |       concat       
-------+--------------------
     6 | ---XYZ---   XYZ   
(1 row)

-- select concat with group by index (result)
--Testcase 1202:
SELECT value1, concat(str1, str2) FROM s3 GROUP BY 2,1;
 value1 |       concat       
--------+--------------------
    0.1 | ---XYZ---   XYZ   
    0.2 | ---XYZ---   XYZ   
    0.3 | ---XYZ---   XYZ   
    1.1 | ---XYZ---   XYZ   
    2.2 | ---XYZ---   XYZ   
    3.3 | ---XYZ---   XYZ   
(6 rows)

-- select concat with group by having (explain)
--Testcase 1203:
EXPLAIN VERBOSE
SELECT count(value1), concat(str1, str2) FROM s3 GROUP BY concat(str1, str2) HAVING concat(str1, str2) IS NOT NULL;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (concat(str1, str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), concat(`str1`, `str2`) FROM `mysql_fdw_regress`.`s3` WHERE ((concat(`str1`, `str2`) IS NOT NULL)) GROUP BY 2
(5 rows)

-- select concat with group by having (explain)
--Testcase 1204:
SELECT count(value1), concat(str1, str2) FROM s3 GROUP BY concat(str1, str2) HAVING concat(str1, str2) IS NOT NULL;
 count |       concat       
-------+--------------------
     6 | ---XYZ---   XYZ   
(1 row)

-- select concat with group by index having (result)
--Testcase 1205:
SELECT value1, concat(str1, str2, value1, value2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |          concat          
--------+--------------------------
    1.1 | ---XYZ---   XYZ   1.1200
    2.2 | ---XYZ---   XYZ   2.2200
    3.3 | ---XYZ---   XYZ   3.3200
(3 rows)

-- ===============================================================================
-- test concat_ws()
-- ===============================================================================
-- select concat_ws (stub function, explain)
--Testcase 1206:
EXPLAIN VERBOSE
SELECT concat_ws(',', str2, str1, tag1, value2) FROM s3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..131.45 rows=660 width=32)
   Output: concat_ws(','::text, str2, str1, tag1, value2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select concat_ws (stub function, explain)
--Testcase 1207:
SELECT concat_ws(',', str2, str1, tag1, value2) FROM s3;
         concat_ws         
---------------------------
    XYZ   ,---XYZ---,a,100
    XYZ   ,---XYZ---,a,100
    XYZ   ,---XYZ---,a,100
    XYZ   ,---XYZ---,b,200
    XYZ   ,---XYZ---,b,200
    XYZ   ,---XYZ---,b,200
(6 rows)

-- select concat_ws (stub function, not pushdown constraints, explain)
--Testcase 1208:
EXPLAIN VERBOSE
SELECT value1, concat_ws('.', str2, str1) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=40)
   Output: value1, concat_ws('.'::text, str2, str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select concat_ws (stub function, not pushdown constraints, result)
--Testcase 1209:
SELECT value1, concat_ws('.', str2, str1) FROM s3 WHERE to_hex(value2) = '64';
 value1 |      concat_ws      
--------+---------------------
    0.1 |    XYZ   .---XYZ---
    0.2 |    XYZ   .---XYZ---
    0.3 |    XYZ   .---XYZ---
(3 rows)

-- select concat_ws (stub function, pushdown constraints, explain)
--Testcase 1210:
EXPLAIN VERBOSE
SELECT value1, concat_ws('.', str2, str1) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=40)
   Output: value1, concat_ws('.'::text, str2, str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select concat_ws (stub function, pushdown constraints, result)
--Testcase 1211:
SELECT value1, concat_ws('.', str2, str1) FROM s3 WHERE value2 != 200;
 value1 |      concat_ws      
--------+---------------------
    0.1 |    XYZ   .---XYZ---
    0.2 |    XYZ   .---XYZ---
    0.3 |    XYZ   .---XYZ---
(3 rows)

-- select concat_ws with non pushdown func and explicit constant (explain)
--Testcase 1212:
EXPLAIN VERBOSE
SELECT concat_ws('.', str2, str1), pi(), 4.1 FROM s3;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=72)
   Output: concat_ws('.'::text, str2, str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select concat_ws with non pushdown func and explicit constant (result)
--Testcase 1213:
SELECT concat_ws('.', str2, str1), pi(), 4.1 FROM s3;
      concat_ws      |        pi         | ?column? 
---------------------+-------------------+----------
    XYZ   .---XYZ--- | 3.141592653589793 |      4.1
    XYZ   .---XYZ--- | 3.141592653589793 |      4.1
    XYZ   .---XYZ--- | 3.141592653589793 |      4.1
    XYZ   .---XYZ--- | 3.141592653589793 |      4.1
    XYZ   .---XYZ--- | 3.141592653589793 |      4.1
    XYZ   .---XYZ--- | 3.141592653589793 |      4.1
(6 rows)

-- select concat_ws with order by (explain)
--Testcase 1214:
EXPLAIN VERBOSE
SELECT value1, concat_ws('.', str2, str1) FROM s3 ORDER BY concat_ws('.', str2, str1);
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, concat_ws('.'::text, str2, str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY concat_ws('.', `str2`, `str1`) IS NULL ASC, concat_ws('.', `str2`, `str1`) ASC
(4 rows)

-- select concat_ws with order by (result)
--Testcase 1215:
SELECT value1, concat_ws('.', str2, str1) FROM s3 ORDER BY concat_ws('.', str2, str1);
 value1 |      concat_ws      
--------+---------------------
    0.1 |    XYZ   .---XYZ---
    0.2 |    XYZ   .---XYZ---
    0.3 |    XYZ   .---XYZ---
    1.1 |    XYZ   .---XYZ---
    2.2 |    XYZ   .---XYZ---
    3.3 |    XYZ   .---XYZ---
(6 rows)

-- select concat_ws with order by index (result)
--Testcase 1216:
SELECT value1, concat_ws('.', str2, str1) FROM s3 ORDER BY 2,1;
 value1 |      concat_ws      
--------+---------------------
    0.1 |    XYZ   .---XYZ---
    0.2 |    XYZ   .---XYZ---
    0.3 |    XYZ   .---XYZ---
    1.1 |    XYZ   .---XYZ---
    2.2 |    XYZ   .---XYZ---
    3.3 |    XYZ   .---XYZ---
(6 rows)

-- select concat_ws with order by index (result)
--Testcase 1217:
SELECT value1, concat_ws('.', value1, value4) FROM s3 ORDER BY 1,2;
 value1 | concat_ws 
--------+-----------
    0.1 | 0.1.-100
    0.2 | 0.2.-100
    0.3 | 0.3.-100
    1.1 | 1.1.-200
    2.2 | 2.2.-200
    3.3 | 3.3.-200
(6 rows)

-- select concat_ws with group by (explain)
--Testcase 1218:
EXPLAIN VERBOSE
SELECT count(value1), concat_ws('.', str2, str1) FROM s3 GROUP BY concat_ws('.', str2, str1);
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (concat_ws('.'::text, str2, str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), concat_ws('.', `str2`, `str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select concat_ws with group by (result)
--Testcase 1219:
SELECT count(value1), concat_ws('.', str2, str1) FROM s3 GROUP BY concat_ws('.', str2, str1);
 count |      concat_ws      
-------+---------------------
     6 |    XYZ   .---XYZ---
(1 row)

-- select concat_ws with group by index (result)
--Testcase 1220:
SELECT value1, concat_ws('.', str2, str1) FROM s3 GROUP BY 2,1;
 value1 |      concat_ws      
--------+---------------------
    0.1 |    XYZ   .---XYZ---
    0.2 |    XYZ   .---XYZ---
    0.3 |    XYZ   .---XYZ---
    1.1 |    XYZ   .---XYZ---
    2.2 |    XYZ   .---XYZ---
    3.3 |    XYZ   .---XYZ---
(6 rows)

-- select concat_ws with group by having (explain)
--Testcase 1221:
EXPLAIN VERBOSE
SELECT count(value1), concat_ws('.', str2, str1) FROM s3 GROUP BY concat_ws('.', str2, str1) HAVING concat_ws('.', str2, str1) IS NOT NULL;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (concat_ws('.'::text, str2, str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), concat_ws('.', `str2`, `str1`) FROM `mysql_fdw_regress`.`s3` WHERE ((concat_ws('.', `str2`, `str1`) IS NOT NULL)) GROUP BY 2
(5 rows)

-- select concat_ws with group by having (result)
--Testcase 1222:
SELECT count(value1), concat_ws('.', str2, str1) FROM s3 GROUP BY concat_ws('.', str2, str1) HAVING concat_ws('.', str2, str1) IS NOT NULL;
 count |      concat_ws      
-------+---------------------
     6 |    XYZ   .---XYZ---
(1 row)

-- select concat_ws with group by index having (result)
--Testcase 1223:
SELECT value1, concat_ws('.', str2, str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |      concat_ws      
--------+---------------------
    1.1 |    XYZ   .---XYZ---
    2.2 |    XYZ   .---XYZ---
    3.3 |    XYZ   .---XYZ---
(3 rows)

-- ===============================================================================
-- test elt()
-- ===============================================================================
-- select elt (stub function, explain)
--Testcase 1224:
EXPLAIN VERBOSE
SELECT elt(1, str2, str1, tag1) FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..132.16 rows=682 width=32)
   Output: elt(1, VARIADIC ARRAY[str2, str1, tag1])
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select elt (stub function, result)
--Testcase 1225:
SELECT elt(1, str2, str1, tag1) FROM s3;
ERROR:  stub elt(int, variadic text[]) is called
CONTEXT:  PL/pgSQL function elt(integer,text[]) line 3 at RAISE
-- select elt (stub function, not pushdown constraints, explain)
--Testcase 1226:
EXPLAIN VERBOSE
SELECT value1, elt(1, str2, str1) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=40)
   Output: value1, elt(1, VARIADIC ARRAY[str2, str1])
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select elt (stub function, not pushdown constraints, result)
--Testcase 1227:
SELECT value1, elt(1, str2, str1) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub elt(int, variadic text[]) is called
CONTEXT:  PL/pgSQL function elt(integer,text[]) line 3 at RAISE
-- select elt (stub function, pushdown constraints, explain)
--Testcase 1228:
EXPLAIN VERBOSE
SELECT value1, elt(1, str2, str1) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=40)
   Output: value1, elt(1, VARIADIC ARRAY[str2, str1])
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select elt (stub function, pushdown constraints, result)
--Testcase 1229:
SELECT value1, elt(1, str2, str1) FROM s3 WHERE value2 != 200;
ERROR:  stub elt(int, variadic text[]) is called
CONTEXT:  PL/pgSQL function elt(integer,text[]) line 3 at RAISE
-- select elt with non pushdown func and explicit constant (explain)
--Testcase 1230:
EXPLAIN VERBOSE
SELECT elt(1, str2, str1), pi(), 4.1 FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=72)
   Output: elt(1, VARIADIC ARRAY[str2, str1]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select elt with non pushdown func and explicit constant (result)
--Testcase 1231:
SELECT elt(1, str2, str1), pi(), 4.1 FROM s3;
ERROR:  stub elt(int, variadic text[]) is called
CONTEXT:  PL/pgSQL function elt(integer,text[]) line 3 at RAISE
-- select elt with order by (explain)
--Testcase 1232:
EXPLAIN VERBOSE
SELECT value1, elt(1, str2, str1) FROM s3 ORDER BY elt(1, str2, str1);
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, elt(1, VARIADIC ARRAY[str2, str1])
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY elt(1, `str2`, `str1`) IS NULL ASC, elt(1, `str2`, `str1`) ASC
(4 rows)

-- select elt with order by (result)
--Testcase 1233:
SELECT value1, elt(1, str2, str1) FROM s3 ORDER BY elt(1, str2, str1);
ERROR:  stub elt(int, variadic text[]) is called
CONTEXT:  PL/pgSQL function elt(integer,text[]) line 3 at RAISE
-- select elt with order by index (result)
--Testcase 1234:
SELECT value1, elt(1, str2, str1) FROM s3 ORDER BY 2,1;
ERROR:  stub elt(int, variadic text[]) is called
CONTEXT:  PL/pgSQL function elt(integer,text[]) line 3 at RAISE
-- select elt with order by index (result)
--Testcase 1235:
SELECT value1, elt(1, str2, str1) FROM s3 ORDER BY 1,2;
ERROR:  stub elt(int, variadic text[]) is called
CONTEXT:  PL/pgSQL function elt(integer,text[]) line 3 at RAISE
-- select elt with group by (explain)
--Testcase 1236:
EXPLAIN VERBOSE
SELECT count(value1), elt(1, str2, str1) FROM s3 GROUP BY elt(1, str2, str1);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (elt(1, VARIADIC ARRAY[str2, str1]))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), elt(1, `str2`, `str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select elt with group by (result)
--Testcase 1237:
SELECT count(value1), elt(1, str2, str1) FROM s3 GROUP BY elt(1, str2, str1);
 count |    elt    
-------+-----------
     6 |    XYZ   
(1 row)

-- select elt with group by index (result)
--Testcase 1238:
SELECT value1, elt(1, str2, str1) FROM s3 GROUP BY 2,1;
 value1 |    elt    
--------+-----------
    0.1 |    XYZ   
    0.2 |    XYZ   
    0.3 |    XYZ   
    1.1 |    XYZ   
    2.2 |    XYZ   
    3.3 |    XYZ   
(6 rows)

-- select elt with group by having (explain)
--Testcase 1239:
EXPLAIN VERBOSE
SELECT count(value1), elt(1, str2, str1) FROM s3 GROUP BY elt(1, str2, str1), str1, str2 HAVING elt(1, str2, str1) IS NOT NULL;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=104)
   Output: (count(value1)), (elt(1, VARIADIC ARRAY[str2, str1])), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), elt(1, `str2`, `str1`), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((elt(1, `str2`, `str1`) IS NOT NULL))
(5 rows)

-- select elt with group by having (result)
--Testcase 1240:
SELECT count(value1), elt(1, str2, str1) FROM s3 GROUP BY elt(1, str2, str1), str1, str2 HAVING elt(1, str2, str1) IS NOT NULL;
 count |    elt    
-------+-----------
     6 |    XYZ   
(1 row)

-- select elt with group by index having (result)
--Testcase 1241:
SELECT value1, elt(1, str2, str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |    elt    
--------+-----------
    1.1 |    XYZ   
    2.2 |    XYZ   
    3.3 |    XYZ   
(3 rows)

-- ===============================================================================
-- test export_set()
-- ===============================================================================
-- select export_set (stub function, explain)
--Testcase 1242:
EXPLAIN VERBOSE
SELECT export_set(5, str2, str1) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=32)
   Output: export_set(5, str2, str1)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select export_set (stub function, result)
--Testcase 1243:
SELECT export_set(5, str2, str1) FROM s3;
ERROR:  stub export_set(int, text, text) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text) line 3 at RAISE
--Testcase 1244:
EXPLAIN VERBOSE
SELECT export_set(5, str2, str1, ',') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=32)
   Output: export_set(5, str2, str1, ','::text)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select export_set (stub function, result)
--Testcase 1245:
SELECT export_set(5, str2, str1, ',') FROM s3;
ERROR:  stub export_set(int, text, text, text) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text,text) line 3 at RAISE
-- select export_set (stub function, explain)
--Testcase 1246:
EXPLAIN VERBOSE
SELECT export_set(5, str2, str1, ',', 2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=32)
   Output: export_set(5, str2, str1, ','::text, 2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select export_set (stub function, result)
--Testcase 1247:
SELECT export_set(5, str2, str1, ',', 2) FROM s3;
ERROR:  stub export_set(int, text, text, text, int) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text,text,integer) line 3 at RAISE
-- select export_set (stub function, not pushdown constraints, explain)
--Testcase 1248:
EXPLAIN VERBOSE
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=40)
   Output: value1, export_set(5, str2, str1, ','::text, 2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select export_set (stub function, not pushdown constraints, result)
--Testcase 1249:
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub export_set(int, text, text, text, int) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text,text,integer) line 3 at RAISE
-- select export_set (stub function, pushdown constraints, explain)
--Testcase 1250:
EXPLAIN VERBOSE
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=40)
   Output: value1, export_set(5, str2, str1, ','::text, 2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select export_set (stub function, pushdown constraints, result)
--Testcase 1251:
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 WHERE value2 != 200;
ERROR:  stub export_set(int, text, text, text, int) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text,text,integer) line 3 at RAISE
-- select export_set with non pushdown func and explicit constant (explain)
--Testcase 1252:
EXPLAIN VERBOSE
SELECT export_set(5, str2, str1, ',', 2), pi(), 4.1 FROM s3;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=72)
   Output: export_set(5, str2, str1, ','::text, 2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select export_set with non pushdown func and explicit constant (result)
--Testcase 1253:
SELECT export_set(5, str2, str1, ',', 2), pi(), 4.1 FROM s3;
ERROR:  stub export_set(int, text, text, text, int) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text,text,integer) line 3 at RAISE
-- select export_set with order by (explain)
--Testcase 1254:
EXPLAIN VERBOSE
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 ORDER BY export_set(5, str2, str1, ',', 2);
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, export_set(5, str2, str1, ','::text, 2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY export_set(5, `str2`, `str1`, ',', 2) IS NULL ASC, export_set(5, `str2`, `str1`, ',', 2) ASC
(4 rows)

-- select export_set with order by (result)
--Testcase 1255:
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 ORDER BY export_set(5, str2, str1, ',', 2);
ERROR:  stub export_set(int, text, text, text, int) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text,text,integer) line 3 at RAISE
-- select export_set with order by index (result)
--Testcase 1256:
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 ORDER BY 2,1;
ERROR:  stub export_set(int, text, text, text, int) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text,text,integer) line 3 at RAISE
-- select export_set with order by index (result)
--Testcase 1257:
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 ORDER BY 1,2;
ERROR:  stub export_set(int, text, text, text, int) is called
CONTEXT:  PL/pgSQL function export_set(integer,text,text,text,integer) line 3 at RAISE
-- select export_set with group by (explain)
--Testcase 1258:
EXPLAIN VERBOSE
SELECT count(value1), export_set(5, str2, str1, ',', 2) FROM s3 GROUP BY export_set(5, str2, str1, ',', 2);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (export_set(5, str2, str1, ','::text, 2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), export_set(5, `str2`, `str1`, ',', 2) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select export_set with group by (result)
--Testcase 1259:
SELECT count(value1), export_set(5, str2, str1, ',', 2) FROM s3 GROUP BY export_set(5, str2, str1, ',', 2);
 count |     export_set      
-------+---------------------
     6 |    XYZ   ,---XYZ---
(1 row)

-- select export_set with group by index (result)
--Testcase 1260:
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 GROUP BY 2,1;
 value1 |     export_set      
--------+---------------------
    0.1 |    XYZ   ,---XYZ---
    0.2 |    XYZ   ,---XYZ---
    0.3 |    XYZ   ,---XYZ---
    1.1 |    XYZ   ,---XYZ---
    2.2 |    XYZ   ,---XYZ---
    3.3 |    XYZ   ,---XYZ---
(6 rows)

-- select export_set with group by having (explain)
--Testcase 1261:
EXPLAIN VERBOSE
SELECT count(value1), export_set(5, str2, str1, ',', 2) FROM s3 GROUP BY export_set(5, str2, str1, ',', 2), str1, str2 HAVING export_set(5, str2, str1, ',', 2) IS NOT NULL;
                                                                                                QUERY PLAN                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=104)
   Output: (count(value1)), (export_set(5, str2, str1, ','::text, 2)), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), export_set(5, `str2`, `str1`, ',', 2), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((export_set(5, `str2`, `str1`, ',', 2) IS NOT NULL))
(5 rows)

-- select export_set with group by having (result)
--Testcase 1262:
SELECT count(value1), export_set(5, str2, str1, ',', 2) FROM s3 GROUP BY export_set(5, str2, str1, ',', 2), str1, str2 HAVING export_set(5, str2, str1, ',', 2) IS NOT NULL;
 count |     export_set      
-------+---------------------
     6 |    XYZ   ,---XYZ---
(1 row)

-- select export_set with group by index having (result)
--Testcase 1263:
SELECT value1, export_set(5, str2, str1, ',', 2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |     export_set      
--------+---------------------
    1.1 |    XYZ   ,---XYZ---
    2.2 |    XYZ   ,---XYZ---
    3.3 |    XYZ   ,---XYZ---
(3 rows)

-- ===============================================================================
-- test field()
-- ===============================================================================
-- select field (stub function, explain)
--Testcase 1264:
EXPLAIN VERBOSE
SELECT field('---XYZ---', str2, str1) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=4)
   Output: field('---XYZ---'::text, VARIADIC ARRAY[str2, str1])
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select field (stub function, result)
--Testcase 1265:
SELECT field('---XYZ---', str2, str1) FROM s3;
ERROR:  stub field(text, variadic text[]) is called
CONTEXT:  PL/pgSQL function field(text,text[]) line 3 at RAISE
-- select field (stub function, not pushdown constraints, explain)
--Testcase 1266:
EXPLAIN VERBOSE
SELECT value1, field('---XYZ---', str2, str1) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=12)
   Output: value1, field('---XYZ---'::text, VARIADIC ARRAY[str2, str1])
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select field (stub function, not pushdown constraints, result)
--Testcase 1267:
SELECT value1, field('---XYZ---', str2, str1) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub field(text, variadic text[]) is called
CONTEXT:  PL/pgSQL function field(text,text[]) line 3 at RAISE
-- select field (stub function, pushdown constraints, explain)
--Testcase 1268:
EXPLAIN VERBOSE
SELECT value1, field('---XYZ---', str2, str1) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=12)
   Output: value1, field('---XYZ---'::text, VARIADIC ARRAY[str2, str1])
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select field (stub function, pushdown constraints, result)
--Testcase 1269:
SELECT value1, field('---XYZ---', str2, str1) FROM s3 WHERE value2 != 200;
ERROR:  stub field(text, variadic text[]) is called
CONTEXT:  PL/pgSQL function field(text,text[]) line 3 at RAISE
-- select field with non pushdown func and explicit constant (explain)
--Testcase 1270:
EXPLAIN VERBOSE
SELECT field('---XYZ---', str2, str1), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=44)
   Output: field('---XYZ---'::text, VARIADIC ARRAY[str2, str1]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select field with non pushdown func and explicit constant (result)
--Testcase 1271:
SELECT field('---XYZ---', str2, str1), pi(), 4.1 FROM s3;
ERROR:  stub field(text, variadic text[]) is called
CONTEXT:  PL/pgSQL function field(text,text[]) line 3 at RAISE
-- select field with order by (explain)
--Testcase 1272:
EXPLAIN VERBOSE
SELECT value1, field('---XYZ---', str2, str1) FROM s3 ORDER BY field('---XYZ---', str2, str1);
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, field('---XYZ---'::text, VARIADIC ARRAY[str2, str1])
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY field('---XYZ---', `str2`, `str1`) IS NULL ASC, field('---XYZ---', `str2`, `str1`) ASC
(4 rows)

-- select field with order by (result)
--Testcase 1273:
SELECT value1, field('---XYZ---', str2, str1) FROM s3 ORDER BY field('---XYZ---', str2, str1);
ERROR:  stub field(text, variadic text[]) is called
CONTEXT:  PL/pgSQL function field(text,text[]) line 3 at RAISE
-- select field with order by index (result)
--Testcase 1274:
SELECT value1, field('---XYZ---', str2, str1) FROM s3 ORDER BY 2,1;
ERROR:  stub field(text, variadic text[]) is called
CONTEXT:  PL/pgSQL function field(text,text[]) line 3 at RAISE
-- select field with order by index (result)
--Testcase 1275:
SELECT value1, field('---XYZ---', str2, str1) FROM s3 ORDER BY 1,2;
ERROR:  stub field(text, variadic text[]) is called
CONTEXT:  PL/pgSQL function field(text,text[]) line 3 at RAISE
-- select field with group by (explain)
--Testcase 1276:
EXPLAIN VERBOSE
SELECT count(value1), field('---XYZ---', str2, str1) FROM s3 GROUP BY field('---XYZ---', str2, str1);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (field('---XYZ---'::text, VARIADIC ARRAY[str2, str1]))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), field('---XYZ---', `str2`, `str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select field with group by (result)
--Testcase 1277:
SELECT count(value1), field('---XYZ---', str2, str1) FROM s3 GROUP BY field('---XYZ---', str2, str1);
 count | field 
-------+-------
     6 |     2
(1 row)

-- select field with group by index (result)
--Testcase 1278:
SELECT value1, field('---XYZ---', str2, str1) FROM s3 GROUP BY 2,1;
 value1 | field 
--------+-------
    0.1 |     2
    0.2 |     2
    0.3 |     2
    1.1 |     2
    2.2 |     2
    3.3 |     2
(6 rows)

-- select field with group by having (explain)
--Testcase 1279:
EXPLAIN VERBOSE
SELECT count(value1), field('---XYZ---', str2, str1) FROM s3 GROUP BY field('---XYZ---', str2, str1), str1, str2 HAVING field('---XYZ---', str2, str1) > 0;
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=76)
   Output: (count(value1)), (field('---XYZ---'::text, VARIADIC ARRAY[str2, str1])), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), field('---XYZ---', `str2`, `str1`), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((field('---XYZ---', `str2`, `str1`) > 0))
(5 rows)

-- select field with group by having (result)
--Testcase 1280:
SELECT count(value1), field('---XYZ---', str2, str1) FROM s3 GROUP BY field('---XYZ---', str2, str1), str1, str2 HAVING field('---XYZ---', str2, str1) > 0;
 count | field 
-------+-------
     6 |     2
(1 row)

-- select field with group by index having (result)
--Testcase 1281:
SELECT value1, field('---XYZ---', str2, str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | field 
--------+-------
    1.1 |     2
    2.2 |     2
    3.3 |     2
(3 rows)

-- ===============================================================================
-- test find_in_set()
-- ===============================================================================
-- select find_in_set (stub function, explain)
--Testcase 1282:
EXPLAIN VERBOSE
SELECT find_in_set('---XYZ---', str1) FROM s3;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=4)
   Output: find_in_set('---XYZ---'::text, str1)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select find_in_set (stub function, result)
--Testcase 1283:
SELECT find_in_set('---XYZ---', str1) FROM s3;
ERROR:  stub find_in_set(text, text) is called
CONTEXT:  PL/pgSQL function find_in_set(text,text) line 3 at RAISE
-- select find_in_set (stub function, not pushdown constraints, explain)
--Testcase 1284:
EXPLAIN VERBOSE
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=12)
   Output: value1, find_in_set('---XYZ---'::text, str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select find_in_set (stub function, not pushdown constraints, result)
--Testcase 1285:
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub find_in_set(text, text) is called
CONTEXT:  PL/pgSQL function find_in_set(text,text) line 3 at RAISE
-- select find_in_set (stub function, pushdown constraints, explain)
--Testcase 1286:
EXPLAIN VERBOSE
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=12)
   Output: value1, find_in_set('---XYZ---'::text, str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select find_in_set (stub function, pushdown constraints, result)
--Testcase 1287:
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 WHERE value2 != 200;
ERROR:  stub find_in_set(text, text) is called
CONTEXT:  PL/pgSQL function find_in_set(text,text) line 3 at RAISE
-- select find_in_set with non pushdown func and explicit constant (explain)
--Testcase 1288:
EXPLAIN VERBOSE
SELECT find_in_set('---XYZ---', str1), pi(), 4.1 FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: find_in_set('---XYZ---'::text, str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select find_in_set with non pushdown func and explicit constant (result)
--Testcase 1289:
SELECT find_in_set('---XYZ---', str1), pi(), 4.1 FROM s3;
ERROR:  stub find_in_set(text, text) is called
CONTEXT:  PL/pgSQL function find_in_set(text,text) line 3 at RAISE
-- select find_in_set with order by (explain)
--Testcase 1290:
EXPLAIN VERBOSE
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 ORDER BY find_in_set('---XYZ---', str1);
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, find_in_set('---XYZ---'::text, str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY find_in_set('---XYZ---', `str1`) IS NULL ASC, find_in_set('---XYZ---', `str1`) ASC
(4 rows)

-- select find_in_set with order by (result)
--Testcase 1291:
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 ORDER BY find_in_set('---XYZ---', str1);
ERROR:  stub find_in_set(text, text) is called
CONTEXT:  PL/pgSQL function find_in_set(text,text) line 3 at RAISE
-- select find_in_set with order by index (result)
--Testcase 1292:
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 ORDER BY 2,1;
ERROR:  stub find_in_set(text, text) is called
CONTEXT:  PL/pgSQL function find_in_set(text,text) line 3 at RAISE
-- select find_in_set with order by index (result)
--Testcase 1293:
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 ORDER BY 1,2;
ERROR:  stub find_in_set(text, text) is called
CONTEXT:  PL/pgSQL function find_in_set(text,text) line 3 at RAISE
-- select find_in_set with group by (explain)
--Testcase 1294:
EXPLAIN VERBOSE
SELECT count(value1), find_in_set('---XYZ---', str1) FROM s3 GROUP BY find_in_set('---XYZ---', str1);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (find_in_set('---XYZ---'::text, str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), find_in_set('---XYZ---', `str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select find_in_set with group by (result)
--Testcase 1295:
SELECT count(value1), find_in_set('---XYZ---', str1) FROM s3 GROUP BY find_in_set('---XYZ---', str1);
 count | find_in_set 
-------+-------------
     6 |           1
(1 row)

-- select find_in_set with group by index (result)
--Testcase 1296:
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 GROUP BY 2,1;
 value1 | find_in_set 
--------+-------------
    0.1 |           1
    0.2 |           1
    0.3 |           1
    1.1 |           1
    2.2 |           1
    3.3 |           1
(6 rows)

-- select find_in_set with group by having (explain)
--Testcase 1297:
EXPLAIN VERBOSE
SELECT count(value1), find_in_set('---XYZ---', str1) FROM s3 GROUP BY find_in_set('---XYZ---', str1), str1, str2 HAVING count(find_in_set('---XYZ---', str1)) IS NOT NULL;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=76)
   Output: (count(value1)), (find_in_set('---XYZ---'::text, str1)), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), find_in_set('---XYZ---', `str1`), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((count(find_in_set('---XYZ---', `str1`)) IS NOT NULL))
(5 rows)

-- select find_in_set with group by having (result)
--Testcase 1298:
SELECT count(value1), find_in_set('---XYZ---', str1) FROM s3 GROUP BY find_in_set('---XYZ---', str1), str1, str2 HAVING count(find_in_set('---XYZ---', str1)) IS NOT NULL;
 count | find_in_set 
-------+-------------
     6 |           1
(1 row)

-- select find_in_set with group by index having (result)
--Testcase 1299:
SELECT value1, find_in_set('---XYZ---', str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | find_in_set 
--------+-------------
    1.1 |           1
    2.2 |           1
    3.3 |           1
(3 rows)

-- ===============================================================================
-- test format() of MySQL
-- ===============================================================================
-- select mysql_format (stub function, explain)
--Testcase 1300:
EXPLAIN VERBOSE
SELECT mysql_format(value1, 4), mysql_format(value2, 4), mysql_format(value4, 4) FROM s3;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..197.04 rows=2048 width=96)
   Output: mysql_format(value1, 4), mysql_format((value2)::double precision, 4), mysql_format((value4)::double precision, 4)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_format (stub function, result)
--Testcase 1301:
SELECT mysql_format(value1, 4), mysql_format(value2, 4), mysql_format(value4, 4) FROM s3;
ERROR:  stub mysql_format(double precision, int) is called
CONTEXT:  PL/pgSQL function mysql_format(double precision,integer) line 3 at RAISE
-- select mysql_format (stub function, explain)
--Testcase 1302:
EXPLAIN VERBOSE
SELECT mysql_format(value1, 4, 'de_DE'), mysql_format(value2, 4, 'de_DE'), mysql_format(value4, 4, 'de_DE') FROM s3;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..197.04 rows=2048 width=96)
   Output: mysql_format(value1, 4, 'de_DE'::text), mysql_format((value2)::double precision, 4, 'de_DE'::text), mysql_format((value4)::double precision, 4, 'de_DE'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_format (stub function, result)
--Testcase 1303:
SELECT mysql_format(value1, 4, 'de_DE'), mysql_format(value2, 4, 'de_DE'), mysql_format(value4, 4, 'de_DE') FROM s3;
ERROR:  stub mysql_format(double precision, int, text) is called
CONTEXT:  PL/pgSQL function mysql_format(double precision,integer,text) line 3 at RAISE
-- select mysql_format (stub function, not pushdown constraints, explain)
--Testcase 1304:
EXPLAIN VERBOSE
SELECT value1, mysql_format(value1, 4) FROM s3 WHERE to_hex(value2) = '64';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..148.69 rows=13 width=40)
   Output: value1, mysql_format(value1, 4)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select mysql_format (stub function, not pushdown constraints, result)
--Testcase 1305:
SELECT value1, mysql_format(value1, 4) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub mysql_format(double precision, int) is called
CONTEXT:  PL/pgSQL function mysql_format(double precision,integer) line 3 at RAISE
-- select mysql_format (stub function, pushdown constraints, explain)
--Testcase 1306:
EXPLAIN VERBOSE
SELECT value1, mysql_format(value1, 4) FROM s3 WHERE value2 != 200;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..199.31 rows=2547 width=40)
   Output: value1, mysql_format(value1, 4)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select mysql_format (stub function, pushdown constraints, result)
--Testcase 1307:
SELECT value1, mysql_format(value1, 4) FROM s3 WHERE value2 != 200;
ERROR:  stub mysql_format(double precision, int) is called
CONTEXT:  PL/pgSQL function mysql_format(double precision,integer) line 3 at RAISE
-- select mysql_format with non pushdown func and explicit constant (explain)
--Testcase 1308:
EXPLAIN VERBOSE
SELECT mysql_format(value1, 4), pi(), 4.1 FROM s3;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..193.20 rows=2560 width=72)
   Output: mysql_format(value1, 4), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_format with non pushdown func and explicit constant (result)
--Testcase 1309:
SELECT mysql_format(value1, 4), pi(), 4.1 FROM s3;
ERROR:  stub mysql_format(double precision, int) is called
CONTEXT:  PL/pgSQL function mysql_format(double precision,integer) line 3 at RAISE
-- select mysql_format with order by (explain)
--Testcase 1310:
EXPLAIN VERBOSE
SELECT value1, mysql_format(value1, 4) FROM s3 ORDER BY mysql_format(value1, 4);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, mysql_format(value1, 4)
   Local server startup cost: 10
   Remote query: SELECT `value1` FROM `mysql_fdw_regress`.`s3` ORDER BY format(`value1`, 4) IS NULL ASC, format(`value1`, 4) ASC
(4 rows)

-- select mysql_format with order by (result)
--Testcase 1311:
SELECT value1, mysql_format(value1, 4) FROM s3 ORDER BY mysql_format(value1, 4);
ERROR:  stub mysql_format(double precision, int) is called
CONTEXT:  PL/pgSQL function mysql_format(double precision,integer) line 3 at RAISE
-- select mysql_format with order by index (result)
--Testcase 1312:
SELECT value1, mysql_format(value1, 4) FROM s3 ORDER BY 2,1;
ERROR:  stub mysql_format(double precision, int) is called
CONTEXT:  PL/pgSQL function mysql_format(double precision,integer) line 3 at RAISE
-- select mysql_format with order by index (result)
--Testcase 1313:
SELECT value1, mysql_format(value1, 4) FROM s3 ORDER BY 1,2;
ERROR:  stub mysql_format(double precision, int) is called
CONTEXT:  PL/pgSQL function mysql_format(double precision,integer) line 3 at RAISE
-- select mysql_format with group by (explain)
--Testcase 1314:
EXPLAIN VERBOSE
SELECT count(value1), mysql_format(value1, 4) FROM s3 GROUP BY mysql_format(value1, 4);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (mysql_format(value1, 4))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), format(`value1`, 4) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select mysql_format with group by (result)
--Testcase 1315:
SELECT count(value1), mysql_format(value1, 4) FROM s3 GROUP BY mysql_format(value1, 4);
 count | mysql_format 
-------+--------------
     1 | 0.1000
     1 | 0.2000
     1 | 0.3000
     1 | 1.1000
     1 | 2.2000
     1 | 3.3000
(6 rows)

-- select mysql_format with group by index (result)
--Testcase 1316:
SELECT value1, mysql_format(value1, 4) FROM s3 GROUP BY 2,1;
 value1 | mysql_format 
--------+--------------
    0.1 | 0.1000
    0.2 | 0.2000
    0.3 | 0.3000
    1.1 | 1.1000
    2.2 | 2.2000
    3.3 | 3.3000
(6 rows)

-- select mysql_format with group by having (explain)
--Testcase 1317:
EXPLAIN VERBOSE
SELECT count(value1), mysql_format(value1, 4) FROM s3 GROUP BY mysql_format(value1, 4), value1 HAVING mysql_format(value1, 4) IS NOT NULL;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=48)
   Output: (count(value1)), (mysql_format(value1, 4)), value1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), format(`value1`, 4), `value1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((format(`value1`, 4) IS NOT NULL))
(5 rows)

-- select mysql_format with group by having (result)
--Testcase 1318:
SELECT count(value1), mysql_format(value1, 4) FROM s3 GROUP BY mysql_format(value1, 4), value1 HAVING mysql_format(value1, 4) IS NOT NULL;
 count | mysql_format 
-------+--------------
     1 | 0.1000
     1 | 0.2000
     1 | 0.3000
     1 | 1.1000
     1 | 2.2000
     1 | 3.3000
(6 rows)

-- select mysql_format with group by index having (result)
--Testcase 1319:
SELECT value1, mysql_format(value1, 4) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | mysql_format 
--------+--------------
    1.1 | 1.1000
    2.2 | 2.2000
    3.3 | 3.3000
(3 rows)

-- ===============================================================================
-- test from_base64()
-- ===============================================================================
-- select from_base64 (stub function, explain)
--Testcase 1320:
EXPLAIN VERBOSE
SELECT from_base64(tag1), from_base64(str1), from_base64(str2) FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.57 rows=682 width=96)
   Output: from_base64(tag1), from_base64(str1), from_base64(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select from_base64 (stub function, result)
--Testcase 1321:
SELECT from_base64(tag1), from_base64(str1), from_base64(str2) FROM s3;
ERROR:  stub from_base64(text) is called
CONTEXT:  PL/pgSQL function from_base64(text) line 3 at RAISE
-- select from_base64 (stub function, explain)
--Testcase 1322:
EXPLAIN VERBOSE
SELECT from_base64(to_base64(tag1)), from_base64(to_base64(str1)), from_base64(to_base64(str2)) FROM s3;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.69 rows=682 width=96)
   Output: from_base64(to_base64(tag1)), from_base64(to_base64(str1)), from_base64(to_base64(str2))
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select from_base64 (stub function, result)
--Testcase 1323:
SELECT from_base64(to_base64(tag1)), from_base64(to_base64(str1)), from_base64(to_base64(str2)) FROM s3;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select from_base64 (stub function, not pushdown constraints, explain)
--Testcase 1324:
EXPLAIN VERBOSE
SELECT value1, from_base64(to_base64(str1)) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.35 rows=6 width=40)
   Output: value1, from_base64(to_base64(str1))
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select from_base64 (stub function, not pushdown constraints, result)
--Testcase 1325:
SELECT value1, from_base64(to_base64(str1)) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select from_base64 (stub function, pushdown constraints, explain)
--Testcase 1326:
EXPLAIN VERBOSE
SELECT value1, from_base64(to_base64(str1)) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.85 rows=1274 width=40)
   Output: value1, from_base64(to_base64(str1))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select from_base64 (stub function, pushdown constraints, result)
--Testcase 1327:
SELECT value1, from_base64(to_base64(str1)) FROM s3 WHERE value2 != 200;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select from_base64 with non pushdown func and explicit constant (explain)
--Testcase 1328:
EXPLAIN VERBOSE
SELECT from_base64(to_base64(str1)), pi(), 4.1 FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..161.17 rows=1462 width=72)
   Output: from_base64(to_base64(str1)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select from_base64 with non pushdown func and explicit constant (result)
--Testcase 1329:
SELECT from_base64(to_base64(str1)), pi(), 4.1 FROM s3;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select from_base64 with order by (explain)
--Testcase 1330:
EXPLAIN VERBOSE
SELECT value1, from_base64(to_base64(str1)) FROM s3 ORDER BY from_base64(to_base64(str1));
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=40)
   Output: value1, from_base64(to_base64(str1))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY from_base64(to_base64(`str1`)) IS NULL ASC, from_base64(to_base64(`str1`)) ASC
(4 rows)

-- select from_base64 with order by (result)
--Testcase 1331:
SELECT value1, from_base64(to_base64(str1)) FROM s3 ORDER BY from_base64(to_base64(str1));
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select from_base64 with order by index (result)
--Testcase 1332:
SELECT value1, from_base64(to_base64(str1)) FROM s3 ORDER BY 2,1;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select from_base64 with order by index (result)
--Testcase 1333:
SELECT value1, from_base64(to_base64(str1)) FROM s3 ORDER BY 1,2;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select from_base64 with group by (explain)
--Testcase 1334:
EXPLAIN VERBOSE
SELECT count(value1), from_base64(to_base64(str1)) FROM s3 GROUP BY from_base64(to_base64(str1));
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (from_base64(to_base64(str1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), from_base64(to_base64(`str1`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select from_base64 with group by (result)
--Testcase 1335:
SELECT count(value1), from_base64(to_base64(str1)) FROM s3 GROUP BY from_base64(to_base64(str1));
 count | from_base64 
-------+-------------
     6 | ---XYZ---
(1 row)

-- select from_base64 with group by index (result)
--Testcase 1336:
SELECT value1, from_base64(to_base64(str1)) FROM s3 GROUP BY 2,1;
 value1 | from_base64 
--------+-------------
    0.1 | ---XYZ---
    0.2 | ---XYZ---
    0.3 | ---XYZ---
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(6 rows)

-- select from_base64 with group by having (explain)
--Testcase 1337:
EXPLAIN VERBOSE
SELECT count(value1), from_base64(to_base64(str1)) FROM s3 GROUP BY from_base64(to_base64(str1)), str1 HAVING from_base64(to_base64(str1)) IS NOT NULL;
                                                                                    QUERY PLAN                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (from_base64(to_base64(str1))), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), from_base64(to_base64(`str1`)), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((from_base64(to_base64(`str1`)) IS NOT NULL))
(5 rows)

-- select from_base64 with group by having (result)
--Testcase 1338:
SELECT count(value1), from_base64(to_base64(str1)) FROM s3 GROUP BY from_base64(to_base64(str1)), str1 HAVING from_base64(to_base64(str1)) IS NOT NULL;
 count | from_base64 
-------+-------------
     6 | ---XYZ---
(1 row)

-- select from_base64 with group by index having (result)
--Testcase 1339:
SELECT value1, from_base64(to_base64(str1)) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | from_base64 
--------+-------------
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(3 rows)

-- ===============================================================================
-- test hex()
-- ===============================================================================
-- select hex (stub function, explain)
--Testcase 1340:
EXPLAIN VERBOSE
SELECT hex(tag1), hex(value2), hex(value4), hex(str1), hex(str2) FROM s3;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.40 rows=640 width=160)
   Output: hex(tag1), hex((value2)::bigint), hex((value4)::bigint), hex(str1), hex(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `value2`, `value4`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select hex (stub function, result)
--Testcase 1341:
SELECT hex(tag1), hex(value2), hex(value4), hex(str1), hex(str2) FROM s3;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select hex (stub function, not pushdown constraints, explain)
--Testcase 1342:
EXPLAIN VERBOSE
SELECT value1, hex(str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, hex(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select hex (stub function, not pushdown constraints, result)
--Testcase 1343:
SELECT value1, hex(str1) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select hex (stub function, pushdown constraints, explain)
--Testcase 1344:
EXPLAIN VERBOSE
SELECT value1, hex(str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, hex(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select hex (stub function, pushdown constraints, result)
--Testcase 1345:
SELECT value1, hex(str1) FROM s3 WHERE value2 != 200;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select hex with non pushdown func and explicit constant (explain)
--Testcase 1346:
EXPLAIN VERBOSE
SELECT hex(str1), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: hex(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select hex with non pushdown func and explicit constant (result)
--Testcase 1347:
SELECT hex(str1), pi(), 4.1 FROM s3;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select hex with order by (explain)
--Testcase 1348:
EXPLAIN VERBOSE
SELECT value1, hex(str1) FROM s3 ORDER BY hex(str1);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, hex(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY hex(`str1`) IS NULL ASC, hex(`str1`) ASC
(4 rows)

-- select hex with order by (result)
--Testcase 1349:
SELECT value1, hex(str1) FROM s3 ORDER BY hex(str1);
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select hex with order by index (result)
--Testcase 1350:
SELECT value1, hex(str1) FROM s3 ORDER BY 2,1;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select hex with order by index (result)
--Testcase 1351:
SELECT value1, hex(str1) FROM s3 ORDER BY 1,2;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select hex with group by (explain)
--Testcase 1352:
EXPLAIN VERBOSE
SELECT count(value1), hex(str1) FROM s3 GROUP BY hex(str1);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (hex(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), hex(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select hex with group by (result)
--Testcase 1353:
SELECT count(value1), hex(str1) FROM s3 GROUP BY hex(str1);
 count |        hex         
-------+--------------------
     6 | 2D2D2D58595A2D2D2D
(1 row)

-- select hex with group by index (result)
--Testcase 1354:
SELECT value1, hex(str1) FROM s3 GROUP BY 2,1;
 value1 |        hex         
--------+--------------------
    0.1 | 2D2D2D58595A2D2D2D
    0.2 | 2D2D2D58595A2D2D2D
    0.3 | 2D2D2D58595A2D2D2D
    1.1 | 2D2D2D58595A2D2D2D
    2.2 | 2D2D2D58595A2D2D2D
    3.3 | 2D2D2D58595A2D2D2D
(6 rows)

-- select hex with group by having (explain)
--Testcase 1355:
EXPLAIN VERBOSE
SELECT count(value1), hex(str1) FROM s3 GROUP BY hex(str1), str1 HAVING hex(str1) IS NOT NULL;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (hex(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), hex(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((hex(`str1`) IS NOT NULL))
(5 rows)

-- select hex with group by having (result)
--Testcase 1356:
SELECT count(value1), hex(str1) FROM s3 GROUP BY hex(str1), str1 HAVING hex(str1) IS NOT NULL;
 count |        hex         
-------+--------------------
     6 | 2D2D2D58595A2D2D2D
(1 row)

-- select hex with group by index having (result)
--Testcase 1357:
SELECT value1, hex(value4) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |       hex        
--------+------------------
    1.1 | FFFFFFFFFFFFFF38
    2.2 | FFFFFFFFFFFFFF38
    3.3 | FFFFFFFFFFFFFF38
(3 rows)

-- ===============================================================================
-- test insert()
-- ===============================================================================
-- select insert (stub function, explain)
--Testcase 1358:
EXPLAIN VERBOSE
SELECT insert(str1, 3, 4, str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=32)
   Output: insert(str1, 3, 4, str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select hex (stub function, result)
--Testcase 1359:
SELECT insert(str1, 3, 4, str2) FROM s3;
ERROR:  stub insert(text, int, int, text) is called
CONTEXT:  PL/pgSQL function insert(text,integer,integer,text) line 3 at RAISE
-- select insert (stub function, not pushdown constraints, explain)
--Testcase 1360:
EXPLAIN VERBOSE
SELECT value1, insert(str1, 3, 4, str2) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=40)
   Output: value1, insert(str1, 3, 4, str2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select insert (stub function, not pushdown constraints, result)
--Testcase 1361:
SELECT value1, insert(str1, 3, 4, str2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub insert(text, int, int, text) is called
CONTEXT:  PL/pgSQL function insert(text,integer,integer,text) line 3 at RAISE
-- select insert (stub function, pushdown constraints, explain)
--Testcase 1362:
EXPLAIN VERBOSE
SELECT value1, insert(str1, 3, 4, str2) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=40)
   Output: value1, insert(str1, 3, 4, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select insert (stub function, pushdown constraints, result)
--Testcase 1363:
SELECT value1, insert(str1, 3, 4, str2) FROM s3 WHERE value2 != 200;
ERROR:  stub insert(text, int, int, text) is called
CONTEXT:  PL/pgSQL function insert(text,integer,integer,text) line 3 at RAISE
-- select insert with non pushdown func and explicit constant (explain)
--Testcase 1364:
EXPLAIN VERBOSE
SELECT insert(str1, 3, 4, str2), pi(), 4.1 FROM s3;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=72)
   Output: insert(str1, 3, 4, str2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select insert with non pushdown func and explicit constant (result)
--Testcase 1365:
SELECT insert(str1, 3, 4, str2), pi(), 4.1 FROM s3;
ERROR:  stub insert(text, int, int, text) is called
CONTEXT:  PL/pgSQL function insert(text,integer,integer,text) line 3 at RAISE
-- select insert with order by (explain)
--Testcase 1366:
EXPLAIN VERBOSE
SELECT value1, insert(str1, 3, 4, str2) FROM s3 ORDER BY insert(str1, 3, 4, str2);
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, insert(str1, 3, 4, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY insert(`str1`, 3, 4, `str2`) IS NULL ASC, insert(`str1`, 3, 4, `str2`) ASC
(4 rows)

-- select insert with order by (result)
--Testcase 1367:
SELECT value1, insert(str1, 3, 4, str2) FROM s3 ORDER BY insert(str1, 3, 4, str2);
ERROR:  stub insert(text, int, int, text) is called
CONTEXT:  PL/pgSQL function insert(text,integer,integer,text) line 3 at RAISE
-- select insert with order by index (result)
--Testcase 1368:
SELECT value1, insert(str1, 3, 4, str2) FROM s3 ORDER BY 2,1;
ERROR:  stub insert(text, int, int, text) is called
CONTEXT:  PL/pgSQL function insert(text,integer,integer,text) line 3 at RAISE
-- select insert with order by index (result)
--Testcase 1369:
SELECT value1, insert(str1, 3, 4, str2) FROM s3 ORDER BY 1,2;
ERROR:  stub insert(text, int, int, text) is called
CONTEXT:  PL/pgSQL function insert(text,integer,integer,text) line 3 at RAISE
-- select insert with group by (explain)
--Testcase 1370:
EXPLAIN VERBOSE
SELECT count(value1), insert(str1, 3, 4, str2) FROM s3 GROUP BY insert(str1, 3, 4, str2);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (insert(str1, 3, 4, str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), insert(`str1`, 3, 4, `str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select insert with group by (result)
--Testcase 1371:
SELECT count(value1), insert(str1, 3, 4, str2) FROM s3 GROUP BY insert(str1, 3, 4, str2);
 count |     insert     
-------+----------------
     6 | --   XYZ   ---
(1 row)

-- select insert with group by index (result)
--Testcase 1372:
SELECT value1, insert(str1, 3, 4, str2) FROM s3 GROUP BY 2,1;
 value1 |     insert     
--------+----------------
    0.1 | --   XYZ   ---
    0.2 | --   XYZ   ---
    0.3 | --   XYZ   ---
    1.1 | --   XYZ   ---
    2.2 | --   XYZ   ---
    3.3 | --   XYZ   ---
(6 rows)

-- select insert with group by having (explain)
--Testcase 1373:
EXPLAIN VERBOSE
SELECT count(value1), insert(str1, 3, 4, str2) FROM s3 GROUP BY insert(str1, 3, 4, str2), str1, str2 HAVING insert(str1, 3, 4, str2) IS NOT NULL;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=104)
   Output: (count(value1)), (insert(str1, 3, 4, str2)), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), insert(`str1`, 3, 4, `str2`), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((insert(`str1`, 3, 4, `str2`) IS NOT NULL))
(5 rows)

-- select insert with group by having (result)
--Testcase 1374:
SELECT count(value1), insert(str1, 3, 4, str2) FROM s3 GROUP BY insert(str1, 3, 4, str2), str1, str2 HAVING insert(str1, 3, 4, str2) IS NOT NULL;
 count |     insert     
-------+----------------
     6 | --   XYZ   ---
(1 row)

-- select insert with group by index having (result)
--Testcase 1375:
SELECT value1, insert(str1, 3, 4, str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |     insert     
--------+----------------
    1.1 | --   XYZ   ---
    2.2 | --   XYZ   ---
    3.3 | --   XYZ   ---
(3 rows)

-- ===============================================================================
-- test instr()
-- ===============================================================================
-- select instr (stub function, explain)
--Testcase 1376:
EXPLAIN VERBOSE
SELECT instr(str1, str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=8)
   Output: instr(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select instr (stub function, result)
--Testcase 1377:
SELECT instr(str1, str2) FROM s3;
ERROR:  stub instr(text, text) is called
CONTEXT:  PL/pgSQL function instr(text,text) line 3 at RAISE
-- select instr (stub function, not pushdown constraints, explain)
--Testcase 1378:
EXPLAIN VERBOSE
SELECT value1, instr(str1, str2) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=16)
   Output: value1, instr(str1, str2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select instr (stub function, not pushdown constraints, result)
--Testcase 1379:
SELECT value1, instr(str1, str2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub instr(text, text) is called
CONTEXT:  PL/pgSQL function instr(text,text) line 3 at RAISE
-- select instr (stub function, pushdown constraints, explain)
--Testcase 1380:
EXPLAIN VERBOSE
SELECT value1, instr(str1, str2) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=16)
   Output: value1, instr(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select instr (stub function, pushdown constraints, result)
--Testcase 1381:
SELECT value1, instr(str1, str2) FROM s3 WHERE value2 != 200;
ERROR:  stub instr(text, text) is called
CONTEXT:  PL/pgSQL function instr(text,text) line 3 at RAISE
-- select instr with non pushdown func and explicit constant (explain)
--Testcase 1382:
EXPLAIN VERBOSE
SELECT instr(str1, str2), pi(), 4.1 FROM s3;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=48)
   Output: instr(str1, str2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select instr with non pushdown func and explicit constant (result)
--Testcase 1383:
SELECT instr(str1, str2), pi(), 4.1 FROM s3;
ERROR:  stub instr(text, text) is called
CONTEXT:  PL/pgSQL function instr(text,text) line 3 at RAISE
-- select instr with order by (explain)
--Testcase 1384:
EXPLAIN VERBOSE
SELECT value1, instr(str1, str2) FROM s3 ORDER BY instr(str1, str2);
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=16)
   Output: value1, instr(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY instr(`str1`, `str2`) IS NULL ASC, instr(`str1`, `str2`) ASC
(4 rows)

-- select instr with order by (result)
--Testcase 1385:
SELECT value1, instr(str1, str2) FROM s3 ORDER BY instr(str1, str2);
ERROR:  stub instr(text, text) is called
CONTEXT:  PL/pgSQL function instr(text,text) line 3 at RAISE
-- select instr with order by index (result)
--Testcase 1386:
SELECT value1, instr(str1, str2) FROM s3 ORDER BY 2,1;
ERROR:  stub instr(text, text) is called
CONTEXT:  PL/pgSQL function instr(text,text) line 3 at RAISE
-- select instr with order by index (result)
--Testcase 1387:
SELECT value1, instr(str1, str2) FROM s3 ORDER BY 1,2;
ERROR:  stub instr(text, text) is called
CONTEXT:  PL/pgSQL function instr(text,text) line 3 at RAISE
-- select instr with group by (explain)
--Testcase 1388:
EXPLAIN VERBOSE
SELECT count(value1), instr(str1, str2) FROM s3 GROUP BY instr(str1, str2);
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (instr(str1, str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), instr(`str1`, `str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select instr with group by (result)
--Testcase 1389:
SELECT count(value1), instr(str1, str2) FROM s3 GROUP BY instr(str1, str2);
 count | instr 
-------+-------
     6 |     0
(1 row)

-- select instr with group by index (result)
--Testcase 1390:
SELECT value1, instr(str1, str2) FROM s3 GROUP BY 2,1;
 value1 | instr 
--------+-------
    0.1 |     0
    0.2 |     0
    0.3 |     0
    1.1 |     0
    2.2 |     0
    3.3 |     0
(6 rows)

-- select instr with group by having (explain)
--Testcase 1391:
EXPLAIN VERBOSE
SELECT count(value1), instr(str1, str2) FROM s3 GROUP BY instr(str1, str2), str1, str2 HAVING instr(str1, str2) IS NOT NULL;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=80)
   Output: (count(value1)), (instr(str1, str2)), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), instr(`str1`, `str2`), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((instr(`str1`, `str2`) IS NOT NULL))
(5 rows)

-- select instr with group by having (result)
--Testcase 1392:
SELECT count(value1), instr(str1, str2) FROM s3 GROUP BY instr(str1, str2), str1, str2 HAVING instr(str1, str2) IS NOT NULL;
 count | instr 
-------+-------
     6 |     0
(1 row)

-- select instr with group by index having (result)
--Testcase 1393:
SELECT value1, instr(str1, str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | instr 
--------+-------
    1.1 |     0
    2.2 |     0
    3.3 |     0
(3 rows)

-- ===============================================================================
-- test lcase()
-- ===============================================================================
-- select lcase (stub function, explain)
--Testcase 1394:
EXPLAIN VERBOSE
SELECT lcase(tag1), lcase(str1), lcase(str2) FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.57 rows=682 width=96)
   Output: lcase(tag1), lcase(str1), lcase(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select lcase (stub function, result)
--Testcase 1395:
SELECT lcase(tag1), lcase(str1), lcase(str2) FROM s3;
ERROR:  stub lcase(text) is called
CONTEXT:  PL/pgSQL function lcase(text) line 3 at RAISE
-- select lcase (stub function, not pushdown constraints, explain)
--Testcase 1396:
EXPLAIN VERBOSE
SELECT value1, lcase(str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, lcase(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select lcase (stub function, not pushdown constraints, result)
--Testcase 1397:
SELECT value1, lcase(str1) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub lcase(text) is called
CONTEXT:  PL/pgSQL function lcase(text) line 3 at RAISE
-- select lcase (stub function, pushdown constraints, explain)
--Testcase 1398:
EXPLAIN VERBOSE
SELECT value1, lcase(str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, lcase(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select lcase (stub function, pushdown constraints, result)
--Testcase 1399:
SELECT value1, lcase(str1) FROM s3 WHERE value2 != 200;
ERROR:  stub lcase(text) is called
CONTEXT:  PL/pgSQL function lcase(text) line 3 at RAISE
-- select lcase with non pushdown func and explicit constant (explain)
--Testcase 1400:
EXPLAIN VERBOSE
SELECT lcase(str1), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: lcase(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select lcase with non pushdown func and explicit constant (result)
--Testcase 1401:
SELECT lcase(str1), pi(), 4.1 FROM s3;
ERROR:  stub lcase(text) is called
CONTEXT:  PL/pgSQL function lcase(text) line 3 at RAISE
-- select lcase with order by (explain)
--Testcase 1402:
EXPLAIN VERBOSE
SELECT value1, lcase(str1) FROM s3 ORDER BY lcase(str1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, lcase(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY lcase(`str1`) IS NULL ASC, lcase(`str1`) ASC
(4 rows)

-- select lcase with order by (result)
--Testcase 1403:
SELECT value1, lcase(str1) FROM s3 ORDER BY lcase(str1);
ERROR:  stub lcase(text) is called
CONTEXT:  PL/pgSQL function lcase(text) line 3 at RAISE
-- select lcase with order by index (result)
--Testcase 1404:
SELECT value1, lcase(str1) FROM s3 ORDER BY 2,1;
ERROR:  stub lcase(text) is called
CONTEXT:  PL/pgSQL function lcase(text) line 3 at RAISE
-- select lcase with order by index (result)
--Testcase 1405:
SELECT value1, lcase(str1) FROM s3 ORDER BY 1,2;
ERROR:  stub lcase(text) is called
CONTEXT:  PL/pgSQL function lcase(text) line 3 at RAISE
-- select lcase with group by (explain)
--Testcase 1406:
EXPLAIN VERBOSE
SELECT count(value1), lcase(str1) FROM s3 GROUP BY lcase(str1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (lcase(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), lcase(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select lcase with group by (result)
--Testcase 1407:
SELECT count(value1), lcase(str1) FROM s3 GROUP BY lcase(str1);
 count |   lcase   
-------+-----------
     6 | ---xyz---
(1 row)

-- select lcase with group by index (result)
--Testcase 1408:
SELECT value1, lcase(str1) FROM s3 GROUP BY 2,1;
 value1 |   lcase   
--------+-----------
    0.1 | ---xyz---
    0.2 | ---xyz---
    0.3 | ---xyz---
    1.1 | ---xyz---
    2.2 | ---xyz---
    3.3 | ---xyz---
(6 rows)

-- select lcase with group by having (explain)
--Testcase 1409:
EXPLAIN VERBOSE
SELECT count(value1), lcase(str1) FROM s3 GROUP BY lcase(str1), str1 HAVING lcase(str1) IS NOT NULL;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (lcase(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), lcase(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((lcase(`str1`) IS NOT NULL))
(5 rows)

-- select lcase with group by having (result)
--Testcase 1410:
SELECT count(value1), lcase(str1) FROM s3 GROUP BY lcase(str1), str1 HAVING lcase(str1) IS NOT NULL;
 count |   lcase   
-------+-----------
     6 | ---xyz---
(1 row)

-- select lcase with group by index having (result)
--Testcase 1411:
SELECT value1, lcase(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |   lcase   
--------+-----------
    1.1 | ---xyz---
    2.2 | ---xyz---
    3.3 | ---xyz---
(3 rows)

-- ===============================================================================
-- test left()
-- ===============================================================================
-- select left (stub function, explain)
--Testcase 1412:
EXPLAIN VERBOSE
SELECT left(str1, 5), left(str2, 5) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: "left"(str1, 5), "left"(str2, 5)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select left (stub function, result)
--Testcase 1413:
SELECT left(str1, 5), left(str2, 5) FROM s3;
 left  | left  
-------+-------
 ---XY |    XY
 ---XY |    XY
 ---XY |    XY
 ---XY |    XY
 ---XY |    XY
 ---XY |    XY
(6 rows)

-- select left (stub function, not pushdown constraints, explain)
--Testcase 1414:
EXPLAIN VERBOSE
SELECT value1, left(str1, 5) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, "left"(str1, 5)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select left (stub function, not pushdown constraints, result)
--Testcase 1415:
SELECT value1, left(str1, 5) FROM s3 WHERE to_hex(value2) = '64';
 value1 | left  
--------+-------
    0.1 | ---XY
    0.2 | ---XY
    0.3 | ---XY
(3 rows)

-- select left (stub function, pushdown constraints, explain)
--Testcase 1416:
EXPLAIN VERBOSE
SELECT value1, left(str1, 5) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, "left"(str1, 5)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select left (stub function, pushdown constraints, result)
--Testcase 1417:
SELECT value1, left(str1, 5) FROM s3 WHERE value2 != 200;
 value1 | left  
--------+-------
    0.1 | ---XY
    0.2 | ---XY
    0.3 | ---XY
(3 rows)

-- select left with non pushdown func and explicit constant (explain)
--Testcase 1418:
EXPLAIN VERBOSE
SELECT left(str1, 5), pi(), 4.1 FROM s3;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: "left"(str1, 5), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select left with non pushdown func and explicit constant (result)
--Testcase 1419:
SELECT left(str1, 5), pi(), 4.1 FROM s3;
 left  |        pi         | ?column? 
-------+-------------------+----------
 ---XY | 3.141592653589793 |      4.1
 ---XY | 3.141592653589793 |      4.1
 ---XY | 3.141592653589793 |      4.1
 ---XY | 3.141592653589793 |      4.1
 ---XY | 3.141592653589793 |      4.1
 ---XY | 3.141592653589793 |      4.1
(6 rows)

-- select left with order by (explain)
--Testcase 1420:
EXPLAIN VERBOSE
SELECT value1, left(str1, 5) FROM s3 ORDER BY left(str1, 5);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, "left"(str1, 5)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY left(`str1`, 5) IS NULL ASC, left(`str1`, 5) ASC
(4 rows)

-- select left with order by (result)
--Testcase 1421:
SELECT value1, left(str1, 5) FROM s3 ORDER BY left(str1, 5);
 value1 | left  
--------+-------
    0.1 | ---XY
    0.2 | ---XY
    0.3 | ---XY
    1.1 | ---XY
    2.2 | ---XY
    3.3 | ---XY
(6 rows)

-- select left with order by index (result)
--Testcase 1422:
SELECT value1, left(str1, 5) FROM s3 ORDER BY 2,1;
 value1 | left  
--------+-------
    0.1 | ---XY
    0.2 | ---XY
    0.3 | ---XY
    1.1 | ---XY
    2.2 | ---XY
    3.3 | ---XY
(6 rows)

-- select left with order by index (result)
--Testcase 1423:
SELECT value1, left(str1, 5) FROM s3 ORDER BY 1,2;
 value1 | left  
--------+-------
    0.1 | ---XY
    0.2 | ---XY
    0.3 | ---XY
    1.1 | ---XY
    2.2 | ---XY
    3.3 | ---XY
(6 rows)

-- select left with group by (explain)
--Testcase 1424:
EXPLAIN VERBOSE
SELECT count(value1), left(str1, 5) FROM s3 GROUP BY left(str1, 5);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), ("left"(str1, 5))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), left(`str1`, 5) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select left with group by (result)
--Testcase 1425:
SELECT count(value1), left(str1, 5) FROM s3 GROUP BY left(str1, 5);
 count | left  
-------+-------
     6 | ---XY
(1 row)

-- select left with group by index (result)
--Testcase 1426:
SELECT value1, left(str1, 5) FROM s3 GROUP BY 2,1;
 value1 | left  
--------+-------
    0.1 | ---XY
    0.2 | ---XY
    0.3 | ---XY
    1.1 | ---XY
    2.2 | ---XY
    3.3 | ---XY
(6 rows)

-- select left with group by having (explain)
--Testcase 1427:
EXPLAIN VERBOSE
SELECT count(value1), left(str1, 5) FROM s3 GROUP BY left(str1, 5), str1 HAVING left(str1, 5) IS NOT NULL;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), ("left"(str1, 5)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), left(`str1`, 5), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((left(`str1`, 5) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select left with group by having (result)
--Testcase 1428:
SELECT count(value1), left(str1, 5) FROM s3 GROUP BY left(str1, 5), str1 HAVING left(str1, 5) IS NOT NULL;
 count | left  
-------+-------
     6 | ---XY
(1 row)

-- select left with group by index having (result)
--Testcase 1429:
SELECT value1, left(str1, 5) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | left  
--------+-------
    1.1 | ---XY
    2.2 | ---XY
    3.3 | ---XY
(3 rows)

-- ===============================================================================
-- test length()
-- ===============================================================================
-- select length (stub function, explain)
--Testcase 1430:
EXPLAIN VERBOSE
SELECT length(str1), length(str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=8)
   Output: length(str1), length(str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select length (stub function, result)
--Testcase 1431:
SELECT length(str1), length(str2) FROM s3;
 length | length 
--------+--------
      9 |      9
      9 |      9
      9 |      9
      9 |      9
      9 |      9
      9 |      9
(6 rows)

-- select length (stub function, not pushdown constraints, explain)
--Testcase 1432:
EXPLAIN VERBOSE
SELECT value1, length(str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=12)
   Output: value1, length(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select length (stub function, not pushdown constraints, result)
--Testcase 1433:
SELECT value1, length(str1) FROM s3 WHERE to_hex(value2) = '64';
 value1 | length 
--------+--------
    0.1 |      9
    0.2 |      9
    0.3 |      9
(3 rows)

-- select length (stub function, pushdown constraints, explain)
--Testcase 1434:
EXPLAIN VERBOSE
SELECT value1, length(str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=12)
   Output: value1, length(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select length (stub function, pushdown constraints, result)
--Testcase 1435:
SELECT value1, length(str1) FROM s3 WHERE value2 != 200;
 value1 | length 
--------+--------
    0.1 |      9
    0.2 |      9
    0.3 |      9
(3 rows)

-- select length with non pushdown func and explicit constant (explain)
--Testcase 1436:
EXPLAIN VERBOSE
SELECT length(str1), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: length(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select length with non pushdown func and explicit constant (result)
--Testcase 1437:
SELECT length(str1), pi(), 4.1 FROM s3;
 length |        pi         | ?column? 
--------+-------------------+----------
      9 | 3.141592653589793 |      4.1
      9 | 3.141592653589793 |      4.1
      9 | 3.141592653589793 |      4.1
      9 | 3.141592653589793 |      4.1
      9 | 3.141592653589793 |      4.1
      9 | 3.141592653589793 |      4.1
(6 rows)

-- select length with order by (explain)
--Testcase 1438:
EXPLAIN VERBOSE
SELECT value1, length(str1) FROM s3 ORDER BY length(str1);
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, length(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY length(`str1`) IS NULL ASC, length(`str1`) ASC
(4 rows)

-- select length with order by (result)
--Testcase 1439:
SELECT value1, length(str1) FROM s3 ORDER BY length(str1);
 value1 | length 
--------+--------
    0.1 |      9
    0.2 |      9
    0.3 |      9
    1.1 |      9
    2.2 |      9
    3.3 |      9
(6 rows)

-- select length with order by index (result)
--Testcase 1440:
SELECT value1, length(str1) FROM s3 ORDER BY 2,1;
 value1 | length 
--------+--------
    0.1 |      9
    0.2 |      9
    0.3 |      9
    1.1 |      9
    2.2 |      9
    3.3 |      9
(6 rows)

-- select length with order by index (result)
--Testcase 1441:
SELECT value1, length(str1) FROM s3 ORDER BY 1,2;
 value1 | length 
--------+--------
    0.1 |      9
    0.2 |      9
    0.3 |      9
    1.1 |      9
    2.2 |      9
    3.3 |      9
(6 rows)

-- select length with group by (explain)
--Testcase 1442:
EXPLAIN VERBOSE
SELECT count(value1), length(str1) FROM s3 GROUP BY length(str1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (length(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), length(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select length with group by (result)
--Testcase 1443:
SELECT count(value1), length(str1) FROM s3 GROUP BY length(str1);
 count | length 
-------+--------
     6 |      9
(1 row)

-- select length with group by index (result)
--Testcase 1444:
SELECT value1, length(str1) FROM s3 GROUP BY 2,1;
 value1 | length 
--------+--------
    0.1 |      9
    0.2 |      9
    0.3 |      9
    1.1 |      9
    2.2 |      9
    3.3 |      9
(6 rows)

-- select length with group by having (explain)
--Testcase 1445:
EXPLAIN VERBOSE
SELECT count(value1), length(str1) FROM s3 GROUP BY length(str1), str1 HAVING length(str1) IS NOT NULL;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=44)
   Output: (count(value1)), (length(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), length(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((length(`str1`) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select length with group by having (result)
--Testcase 1446:
SELECT count(value1), length(str1) FROM s3 GROUP BY length(str1), str1 HAVING length(str1) IS NOT NULL;
 count | length 
-------+--------
     6 |      9
(1 row)

-- select length with group by index having (result)
--Testcase 1447:
SELECT value1, length(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | length 
--------+--------
    1.1 |      9
    2.2 |      9
    3.3 |      9
(3 rows)

-- ===============================================================================
-- test locate()
-- ===============================================================================
-- select locate (stub function, explain)
--Testcase 1448:
EXPLAIN VERBOSE
SELECT locate(str1, str2), locate(str2, str1, 3) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=16)
   Output: locate(str1, str2), locate(str2, str1, '3'::bigint)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select locate (stub function, result)
--Testcase 1449:
SELECT locate(str1, str2), locate(str2, str1, 3) FROM s3;
ERROR:  stub locate(text, text) is called
CONTEXT:  PL/pgSQL function locate(text,text) line 3 at RAISE
-- select locate (stub function, not pushdown constraints, explain)
--Testcase 1450:
EXPLAIN VERBOSE
SELECT value1, locate(str1, str2) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=16)
   Output: value1, locate(str1, str2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select locate (stub function, not pushdown constraints, result)
--Testcase 1451:
SELECT value1, locate(str1, str2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub locate(text, text) is called
CONTEXT:  PL/pgSQL function locate(text,text) line 3 at RAISE
-- select locate (stub function, pushdown constraints, explain)
--Testcase 1452:
EXPLAIN VERBOSE
SELECT value1, locate(str1, str2) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=16)
   Output: value1, locate(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select locate (stub function, pushdown constraints, result)
--Testcase 1453:
SELECT value1, locate(str1, str2) FROM s3 WHERE value2 != 200;
ERROR:  stub locate(text, text) is called
CONTEXT:  PL/pgSQL function locate(text,text) line 3 at RAISE
-- select locate with non pushdown func and explicit constant (explain)
--Testcase 1454:
EXPLAIN VERBOSE
SELECT locate(str1, str2), pi(), 4.1 FROM s3;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=48)
   Output: locate(str1, str2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select locate with non pushdown func and explicit constant (result)
--Testcase 1455:
SELECT locate(str1, str2), pi(), 4.1 FROM s3;
ERROR:  stub locate(text, text) is called
CONTEXT:  PL/pgSQL function locate(text,text) line 3 at RAISE
-- select locate with order by (explain)
--Testcase 1456:
EXPLAIN VERBOSE
SELECT value1, locate(str1, str2) FROM s3 ORDER BY locate(str1, str2);
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=16)
   Output: value1, locate(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY locate(`str1`, `str2`) IS NULL ASC, locate(`str1`, `str2`) ASC
(4 rows)

-- select locate with order by (result)
--Testcase 1457:
SELECT value1, locate(str1, str2) FROM s3 ORDER BY locate(str1, str2);
ERROR:  stub locate(text, text) is called
CONTEXT:  PL/pgSQL function locate(text,text) line 3 at RAISE
-- select locate with order by index (result)
--Testcase 1458:
SELECT value1, locate(str1, str2) FROM s3 ORDER BY 2,1;
ERROR:  stub locate(text, text) is called
CONTEXT:  PL/pgSQL function locate(text,text) line 3 at RAISE
-- select locate with order by index (result)
--Testcase 1459:
SELECT value1, locate(str1, str2) FROM s3 ORDER BY 1,2;
ERROR:  stub locate(text, text) is called
CONTEXT:  PL/pgSQL function locate(text,text) line 3 at RAISE
-- select locate with group by (explain)
--Testcase 1460:
EXPLAIN VERBOSE
SELECT count(value1), locate(str1, str2) FROM s3 GROUP BY locate(str1, str2);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(value1)), (locate(str1, str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), locate(`str1`, `str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select locate with group by (result)
--Testcase 1461:
SELECT count(value1), locate(str1, str2) FROM s3 GROUP BY locate(str1, str2);
 count | locate 
-------+--------
     6 |      0
(1 row)

-- select locate with group by index (result)
--Testcase 1462:
SELECT value1, locate(str1, str2) FROM s3 GROUP BY 2,1;
 value1 | locate 
--------+--------
    0.1 |      0
    0.2 |      0
    0.3 |      0
    1.1 |      0
    2.2 |      0
    3.3 |      0
(6 rows)

-- select locate with group by having (explain)
--Testcase 1463:
EXPLAIN VERBOSE
SELECT count(value1), locate(str1, str2) FROM s3 GROUP BY locate(str1, str2), str1, str2 HAVING locate(str1, str2) IS NOT NULL;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=80)
   Output: (count(value1)), (locate(str1, str2)), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), locate(`str1`, `str2`), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((locate(`str1`, `str2`) IS NOT NULL))
(5 rows)

-- select locate with group by having (result)
--Testcase 1464:
SELECT count(value1), locate(str1, str2) FROM s3 GROUP BY locate(str1, str2), str1, str2 HAVING locate(str1, str2) IS NOT NULL;
 count | locate 
-------+--------
     6 |      0
(1 row)

-- select locate with group by index having (result)
--Testcase 1465:
SELECT value1, locate(str1, str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | locate 
--------+--------
    1.1 |      0
    2.2 |      0
    3.3 |      0
(3 rows)

-- ===============================================================================
-- test lower()
-- ===============================================================================
-- select lower (stub function, explain)
--Testcase 1466:
EXPLAIN VERBOSE
SELECT lower(str1), lower(str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: lower(str1), lower(str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select lower (stub function, result)
--Testcase 1467:
SELECT lower(str1), lower(str2) FROM s3;
   lower   |   lower   
-----------+-----------
 ---xyz--- |    xyz   
 ---xyz--- |    xyz   
 ---xyz--- |    xyz   
 ---xyz--- |    xyz   
 ---xyz--- |    xyz   
 ---xyz--- |    xyz   
(6 rows)

-- select lower (stub function, not pushdown constraints, explain)
--Testcase 1468:
EXPLAIN VERBOSE
SELECT value1, lower(str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, lower(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select lower (stub function, not pushdown constraints, result)
--Testcase 1469:
SELECT value1, lower(str1) FROM s3 WHERE to_hex(value2) = '64';
 value1 |   lower   
--------+-----------
    0.1 | ---xyz---
    0.2 | ---xyz---
    0.3 | ---xyz---
(3 rows)

-- select lower (stub function, pushdown constraints, explain)
--Testcase 1470:
EXPLAIN VERBOSE
SELECT value1, lower(str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, lower(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select lower (stub function, pushdown constraints, result)
--Testcase 1471:
SELECT value1, lower(str1) FROM s3 WHERE value2 != 200;
 value1 |   lower   
--------+-----------
    0.1 | ---xyz---
    0.2 | ---xyz---
    0.3 | ---xyz---
(3 rows)

-- select lower with non pushdown func and explicit constant (explain)
--Testcase 1472:
EXPLAIN VERBOSE
SELECT lower(str1), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: lower(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select lower with non pushdown func and explicit constant (result)
--Testcase 1473:
SELECT lower(str1), pi(), 4.1 FROM s3;
   lower   |        pi         | ?column? 
-----------+-------------------+----------
 ---xyz--- | 3.141592653589793 |      4.1
 ---xyz--- | 3.141592653589793 |      4.1
 ---xyz--- | 3.141592653589793 |      4.1
 ---xyz--- | 3.141592653589793 |      4.1
 ---xyz--- | 3.141592653589793 |      4.1
 ---xyz--- | 3.141592653589793 |      4.1
(6 rows)

-- select lower with order by (explain)
--Testcase 1474:
EXPLAIN VERBOSE
SELECT value1, lower(str1) FROM s3 ORDER BY lower(str1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, lower(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY lower(`str1`) IS NULL ASC, lower(`str1`) ASC
(4 rows)

-- select lower with order by (result)
--Testcase 1475:
SELECT value1, lower(str1) FROM s3 ORDER BY lower(str1);
 value1 |   lower   
--------+-----------
    0.1 | ---xyz---
    0.2 | ---xyz---
    0.3 | ---xyz---
    1.1 | ---xyz---
    2.2 | ---xyz---
    3.3 | ---xyz---
(6 rows)

-- select lower with order by index (result)
--Testcase 1476:
SELECT value1, lower(str1) FROM s3 ORDER BY 2,1;
 value1 |   lower   
--------+-----------
    0.1 | ---xyz---
    0.2 | ---xyz---
    0.3 | ---xyz---
    1.1 | ---xyz---
    2.2 | ---xyz---
    3.3 | ---xyz---
(6 rows)

-- select lower with order by index (result)
--Testcase 1477:
SELECT value1, lower(str1) FROM s3 ORDER BY 1,2;
 value1 |   lower   
--------+-----------
    0.1 | ---xyz---
    0.2 | ---xyz---
    0.3 | ---xyz---
    1.1 | ---xyz---
    2.2 | ---xyz---
    3.3 | ---xyz---
(6 rows)

-- select lower with group by (explain)
--Testcase 1478:
EXPLAIN VERBOSE
SELECT count(value1), lower(str1) FROM s3 GROUP BY lower(str1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (lower(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), lower(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select lower with group by (result)
--Testcase 1479:
SELECT count(value1), lower(str1) FROM s3 GROUP BY lower(str1);
 count |   lower   
-------+-----------
     6 | ---xyz---
(1 row)

-- select lower with group by index (result)
--Testcase 1480:
SELECT value1, lower(str1) FROM s3 GROUP BY 2,1;
 value1 |   lower   
--------+-----------
    0.1 | ---xyz---
    0.2 | ---xyz---
    0.3 | ---xyz---
    1.1 | ---xyz---
    2.2 | ---xyz---
    3.3 | ---xyz---
(6 rows)

-- select lower with group by having (explain)
--Testcase 1481:
EXPLAIN VERBOSE
SELECT count(value1), lower(str1) FROM s3 GROUP BY lower(str1), str1 HAVING lower(str1) IS NOT NULL;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (lower(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), lower(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((lower(`str1`) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select lower with group by having (result)
--Testcase 1482:
SELECT count(value1), lower(str1) FROM s3 GROUP BY lower(str1), str1 HAVING lower(str1) IS NOT NULL;
 count |   lower   
-------+-----------
     6 | ---xyz---
(1 row)

-- select lower with group by index having (result)
--Testcase 1483:
SELECT value1, lower(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |   lower   
--------+-----------
    1.1 | ---xyz---
    2.2 | ---xyz---
    3.3 | ---xyz---
(3 rows)

-- ===============================================================================
-- test lpad()
-- ===============================================================================
-- select lpad (stub function, explain)
--Testcase 1484:
EXPLAIN VERBOSE
SELECT lpad(str1, 4, 'ABCD'), lpad(str2, 4, 'ABCD') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: lpad(str1, 4, 'ABCD'::text), lpad(str2, 4, 'ABCD'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select lpad (stub function, result)
--Testcase 1485:
SELECT lpad(str1, 4, 'ABCD'), lpad(str2, 4, 'ABCD') FROM s3;
 lpad | lpad 
------+------
 ---X |    X
 ---X |    X
 ---X |    X
 ---X |    X
 ---X |    X
 ---X |    X
(6 rows)

-- select lpad (stub function, not pushdown constraints, explain)
--Testcase 1486:
EXPLAIN VERBOSE
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, lpad(str1, 4, 'ABCD'::text)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select lpad (stub function, not pushdown constraints, result)
--Testcase 1487:
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 WHERE to_hex(value2) = '64';
 value1 | lpad 
--------+------
    0.1 | ---X
    0.2 | ---X
    0.3 | ---X
(3 rows)

-- select lpad (stub function, pushdown constraints, explain)
--Testcase 1488:
EXPLAIN VERBOSE
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, lpad(str1, 4, 'ABCD'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select lpad (stub function, pushdown constraints, result)
--Testcase 1489:
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 WHERE value2 != 200;
 value1 | lpad 
--------+------
    0.1 | ---X
    0.2 | ---X
    0.3 | ---X
(3 rows)

-- select lpad with non pushdown func and explicit constant (explain)
--Testcase 1490:
EXPLAIN VERBOSE
SELECT lpad(str1, 4, 'ABCD'), pi(), 4.1 FROM s3;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: lpad(str1, 4, 'ABCD'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select lpad with non pushdown func and explicit constant (result)
--Testcase 1491:
SELECT lpad(str1, 4, 'ABCD'), pi(), 4.1 FROM s3;
 lpad |        pi         | ?column? 
------+-------------------+----------
 ---X | 3.141592653589793 |      4.1
 ---X | 3.141592653589793 |      4.1
 ---X | 3.141592653589793 |      4.1
 ---X | 3.141592653589793 |      4.1
 ---X | 3.141592653589793 |      4.1
 ---X | 3.141592653589793 |      4.1
(6 rows)

-- select lpad with order by (explain)
--Testcase 1492:
EXPLAIN VERBOSE
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 ORDER BY lpad(str1, 4, 'ABCD');
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, lpad(str1, 4, 'ABCD'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY lpad(`str1`, 4, 'ABCD') IS NULL ASC, lpad(`str1`, 4, 'ABCD') ASC
(4 rows)

-- select lpad with order by (result)
--Testcase 1493:
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 ORDER BY lpad(str1, 4, 'ABCD');
 value1 | lpad 
--------+------
    0.1 | ---X
    0.2 | ---X
    0.3 | ---X
    1.1 | ---X
    2.2 | ---X
    3.3 | ---X
(6 rows)

-- select lpad with order by index (result)
--Testcase 1494:
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 ORDER BY 2,1;
 value1 | lpad 
--------+------
    0.1 | ---X
    0.2 | ---X
    0.3 | ---X
    1.1 | ---X
    2.2 | ---X
    3.3 | ---X
(6 rows)

-- select lpad with order by index (result)
--Testcase 1495:
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 ORDER BY 1,2;
 value1 | lpad 
--------+------
    0.1 | ---X
    0.2 | ---X
    0.3 | ---X
    1.1 | ---X
    2.2 | ---X
    3.3 | ---X
(6 rows)

-- select lpad with group by (explain)
--Testcase 1496:
EXPLAIN VERBOSE
SELECT count(value1), lpad(str1, 4, 'ABCD') FROM s3 GROUP BY lpad(str1, 4, 'ABCD');
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (lpad(str1, 4, 'ABCD'::text))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), lpad(`str1`, 4, 'ABCD') FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select lpad with group by (result)
--Testcase 1497:
SELECT count(value1), lpad(str1, 4, 'ABCD') FROM s3 GROUP BY lpad(str1, 4, 'ABCD');
 count | lpad 
-------+------
     6 | ---X
(1 row)

-- select lpad with group by index (result)
--Testcase 1498:
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 GROUP BY 2,1;
 value1 | lpad 
--------+------
    0.1 | ---X
    0.2 | ---X
    0.3 | ---X
    1.1 | ---X
    2.2 | ---X
    3.3 | ---X
(6 rows)

-- select lpad with group by having (explain)
--Testcase 1499:
EXPLAIN VERBOSE
SELECT count(value1), lpad(str1, 4, 'ABCD') FROM s3 GROUP BY lpad(str1, 4, 'ABCD'), str1 HAVING lpad(str1, 4, 'ABCD') IS NOT NULL;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (lpad(str1, 4, 'ABCD'::text)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), lpad(`str1`, 4, 'ABCD'), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((lpad(`str1`, 4, 'ABCD') IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select lpad with group by having (result)
--Testcase 1500:
SELECT count(value1), lpad(str1, 4, 'ABCD') FROM s3 GROUP BY lpad(str1, 4, 'ABCD'), str1 HAVING lpad(str1, 4, 'ABCD') IS NOT NULL;
 count | lpad 
-------+------
     6 | ---X
(1 row)

-- select lpad with group by index having (result)
--Testcase 1501:
SELECT value1, lpad(str1, 4, 'ABCD') FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | lpad 
--------+------
    1.1 | ---X
    2.2 | ---X
    3.3 | ---X
(3 rows)

-- ===============================================================================
-- test ltrim()
-- ===============================================================================
-- select ltrim (stub function, explain)
--Testcase 1502:
EXPLAIN VERBOSE
SELECT ltrim(str1), ltrim(str2, ' ') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: ltrim(str1), ltrim(str2, ' '::text)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ltrim (stub function, result)
--Testcase 1503:
SELECT ltrim(str1), ltrim(str2, ' ') FROM s3;
   ltrim   | ltrim  
-----------+--------
 ---XYZ--- | XYZ   
 ---XYZ--- | XYZ   
 ---XYZ--- | XYZ   
 ---XYZ--- | XYZ   
 ---XYZ--- | XYZ   
 ---XYZ--- | XYZ   
(6 rows)

-- select ltrim (stub function, not pushdown constraints, explain)
--Testcase 1504:
EXPLAIN VERBOSE
SELECT value1, ltrim(str1, '-') FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, ltrim(str1, '-'::text)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ltrim (stub function, not pushdown constraints, result)
--Testcase 1505:
SELECT value1, ltrim(str1, '-') FROM s3 WHERE to_hex(value2) = '64';
 value1 | ltrim  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
(3 rows)

-- select ltrim (stub function, pushdown constraints, explain)
--Testcase 1506:
EXPLAIN VERBOSE
SELECT value1, ltrim(str1, '-') FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, ltrim(str1, '-'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select ltrim (stub function, pushdown constraints, result)
--Testcase 1507:
SELECT value1, ltrim(str1, '-') FROM s3 WHERE value2 != 200;
 value1 | ltrim  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
(3 rows)

-- select ltrim with non pushdown func and explicit constant (explain)
--Testcase 1508:
EXPLAIN VERBOSE
SELECT ltrim(str1, '-'), pi(), 4.1 FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: ltrim(str1, '-'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ltrim with non pushdown func and explicit constant (result)
--Testcase 1509:
SELECT ltrim(str1, '-'), pi(), 4.1 FROM s3;
 ltrim  |        pi         | ?column? 
--------+-------------------+----------
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
(6 rows)

-- select ltrim with order by (explain)
--Testcase 1510:
EXPLAIN VERBOSE
SELECT value1, ltrim(str1, '-') FROM s3 ORDER BY ltrim(str1, '-');
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, ltrim(str1, '-'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY trim(LEADING '-' FROM `str1`) IS NULL ASC, trim(LEADING '-' FROM `str1`) ASC
(4 rows)

-- select ltrim with order by (result)
--Testcase 1511:
SELECT value1, ltrim(str1, '-') FROM s3 ORDER BY ltrim(str1, '-');
 value1 | ltrim  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(6 rows)

-- select ltrim with order by index (result)
--Testcase 1512:
SELECT value1, ltrim(str1, '-') FROM s3 ORDER BY 2,1;
 value1 | ltrim  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(6 rows)

-- select ltrim with order by index (result)
--Testcase 1513:
SELECT value1, ltrim(str1, '-') FROM s3 ORDER BY 1,2;
 value1 | ltrim  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(6 rows)

-- select ltrim with group by (explain)
--Testcase 1514:
EXPLAIN VERBOSE
SELECT count(value1), ltrim(str1, '-') FROM s3 GROUP BY ltrim(str1, '-');
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (ltrim(str1, '-'::text))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), trim(LEADING '-' FROM `str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select ltrim with group by (result)
--Testcase 1515:
SELECT count(value1), ltrim(str1, '-') FROM s3 GROUP BY ltrim(str1, '-');
 count | ltrim  
-------+--------
     6 | XYZ---
(1 row)

-- select ltrim with group by index (result)
--Testcase 1516:
SELECT value1, ltrim(str1, '-') FROM s3 GROUP BY 2,1;
 value1 | ltrim  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(6 rows)

-- select ltrim with group by having (explain)
--Testcase 1517:
EXPLAIN VERBOSE
SELECT count(value1), ltrim(str1, '-') FROM s3 GROUP BY ltrim(str1, '-'), str2 HAVING ltrim(str1, '-') IS NOT NULL;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (ltrim(str1, '-'::text)), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), trim(LEADING '-' FROM `str1`), `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((trim(LEADING '-' FROM `str1`) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select ltrim with group by having (result)
--Testcase 1518:
SELECT count(value1), ltrim(str1, '-') FROM s3 GROUP BY ltrim(str1, '-'), str2 HAVING ltrim(str1, '-') IS NOT NULL;
 count | ltrim  
-------+--------
     6 | XYZ---
(1 row)

-- select ltrim with group by index having (result)
--Testcase 1519:
SELECT value1, ltrim(str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | ltrim  
--------+--------
    1.1 | XYZ   
    2.2 | XYZ   
    3.3 | XYZ   
(3 rows)

-- ===============================================================================
-- test make_set()
-- ===============================================================================
-- select make_set (stub function, explain)
--Testcase 1520:
EXPLAIN VERBOSE
SELECT make_set(1, str1, str2), make_set(1 | 4, str1, str2) FROM s3;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: make_set('1'::bigint, VARIADIC ARRAY[str1, str2]), make_set('5'::bigint, VARIADIC ARRAY[str1, str2])
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select make_set (stub function, result)
--Testcase 1521:
SELECT make_set(1, str1, str2), make_set(1 | 4, str1, str2) FROM s3;
ERROR:  stub make_set(bigint, variadic text[]) is called
CONTEXT:  PL/pgSQL function make_set(bigint,text[]) line 3 at RAISE
-- select make_set (stub function, not pushdown constraints, explain)
--Testcase 1522:
EXPLAIN VERBOSE
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=40)
   Output: value1, make_set('5'::bigint, VARIADIC ARRAY[str1, str2])
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select make_set (stub function, not pushdown constraints, result)
--Testcase 1523:
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub make_set(bigint, variadic text[]) is called
CONTEXT:  PL/pgSQL function make_set(bigint,text[]) line 3 at RAISE
-- select make_set (stub function, pushdown constraints, explain)
--Testcase 1524:
EXPLAIN VERBOSE
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=40)
   Output: value1, make_set('5'::bigint, VARIADIC ARRAY[str1, str2])
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select make_set (stub function, pushdown constraints, result)
--Testcase 1525:
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 WHERE value2 != 200;
ERROR:  stub make_set(bigint, variadic text[]) is called
CONTEXT:  PL/pgSQL function make_set(bigint,text[]) line 3 at RAISE
-- select make_set with non pushdown func and explicit constant (explain)
--Testcase 1526:
EXPLAIN VERBOSE
SELECT make_set(1 | 4, str1, str2), pi(), 4.1 FROM s3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=72)
   Output: make_set('5'::bigint, VARIADIC ARRAY[str1, str2]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select make_set with non pushdown func and explicit constant (result)
--Testcase 1527:
SELECT make_set(1 | 4, str1, str2), pi(), 4.1 FROM s3;
ERROR:  stub make_set(bigint, variadic text[]) is called
CONTEXT:  PL/pgSQL function make_set(bigint,text[]) line 3 at RAISE
-- select make_set with order by (explain)
--Testcase 1528:
EXPLAIN VERBOSE
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 ORDER BY make_set(1 | 4, str1, str2);
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, make_set('5'::bigint, VARIADIC ARRAY[str1, str2])
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY make_set(5, `str1`, `str2`) IS NULL ASC, make_set(5, `str1`, `str2`) ASC
(4 rows)

-- select make_set with order by (result)
--Testcase 1529:
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 ORDER BY make_set(1 | 4, str1, str2);
ERROR:  stub make_set(bigint, variadic text[]) is called
CONTEXT:  PL/pgSQL function make_set(bigint,text[]) line 3 at RAISE
-- select make_set with order by index (result)
--Testcase 1530:
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 ORDER BY 2,1;
ERROR:  stub make_set(bigint, variadic text[]) is called
CONTEXT:  PL/pgSQL function make_set(bigint,text[]) line 3 at RAISE
-- select make_set with order by index (result)
--Testcase 1531:
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 ORDER BY 1,2;
ERROR:  stub make_set(bigint, variadic text[]) is called
CONTEXT:  PL/pgSQL function make_set(bigint,text[]) line 3 at RAISE
-- select make_set with group by (explain)
--Testcase 1532:
EXPLAIN VERBOSE
SELECT count(value1), make_set(1 | 4, str1, str2) FROM s3 GROUP BY make_set(1 | 4, str1, str2);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (make_set('5'::bigint, VARIADIC ARRAY[str1, str2]))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), make_set(5, `str1`, `str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select make_set with group by (result)
--Testcase 1533:
SELECT count(value1), make_set(1 | 4, str1, str2) FROM s3 GROUP BY make_set(1 | 4, str1, str2);
 count | make_set  
-------+-----------
     6 | ---XYZ---
(1 row)

-- select make_set with group by index (result)
--Testcase 1534:
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 GROUP BY 2,1;
 value1 | make_set  
--------+-----------
    0.1 | ---XYZ---
    0.2 | ---XYZ---
    0.3 | ---XYZ---
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(6 rows)

-- select make_set with group by having (explain)
--Testcase 1535:
EXPLAIN VERBOSE
SELECT count(value1), make_set(1 | 4, str1, str2) FROM s3 GROUP BY make_set(1 | 4, str1, str2), str1, str2 HAVING make_set(1 | 4, str1, str2) IS NOT NULL;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=104)
   Output: (count(value1)), (make_set('5'::bigint, VARIADIC ARRAY[str1, str2])), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), make_set(5, `str1`, `str2`), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((make_set(5, `str1`, `str2`) IS NOT NULL))
(5 rows)

-- select make_set with group by having (result)
--Testcase 1536:
SELECT count(value1), make_set(1 | 4, str1, str2) FROM s3 GROUP BY make_set(1 | 4, str1, str2), str1, str2 HAVING make_set(1 | 4, str1, str2) IS NOT NULL;
 count | make_set  
-------+-----------
     6 | ---XYZ---
(1 row)

-- select make_set with group by index having (result)
--Testcase 1537:
SELECT value1, make_set(1 | 4, str1, str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | make_set  
--------+-----------
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(3 rows)

-- ===============================================================================
-- test mid()
-- ===============================================================================
-- select mid (stub function, explain)
--Testcase 1538:
EXPLAIN VERBOSE
SELECT mid(str1, 2, 4), mid(str2, 2, 4) FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: mid(str1, '2'::bigint, '4'::bigint), mid(str2, '2'::bigint, '4'::bigint)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mid (stub function, result)
--Testcase 1539:
SELECT mid(str1, 2, 4), mid(str2, 2, 4) FROM s3;
ERROR:  stub mid(text, bigint, bigint) is called
CONTEXT:  PL/pgSQL function mid(text,bigint,bigint) line 3 at RAISE
-- select mid (stub function, not pushdown constraints, explain)
--Testcase 1540:
EXPLAIN VERBOSE
SELECT value1, mid(str2, 2, 4) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, mid(str2, '2'::bigint, '4'::bigint)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select mid (stub function, not pushdown constraints, result)
--Testcase 1541:
SELECT value1, mid(str2, 2, 4) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub mid(text, bigint, bigint) is called
CONTEXT:  PL/pgSQL function mid(text,bigint,bigint) line 3 at RAISE
-- select mid (stub function, pushdown constraints, explain)
--Testcase 1542:
EXPLAIN VERBOSE
SELECT value1, mid(str2, 2, 4) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, mid(str2, '2'::bigint, '4'::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select mid (stub function, pushdown constraints, result)
--Testcase 1543:
SELECT value1, mid(str2, 2, 4) FROM s3 WHERE value2 != 200;
ERROR:  stub mid(text, bigint, bigint) is called
CONTEXT:  PL/pgSQL function mid(text,bigint,bigint) line 3 at RAISE
-- select mid with non pushdown func and explicit constant (explain)
--Testcase 1544:
EXPLAIN VERBOSE
SELECT mid(str2, 2, 4), pi(), 4.1 FROM s3;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: mid(str2, '2'::bigint, '4'::bigint), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mid with non pushdown func and explicit constant (result)
--Testcase 1545:
SELECT mid(str2, 2, 4), pi(), 4.1 FROM s3;
ERROR:  stub mid(text, bigint, bigint) is called
CONTEXT:  PL/pgSQL function mid(text,bigint,bigint) line 3 at RAISE
-- select mid with order by (explain)
--Testcase 1546:
EXPLAIN VERBOSE
SELECT value1, mid(str2, 2, 4) FROM s3 ORDER BY mid(str2, 2, 4);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, mid(str2, '2'::bigint, '4'::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY mid(`str2`, 2, 4) IS NULL ASC, mid(`str2`, 2, 4) ASC
(4 rows)

-- select mid with order by (result)
--Testcase 1547:
SELECT value1, mid(str2, 2, 4) FROM s3 ORDER BY mid(str2, 2, 4);
ERROR:  stub mid(text, bigint, bigint) is called
CONTEXT:  PL/pgSQL function mid(text,bigint,bigint) line 3 at RAISE
-- select mid with order by index (result)
--Testcase 1548:
SELECT value1, mid(str2, 2, 4) FROM s3 ORDER BY 2,1;
ERROR:  stub mid(text, bigint, bigint) is called
CONTEXT:  PL/pgSQL function mid(text,bigint,bigint) line 3 at RAISE
-- select mid with order by index (result)
--Testcase 1549:
SELECT value1, mid(str2, 2, 4) FROM s3 ORDER BY 1,2;
ERROR:  stub mid(text, bigint, bigint) is called
CONTEXT:  PL/pgSQL function mid(text,bigint,bigint) line 3 at RAISE
-- select mid with group by (explain)
--Testcase 1550:
EXPLAIN VERBOSE
SELECT count(value1), mid(str2, 2, 4) FROM s3 GROUP BY mid(str2, 2, 4);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (mid(str2, '2'::bigint, '4'::bigint))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), mid(`str2`, 2, 4) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select mid with group by (result)
--Testcase 1551:
SELECT count(value1), mid(str2, 2, 4) FROM s3 GROUP BY mid(str2, 2, 4);
 count | mid  
-------+------
     6 |   XY
(1 row)

-- select mid with group by index (result)
--Testcase 1552:
SELECT value1, mid(str2, 2, 4) FROM s3 GROUP BY 2,1;
 value1 | mid  
--------+------
    0.1 |   XY
    0.2 |   XY
    0.3 |   XY
    1.1 |   XY
    2.2 |   XY
    3.3 |   XY
(6 rows)

-- select mid with group by having (explain)
--Testcase 1553:
EXPLAIN VERBOSE
SELECT count(value1), mid(str2, 2, 4) FROM s3 GROUP BY mid(str2, 2, 4), str2 HAVING mid(str2, 2, 4) IS NOT NULL;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (mid(str2, '2'::bigint, '4'::bigint)), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), mid(`str2`, 2, 4), `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((mid(`str2`, 2, 4) IS NOT NULL))
(5 rows)

-- select mid with group by having (result)
--Testcase 1554:
SELECT count(value1), mid(str2, 2, 4) FROM s3 GROUP BY mid(str2, 2, 4), str2 HAVING mid(str2, 2, 4) IS NOT NULL;
 count | mid  
-------+------
     6 |   XY
(1 row)

-- select mid with group by index having (result)
--Testcase 1555:
SELECT value1, mid(str2, 2, 4) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | mid  
--------+------
    1.1 |   XY
    2.2 |   XY
    3.3 |   XY
(3 rows)

-- ===============================================================================
-- test oct()
-- ===============================================================================
-- select oct (stub function, explain)
--Testcase 1556:
EXPLAIN VERBOSE
SELECT oct(value2), oct(value4) FROM s3;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.40 rows=2560 width=64)
   Output: oct((value2)::bigint), oct((value4)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select oct (stub function, result)
--Testcase 1557:
SELECT oct(value2), oct(value4) FROM s3;
ERROR:  stub oct(bigint) is called
CONTEXT:  PL/pgSQL function oct(bigint) line 3 at RAISE
-- select oct (stub function, not pushdown constraints, explain)
--Testcase 1558:
EXPLAIN VERBOSE
SELECT value1, oct(value4) FROM s3 WHERE to_hex(value2) = '64';
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..144.40 rows=11 width=40)
   Output: value1, oct((value4)::bigint)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select oct (stub function, not pushdown constraints, result)
--Testcase 1559:
SELECT value1, oct(value4) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub oct(bigint) is called
CONTEXT:  PL/pgSQL function oct(bigint) line 3 at RAISE
-- select oct (stub function, pushdown constraints, explain)
--Testcase 1560:
EXPLAIN VERBOSE
SELECT value1, oct(value4) FROM s3 WHERE value2 != 200;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.04 rows=2264 width=40)
   Output: value1, oct((value4)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value4` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select oct (stub function, pushdown constraints, result)
--Testcase 1561:
SELECT value1, oct(value4) FROM s3 WHERE value2 != 200;
ERROR:  stub oct(bigint) is called
CONTEXT:  PL/pgSQL function oct(bigint) line 3 at RAISE
-- select oct with non pushdown func and explicit constant (explain)
--Testcase 1562:
EXPLAIN VERBOSE
SELECT oct(value4), pi(), 4.1 FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2925 width=72)
   Output: oct((value4)::bigint), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select oct with non pushdown func and explicit constant (result)
--Testcase 1563:
SELECT oct(value4), pi(), 4.1 FROM s3;
ERROR:  stub oct(bigint) is called
CONTEXT:  PL/pgSQL function oct(bigint) line 3 at RAISE
-- select oct with order by (explain)
--Testcase 1564:
EXPLAIN VERBOSE
SELECT value1, oct(value4) FROM s3 ORDER BY oct(value4);
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=40)
   Output: value1, oct((value4)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value4` FROM `mysql_fdw_regress`.`s3` ORDER BY oct(`value4`) IS NULL ASC, oct(`value4`) ASC
(4 rows)

-- select oct with order by (result)
--Testcase 1565:
SELECT value1, oct(value4) FROM s3 ORDER BY oct(value4);
ERROR:  stub oct(bigint) is called
CONTEXT:  PL/pgSQL function oct(bigint) line 3 at RAISE
-- select oct with order by index (result)
--Testcase 1566:
SELECT value1, oct(value4) FROM s3 ORDER BY 2,1;
ERROR:  stub oct(bigint) is called
CONTEXT:  PL/pgSQL function oct(bigint) line 3 at RAISE
-- select oct with order by index (result)
--Testcase 1567:
SELECT value1, oct(value4) FROM s3 ORDER BY 1,2;
ERROR:  stub oct(bigint) is called
CONTEXT:  PL/pgSQL function oct(bigint) line 3 at RAISE
-- select oct with group by (explain)
--Testcase 1568:
EXPLAIN VERBOSE
SELECT count(value1), oct(value4) FROM s3 GROUP BY oct(value4);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (oct((value4)::bigint))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), oct(`value4`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select oct with group by (result)
--Testcase 1569:
SELECT count(value1), oct(value4) FROM s3 GROUP BY oct(value4);
 count |          oct           
-------+------------------------
     3 | 1777777777777777777634
     3 | 1777777777777777777470
(2 rows)

-- select oct with group by index (result)
--Testcase 1570:
SELECT value1, oct(value4) FROM s3 GROUP BY 2,1;
 value1 |          oct           
--------+------------------------
    0.1 | 1777777777777777777634
    0.2 | 1777777777777777777634
    0.3 | 1777777777777777777634
    1.1 | 1777777777777777777470
    2.2 | 1777777777777777777470
    3.3 | 1777777777777777777470
(6 rows)

-- select oct with group by having (explain)
--Testcase 1571:
EXPLAIN VERBOSE
SELECT count(value1), oct(value4) FROM s3 GROUP BY oct(value4), value4 HAVING oct(value4) IS NOT NULL;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=44)
   Output: (count(value1)), (oct((value4)::bigint)), value4
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), oct(`value4`), `value4` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((oct(`value4`) IS NOT NULL))
(5 rows)

-- select oct with group by having (result)
--Testcase 1572:
SELECT count(value1), oct(value4) FROM s3 GROUP BY oct(value4), value4 HAVING oct(value4) IS NOT NULL;
 count |          oct           
-------+------------------------
     3 | 1777777777777777777634
     3 | 1777777777777777777470
(2 rows)

-- select oct with group by index having (result)
--Testcase 1573:
SELECT value1, oct(value4) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |          oct           
--------+------------------------
    1.1 | 1777777777777777777470
    2.2 | 1777777777777777777470
    3.3 | 1777777777777777777470
(3 rows)

-- ===============================================================================
-- test octet_length()
-- ===============================================================================
-- select octet_length (stub function, explain)
--Testcase 1574:
EXPLAIN VERBOSE
SELECT octet_length(str1), octet_length(str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=8)
   Output: octet_length(str1), octet_length(str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select octet_length (stub function, result)
--Testcase 1575:
SELECT octet_length(str1), octet_length(str2) FROM s3;
 octet_length | octet_length 
--------------+--------------
            9 |            9
            9 |            9
            9 |            9
            9 |            9
            9 |            9
            9 |            9
(6 rows)

-- select octet_length (stub function, not pushdown constraints, explain)
--Testcase 1576:
EXPLAIN VERBOSE
SELECT value1, octet_length(str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=12)
   Output: value1, octet_length(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select octet_length (stub function, not pushdown constraints, result)
--Testcase 1577:
SELECT value1, octet_length(str1) FROM s3 WHERE to_hex(value2) = '64';
 value1 | octet_length 
--------+--------------
    0.1 |            9
    0.2 |            9
    0.3 |            9
(3 rows)

-- select octet_length (stub function, pushdown constraints, explain)
--Testcase 1578:
EXPLAIN VERBOSE
SELECT value1, octet_length(str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=12)
   Output: value1, octet_length(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select octet_length (stub function, pushdown constraints, result)
--Testcase 1579:
SELECT value1, octet_length(str1) FROM s3 WHERE value2 != 200;
 value1 | octet_length 
--------+--------------
    0.1 |            9
    0.2 |            9
    0.3 |            9
(3 rows)

-- select octet_length with non pushdown func and explicit constant (explain)
--Testcase 1580:
EXPLAIN VERBOSE
SELECT octet_length(str1), pi(), 4.1 FROM s3;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: octet_length(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select octet_length with non pushdown func and explicit constant (result)
--Testcase 1581:
SELECT octet_length(str1), pi(), 4.1 FROM s3;
 octet_length |        pi         | ?column? 
--------------+-------------------+----------
            9 | 3.141592653589793 |      4.1
            9 | 3.141592653589793 |      4.1
            9 | 3.141592653589793 |      4.1
            9 | 3.141592653589793 |      4.1
            9 | 3.141592653589793 |      4.1
            9 | 3.141592653589793 |      4.1
(6 rows)

-- select octet_length with order by (explain)
--Testcase 1582:
EXPLAIN VERBOSE
SELECT value1, octet_length(str1) FROM s3 ORDER BY octet_length(str1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, octet_length(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY octet_length(`str1`) IS NULL ASC, octet_length(`str1`) ASC
(4 rows)

-- select octet_length with order by (result)
--Testcase 1583:
SELECT value1, octet_length(str1) FROM s3 ORDER BY octet_length(str1);
 value1 | octet_length 
--------+--------------
    0.1 |            9
    0.2 |            9
    0.3 |            9
    1.1 |            9
    2.2 |            9
    3.3 |            9
(6 rows)

-- select octet_length with order by index (result)
--Testcase 1584:
SELECT value1, octet_length(str1) FROM s3 ORDER BY 2,1;
 value1 | octet_length 
--------+--------------
    0.1 |            9
    0.2 |            9
    0.3 |            9
    1.1 |            9
    2.2 |            9
    3.3 |            9
(6 rows)

-- select octet_length with order by index (result)
--Testcase 1585:
SELECT value1, octet_length(str1) FROM s3 ORDER BY 1,2;
 value1 | octet_length 
--------+--------------
    0.1 |            9
    0.2 |            9
    0.3 |            9
    1.1 |            9
    2.2 |            9
    3.3 |            9
(6 rows)

-- select octet_length with group by (explain)
--Testcase 1586:
EXPLAIN VERBOSE
SELECT count(value1), octet_length(str1) FROM s3 GROUP BY octet_length(str1);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (octet_length(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), octet_length(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select octet_length with group by (result)
--Testcase 1587:
SELECT count(value1), octet_length(str1) FROM s3 GROUP BY octet_length(str1);
 count | octet_length 
-------+--------------
     6 |            9
(1 row)

-- select octet_length with group by index (result)
--Testcase 1588:
SELECT value1, octet_length(str1) FROM s3 GROUP BY 2,1;
 value1 | octet_length 
--------+--------------
    0.1 |            9
    0.2 |            9
    0.3 |            9
    1.1 |            9
    2.2 |            9
    3.3 |            9
(6 rows)

-- select octet_length with group by having (explain)
--Testcase 1589:
EXPLAIN VERBOSE
SELECT count(value1), octet_length(str1) FROM s3 GROUP BY octet_length(str1), str1 HAVING octet_length(str1) IS NOT NULL;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=44)
   Output: (count(value1)), (octet_length(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), octet_length(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((octet_length(`str1`) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select octet_length with group by having (result)
--Testcase 1590:
SELECT count(value1), octet_length(str1) FROM s3 GROUP BY octet_length(str1), str1 HAVING octet_length(str1) IS NOT NULL;
 count | octet_length 
-------+--------------
     6 |            9
(1 row)

-- select octet_length with group by index having (result)
--Testcase 1591:
SELECT value1, octet_length(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | octet_length 
--------+--------------
    1.1 |            9
    2.2 |            9
    3.3 |            9
(3 rows)

-- ===============================================================================
-- test ord()
-- ===============================================================================
-- select ord (stub function, explain)
--Testcase 1592:
EXPLAIN VERBOSE
SELECT ord(value1), ord(value2), ord(value3), ord(value4), ord(str1), ord(str2) FROM s3;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.90 rows=731 width=24)
   Output: ord(value1), ord(value2), ord(value3), ord(value4), ord(str1), ord(str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `value3`, `value4`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ord (stub function, result)
--Testcase 1593:
SELECT ord(value1), ord(value2), ord(value3), ord(value4), ord(str1), ord(str2) FROM s3;
ERROR:  stub ord(anyelement) is called
CONTEXT:  PL/pgSQL function ord(anyelement) line 3 at RAISE
-- select ord (stub function, not pushdown constraints, explain)
--Testcase 1594:
EXPLAIN VERBOSE
SELECT value1, ord(str2) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=12)
   Output: value1, ord(str2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ord (stub function, not pushdown constraints, result)
--Testcase 1595:
SELECT value1, ord(str2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub ord(anyelement) is called
CONTEXT:  PL/pgSQL function ord(anyelement) line 3 at RAISE
-- select ord (stub function, pushdown constraints, explain)
--Testcase 1596:
EXPLAIN VERBOSE
SELECT value1, ord(str2) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=12)
   Output: value1, ord(str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select ord (stub function, pushdown constraints, result)
--Testcase 1597:
SELECT value1, ord(str2) FROM s3 WHERE value2 != 200;
ERROR:  stub ord(anyelement) is called
CONTEXT:  PL/pgSQL function ord(anyelement) line 3 at RAISE
-- select ord with non pushdown func and explicit constant (explain)
--Testcase 1598:
EXPLAIN VERBOSE
SELECT ord(str2), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: ord(str2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ord with non pushdown func and explicit constant (result)
--Testcase 1599:
SELECT ord(str2), pi(), 4.1 FROM s3;
ERROR:  stub ord(anyelement) is called
CONTEXT:  PL/pgSQL function ord(anyelement) line 3 at RAISE
-- select ord with order by (explain)
--Testcase 1600:
EXPLAIN VERBOSE
SELECT value1, ord(str2) FROM s3 ORDER BY ord(str2);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, ord(str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY ord(`str2`) IS NULL ASC, ord(`str2`) ASC
(4 rows)

-- select ord with order by (result)
--Testcase 1601:
SELECT value1, ord(str2) FROM s3 ORDER BY ord(str2);
ERROR:  stub ord(anyelement) is called
CONTEXT:  PL/pgSQL function ord(anyelement) line 3 at RAISE
-- select ord with order by index (result)
--Testcase 1602:
SELECT value1, ord(str2) FROM s3 ORDER BY 2,1;
ERROR:  stub ord(anyelement) is called
CONTEXT:  PL/pgSQL function ord(anyelement) line 3 at RAISE
-- select ord with order by index (result)
--Testcase 1603:
SELECT value1, ord(str2) FROM s3 ORDER BY 1,2;
ERROR:  stub ord(anyelement) is called
CONTEXT:  PL/pgSQL function ord(anyelement) line 3 at RAISE
-- select ord with group by (explain)
--Testcase 1604:
EXPLAIN VERBOSE
SELECT count(value1), ord(str2) FROM s3 GROUP BY ord(str2);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (ord(str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ord(`str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select ord with group by (result)
--Testcase 1605:
SELECT count(value1), ord(str2) FROM s3 GROUP BY ord(str2);
 count | ord 
-------+-----
     6 |  32
(1 row)

-- select ord with group by index (result)
--Testcase 1606:
SELECT value1, ord(str2) FROM s3 GROUP BY 2,1;
 value1 | ord 
--------+-----
    0.1 |  32
    0.2 |  32
    0.3 |  32
    1.1 |  32
    2.2 |  32
    3.3 |  32
(6 rows)

-- select ord with group by having (explain)
--Testcase 1607:
EXPLAIN VERBOSE
SELECT count(value1), ord(str2) FROM s3 GROUP BY ord(str2), str2 HAVING ord(str2) IS NOT NULL;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=44)
   Output: (count(value1)), (ord(str2)), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ord(`str2`), `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((ord(`str2`) IS NOT NULL))
(5 rows)

-- select ord with group by having (result)
--Testcase 1608:
SELECT count(value1), ord(str2) FROM s3 GROUP BY ord(str2), str2 HAVING ord(str2) IS NOT NULL;
 count | ord 
-------+-----
     6 |  32
(1 row)

-- select ord with group by index having (result)
--Testcase 1609:
SELECT value1, ord(str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | ord 
--------+-----
    1.1 |  32
    2.2 |  32
    3.3 |  32
(3 rows)

-- ===============================================================================
-- test position()
-- ===============================================================================
-- select position (stub function, explain)
--Testcase 1610:
EXPLAIN VERBOSE
SELECT position('XYZ' IN str1), position('XYZ' IN str2) FROM s3;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=8)
   Output: POSITION(('XYZ'::text) IN (str1)), POSITION(('XYZ'::text) IN (str2))
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select position (stub function, result)
--Testcase 1611:
SELECT position('XYZ' IN str1), position('XYZ' IN str2) FROM s3;
 position | position 
----------+----------
        4 |        4
        4 |        4
        4 |        4
        4 |        4
        4 |        4
        4 |        4
(6 rows)

-- select position (stub function, not pushdown constraints, explain)
--Testcase 1612:
EXPLAIN VERBOSE
SELECT value1, position('XYZ' IN str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=12)
   Output: value1, POSITION(('XYZ'::text) IN (str1))
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select position (stub function, not pushdown constraints, result)
--Testcase 1613:
SELECT value1, position('XYZ' IN str1) FROM s3 WHERE to_hex(value2) = '64';
 value1 | position 
--------+----------
    0.1 |        4
    0.2 |        4
    0.3 |        4
(3 rows)

-- select position (stub function, pushdown constraints, explain)
--Testcase 1614:
EXPLAIN VERBOSE
SELECT value1, position('XYZ' IN str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=12)
   Output: value1, POSITION(('XYZ'::text) IN (str1))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select position (stub function, pushdown constraints, result)
--Testcase 1615:
SELECT value1, position('XYZ' IN str1) FROM s3 WHERE value2 != 200;
 value1 | position 
--------+----------
    0.1 |        4
    0.2 |        4
    0.3 |        4
(3 rows)

-- select position with non pushdown func and explicit constant (explain)
--Testcase 1616:
EXPLAIN VERBOSE
SELECT position('XYZ' IN str1), pi(), 4.1 FROM s3;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: POSITION(('XYZ'::text) IN (str1)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select position with non pushdown func and explicit constant (result)
--Testcase 1617:
SELECT position('XYZ' IN str1), pi(), 4.1 FROM s3;
 position |        pi         | ?column? 
----------+-------------------+----------
        4 | 3.141592653589793 |      4.1
        4 | 3.141592653589793 |      4.1
        4 | 3.141592653589793 |      4.1
        4 | 3.141592653589793 |      4.1
        4 | 3.141592653589793 |      4.1
        4 | 3.141592653589793 |      4.1
(6 rows)

-- select position with order by (explain)
--Testcase 1618:
EXPLAIN VERBOSE
SELECT value1, position('XYZ' IN str1) FROM s3 ORDER BY position('XYZ' IN str1);
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, POSITION(('XYZ'::text) IN (str1))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY position('XYZ' IN `str1`) IS NULL ASC, position('XYZ' IN `str1`) ASC
(4 rows)

-- select position with order by (result)
--Testcase 1619:
SELECT value1, position('XYZ' IN str1) FROM s3 ORDER BY position('XYZ' IN str1);
 value1 | position 
--------+----------
    0.1 |        4
    0.2 |        4
    0.3 |        4
    1.1 |        4
    2.2 |        4
    3.3 |        4
(6 rows)

-- select position with order by index (result)
--Testcase 1620:
SELECT value1, position('XYZ' IN str1) FROM s3 ORDER BY 2,1;
 value1 | position 
--------+----------
    0.1 |        4
    0.2 |        4
    0.3 |        4
    1.1 |        4
    2.2 |        4
    3.3 |        4
(6 rows)

-- select position with order by index (result)
--Testcase 1621:
SELECT value1, position('XYZ' IN str1) FROM s3 ORDER BY 1,2;
 value1 | position 
--------+----------
    0.1 |        4
    0.2 |        4
    0.3 |        4
    1.1 |        4
    2.2 |        4
    3.3 |        4
(6 rows)

-- select position with group by (explain)
--Testcase 1622:
EXPLAIN VERBOSE
SELECT count(value1), position('XYZ' IN str1) FROM s3 GROUP BY position('XYZ' IN str1);
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (POSITION(('XYZ'::text) IN (str1)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), position('XYZ' IN `str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select position with group by (result)
--Testcase 1623:
SELECT count(value1), position('XYZ' IN str1) FROM s3 GROUP BY position('XYZ' IN str1);
 count | position 
-------+----------
     6 |        4
(1 row)

-- select position with group by index (result)
--Testcase 1624:
SELECT value1, position('XYZ' IN str1) FROM s3 GROUP BY 2,1;
 value1 | position 
--------+----------
    0.1 |        4
    0.2 |        4
    0.3 |        4
    1.1 |        4
    2.2 |        4
    3.3 |        4
(6 rows)

-- select position with group by having (explain)
--Testcase 1625:
EXPLAIN VERBOSE
SELECT count(value1), position('XYZ' IN str1) FROM s3 GROUP BY position('XYZ' IN str1), str1 HAVING position('XYZ' IN str1) IS NOT NULL;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=44)
   Output: (count(value1)), (POSITION(('XYZ'::text) IN (str1))), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), position('XYZ' IN `str1`), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((position('XYZ' IN `str1`) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select position with group by having (result)
--Testcase 1626:
SELECT count(value1), position('XYZ' IN str1) FROM s3 GROUP BY position('XYZ' IN str1), str1 HAVING position('XYZ' IN str1) IS NOT NULL;
 count | position 
-------+----------
     6 |        4
(1 row)

-- select position with group by index having (result)
--Testcase 1627:
SELECT value1, position('XYZ' IN str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | position 
--------+----------
    1.1 |        4
    2.2 |        4
    3.3 |        4
(3 rows)

-- ===============================================================================
-- test quote()
-- ===============================================================================
-- select quote (stub function, explain)
--Testcase 1628:
EXPLAIN VERBOSE
SELECT quote(str1), quote(str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: quote(str1), quote(str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select quote (stub function, result)
--Testcase 1629:
SELECT quote(str1), quote(str2) FROM s3;
ERROR:  stub quote(text) is called
CONTEXT:  PL/pgSQL function quote(text) line 3 at RAISE
-- select quote (stub function, not pushdown constraints, explain)
--Testcase 1630:
EXPLAIN VERBOSE
SELECT value1, quote(str2) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, quote(str2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select quote (stub function, not pushdown constraints, result)
--Testcase 1631:
SELECT value1, quote(str2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub quote(text) is called
CONTEXT:  PL/pgSQL function quote(text) line 3 at RAISE
-- select quote (stub function, pushdown constraints, explain)
--Testcase 1632:
EXPLAIN VERBOSE
SELECT value1, quote(str2) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, quote(str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select quote (stub function, pushdown constraints, result)
--Testcase 1633:
SELECT value1, quote(str2) FROM s3 WHERE value2 != 200;
ERROR:  stub quote(text) is called
CONTEXT:  PL/pgSQL function quote(text) line 3 at RAISE
-- select quote with non pushdown func and explicit constant (explain)
--Testcase 1634:
EXPLAIN VERBOSE
SELECT quote(str2), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: quote(str2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select quote with non pushdown func and explicit constant (result)
--Testcase 1635:
SELECT quote(str2), pi(), 4.1 FROM s3;
ERROR:  stub quote(text) is called
CONTEXT:  PL/pgSQL function quote(text) line 3 at RAISE
-- select quote with order by (explain)
--Testcase 1636:
EXPLAIN VERBOSE
SELECT value1, quote(str2) FROM s3 ORDER BY quote(str2);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, quote(str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY quote(`str2`) IS NULL ASC, quote(`str2`) ASC
(4 rows)

-- select quote with order by (result)
--Testcase 1637:
SELECT value1, quote(str2) FROM s3 ORDER BY quote(str2);
ERROR:  stub quote(text) is called
CONTEXT:  PL/pgSQL function quote(text) line 3 at RAISE
-- select quote with order by index (result)
--Testcase 1638:
SELECT value1, quote(str2) FROM s3 ORDER BY 2,1;
ERROR:  stub quote(text) is called
CONTEXT:  PL/pgSQL function quote(text) line 3 at RAISE
-- select quote with order by index (result)
--Testcase 1639:
SELECT value1, quote(str2) FROM s3 ORDER BY 1,2;
ERROR:  stub quote(text) is called
CONTEXT:  PL/pgSQL function quote(text) line 3 at RAISE
-- select quote with group by (explain)
--Testcase 1640:
EXPLAIN VERBOSE
SELECT count(value1), quote(str2) FROM s3 GROUP BY quote(str2);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (quote(str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), quote(`str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select quote with group by (result)
--Testcase 1641:
SELECT count(value1), quote(str2) FROM s3 GROUP BY quote(str2);
 count |    quote    
-------+-------------
     6 | '   XYZ   '
(1 row)

-- select quote with group by index (result)
--Testcase 1642:
SELECT value1, quote(str2) FROM s3 GROUP BY 2,1;
 value1 |    quote    
--------+-------------
    0.1 | '   XYZ   '
    0.2 | '   XYZ   '
    0.3 | '   XYZ   '
    1.1 | '   XYZ   '
    2.2 | '   XYZ   '
    3.3 | '   XYZ   '
(6 rows)

-- select quote with group by having (explain)
--Testcase 1643:
EXPLAIN VERBOSE
SELECT count(value1), quote(str2) FROM s3 GROUP BY quote(str2), str2 HAVING quote(str2) IS NOT NULL;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (quote(str2)), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), quote(`str2`), `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((quote(`str2`) IS NOT NULL))
(5 rows)

-- select quote with group by having (result)
--Testcase 1644:
SELECT count(value1), quote(str2) FROM s3 GROUP BY quote(str2), str2 HAVING quote(str2) IS NOT NULL;
 count |    quote    
-------+-------------
     6 | '   XYZ   '
(1 row)

-- select quote with group by index having (result)
--Testcase 1645:
SELECT value1, quote(str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |    quote    
--------+-------------
    1.1 | '   XYZ   '
    2.2 | '   XYZ   '
    3.3 | '   XYZ   '
(3 rows)

-- ===============================================================================
-- test mysql_regexp_instr()
-- ===============================================================================
-- select mysql_regexp_instr (stub function, explain)
--Testcase 1646:
EXPLAIN VERBOSE
SELECT mysql_regexp_instr(str1, 'XY'), mysql_regexp_instr(str2, 'XYZ') FROM s3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=8)
   Output: mysql_regexp_instr(str1, 'XY'::text), mysql_regexp_instr(str2, 'XYZ'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_instr (stub function, result)
--Testcase 1647:
SELECT mysql_regexp_instr(str1, 'XY'), mysql_regexp_instr(str2, 'XYZ') FROM s3;
ERROR:  stub mysql_regexp_instr(text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text) line 3 at RAISE
-- select mysql_regexp_instr (stub function, explain)
--Testcase 1648:
EXPLAIN VERBOSE
SELECT mysql_regexp_instr(str1, 'XY', 3), mysql_regexp_instr(str2, 'XYZ', 3) FROM s3;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=8)
   Output: mysql_regexp_instr(str1, 'XY'::text, 3), mysql_regexp_instr(str2, 'XYZ'::text, 3)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_instr (stub function, result)
--Testcase 1649:
SELECT mysql_regexp_instr(str1, 'XY', 3), mysql_regexp_instr(str2, 'XYZ', 3) FROM s3;
ERROR:  stub mysql_regexp_instr(text, text, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer) line 3 at RAISE
-- select mysql_regexp_instr (stub function, explain)
--Testcase 1650:
EXPLAIN VERBOSE
SELECT mysql_regexp_instr(str1, 'XY', 3, 1), mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=8)
   Output: mysql_regexp_instr(str1, 'XY'::text, 3, 1), mysql_regexp_instr(str2, 'XYZ'::text, 3, 1)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_instr (stub function, result)
--Testcase 1651:
SELECT mysql_regexp_instr(str1, 'XY', 3, 1), mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3;
ERROR:  stub mysql_regexp_instr(text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_instr (stub function, explain)
--Testcase 1652:
EXPLAIN VERBOSE
SELECT mysql_regexp_instr(str1, 'XY', 3, 1, 1), mysql_regexp_instr(str2, 'XYZ', 3, 1, 1) FROM s3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=8)
   Output: mysql_regexp_instr(str1, 'XY'::text, 3, 1, 1), mysql_regexp_instr(str2, 'XYZ'::text, 3, 1, 1)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_instr (stub function, result)
--Testcase 1653:
SELECT mysql_regexp_instr(str1, 'XY', 3, 1, 1), mysql_regexp_instr(str2, 'XYZ', 3, 1, 1) FROM s3;
ERROR:  stub mysql_regexp_instr(text, text, int, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer,integer) line 3 at RAISE
-- select mysql_regexp_instr (stub function, explain)
--Testcase 1654:
EXPLAIN VERBOSE
SELECT mysql_regexp_instr(str1, 'xy', 3, 1, 1, 'i'), mysql_regexp_instr(str2, 'xyz', 3, 1, 1, 'i') FROM s3;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=8)
   Output: mysql_regexp_instr(str1, 'xy'::text, 3, 1, 1, 'i'::text), mysql_regexp_instr(str2, 'xyz'::text, 3, 1, 1, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_instr (stub function, result)
--Testcase 1655:
SELECT mysql_regexp_instr(str1, 'xy', 3, 1, 1, 'i'), mysql_regexp_instr(str2, 'xyz', 3, 1, 1, 'i') FROM s3;
ERROR:  stub mysql_regexp_instr(text, text, int, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_instr (stub function, not pushdown constraints, explain)
--Testcase 1656:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=12)
   Output: value1, mysql_regexp_instr(str2, 'XYZ'::text, 3, 1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select mysql_regexp_instr (stub function, not pushdown constraints, result)
--Testcase 1657:
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub mysql_regexp_instr(text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_instr (stub function, pushdown constraints, explain)
--Testcase 1658:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=12)
   Output: value1, mysql_regexp_instr(str2, 'XYZ'::text, 3, 1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select mysql_regexp_instr (stub function, pushdown constraints, result)
--Testcase 1659:
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3 WHERE value2 != 200;
ERROR:  stub mysql_regexp_instr(text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_instr with non pushdown func and explicit constant (explain)
--Testcase 1660:
EXPLAIN VERBOSE
SELECT mysql_regexp_instr(str2, 'XYZ', 3, 1), pi(), 4.1 FROM s3;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: mysql_regexp_instr(str2, 'XYZ'::text, 3, 1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_instr with non pushdown func and explicit constant (result)
--Testcase 1661:
SELECT mysql_regexp_instr(str2, 'XYZ', 3, 1), pi(), 4.1 FROM s3;
ERROR:  stub mysql_regexp_instr(text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_instr with order by (explain)
--Testcase 1662:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3 ORDER BY mysql_regexp_instr(str2, 'XYZ', 3, 1);
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, mysql_regexp_instr(str2, 'XYZ'::text, 3, 1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY regexp_instr(`str2`, 'XYZ', 3, 1) IS NULL ASC, regexp_instr(`str2`, 'XYZ', 3, 1) ASC
(4 rows)

-- select mysql_regexp_instr with order by (result)
--Testcase 1663:
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3 ORDER BY mysql_regexp_instr(str2, 'XYZ', 3, 1);
ERROR:  stub mysql_regexp_instr(text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_instr with order by index (result)
--Testcase 1664:
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3 ORDER BY 2,1;
ERROR:  stub mysql_regexp_instr(text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_instr with order by index (result)
--Testcase 1665:
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 1) FROM s3 ORDER BY 1,2;
ERROR:  stub mysql_regexp_instr(text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_instr(text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_instr with group by (explain)
--Testcase 1666:
EXPLAIN VERBOSE
SELECT count(value1), mysql_regexp_instr(str2, 'XYZ', 3, 0) FROM s3 GROUP BY mysql_regexp_instr(str2, 'XYZ', 3, 0);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (mysql_regexp_instr(str2, 'XYZ'::text, 3, 0))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), regexp_instr(`str2`, 'XYZ', 3, 0) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select mysql_regexp_instr with group by (result)
--Testcase 1667:
SELECT count(value1), mysql_regexp_instr(str2, 'XYZ', 3, 0) FROM s3 GROUP BY mysql_regexp_instr(str2, 'XYZ', 3, 0);
 count | mysql_regexp_instr 
-------+--------------------
     6 |                  4
(1 row)

-- select mysql_regexp_instr with group by index (result)
--Testcase 1668:
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 0) FROM s3 GROUP BY 2,1;
 value1 | mysql_regexp_instr 
--------+--------------------
    0.1 |                  4
    0.2 |                  4
    0.3 |                  4
    1.1 |                  4
    2.2 |                  4
    3.3 |                  4
(6 rows)

-- select mysql_regexp_instr with group by having (explain)
--Testcase 1669:
EXPLAIN VERBOSE
SELECT count(value1), mysql_regexp_instr(str2, 'XYZ', 3, 0) FROM s3 GROUP BY mysql_regexp_instr(str2, 'XYZ', 3, 0), str2 HAVING mysql_regexp_instr(str2, 'XYZ', 3, 0) IS NOT NULL;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=44)
   Output: (count(value1)), (mysql_regexp_instr(str2, 'XYZ'::text, 3, 0)), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), regexp_instr(`str2`, 'XYZ', 3, 0), `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((regexp_instr(`str2`, 'XYZ', 3, 0) IS NOT NULL))
(5 rows)

-- select mysql_regexp_instr with group by having (result)
--Testcase 1670:
SELECT count(value1), mysql_regexp_instr(str2, 'XYZ', 3, 0) FROM s3 GROUP BY mysql_regexp_instr(str2, 'XYZ', 3, 0), str2 HAVING mysql_regexp_instr(str2, 'XYZ', 3, 0) IS NOT NULL;
 count | mysql_regexp_instr 
-------+--------------------
     6 |                  4
(1 row)

-- select mysql_regexp_instr with group by index having (result)
--Testcase 1671:
SELECT value1, mysql_regexp_instr(str2, 'XYZ', 3, 0) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | mysql_regexp_instr 
--------+--------------------
    1.1 |                  4
    2.2 |                  4
    3.3 |                  4
(3 rows)

-- ===============================================================================
-- test regexp_like()
-- ===============================================================================
-- select mysql_regexp_like (stub function, explain)
--Testcase 1674:
EXPLAIN VERBOSE
SELECT mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=4)
   Output: mysql_regexp_like('   XyZ   '::text, str2, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_like (stub function, result)
--Testcase 1675:
SELECT mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3;
ERROR:  stub mysql_regexp_like(text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_like(text,text,text) line 3 at RAISE
-- select mysql_regexp_like (stub function, not pushdown constraints, explain)
--Testcase 1676:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=12)
   Output: value1, mysql_regexp_like('   XyZ   '::text, str2, 'i'::text)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select mysql_regexp_like (stub function, not pushdown constraints, result)
--Testcase 1677:
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub mysql_regexp_like(text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_like(text,text,text) line 3 at RAISE
-- select mysql_regexp_like (stub function, pushdown constraints, explain)
--Testcase 1678:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=12)
   Output: value1, mysql_regexp_like('   XyZ   '::text, str2, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select mysql_regexp_like (stub function, pushdown constraints, result)
--Testcase 1679:
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 WHERE value2 != 200;
ERROR:  stub mysql_regexp_like(text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_like(text,text,text) line 3 at RAISE
-- select mysql_regexp_like with non pushdown func and explicit constant (explain)
--Testcase 1680:
EXPLAIN VERBOSE
SELECT mysql_regexp_like('   XyZ   ', str2, 'i'), pi(), 4.1 FROM s3;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=44)
   Output: mysql_regexp_like('   XyZ   '::text, str2, 'i'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_like with non pushdown func and explicit constant (result)
--Testcase 1681:
SELECT mysql_regexp_like('   XyZ   ', str2, 'i'), pi(), 4.1 FROM s3;
ERROR:  stub mysql_regexp_like(text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_like(text,text,text) line 3 at RAISE
-- select mysql_regexp_like with order by (explain)
--Testcase 1682:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 ORDER BY mysql_regexp_like('   XyZ   ', str2, 'i');
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, mysql_regexp_like('   XyZ   '::text, str2, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY regexp_like('   XyZ   ', `str2`, 'i') IS NULL ASC, regexp_like('   XyZ   ', `str2`, 'i') ASC
(4 rows)

-- select mysql_regexp_like with order by (result)
--Testcase 1683:
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 ORDER BY mysql_regexp_like('   XyZ   ', str2, 'i');
ERROR:  stub mysql_regexp_like(text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_like(text,text,text) line 3 at RAISE
-- select mysql_regexp_like with order by index (result)
--Testcase 1684:
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 ORDER BY 2,1;
ERROR:  stub mysql_regexp_like(text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_like(text,text,text) line 3 at RAISE
-- select mysql_regexp_like with order by index (result)
--Testcase 1685:
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 ORDER BY 1,2;
ERROR:  stub mysql_regexp_like(text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_like(text,text,text) line 3 at RAISE
-- select mysql_regexp_like with group by (explain)
--Testcase 1686:
EXPLAIN VERBOSE
SELECT count(value1), mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 GROUP BY mysql_regexp_like('   XyZ   ', str2, 'i');
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (mysql_regexp_like('   XyZ   '::text, str2, 'i'::text))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), regexp_like('   XyZ   ', `str2`, 'i') FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select mysql_regexp_like with group by (result)
--Testcase 1687:
SELECT count(value1), mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 GROUP BY mysql_regexp_like('   XyZ   ', str2, 'i');
 count | mysql_regexp_like 
-------+-------------------
     6 |                 1
(1 row)

-- select mysql_regexp_like with group by index (result)
--Testcase 1688:
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 GROUP BY 2,1;
 value1 | mysql_regexp_like 
--------+-------------------
    0.1 |                 1
    0.2 |                 1
    0.3 |                 1
    1.1 |                 1
    2.2 |                 1
    3.3 |                 1
(6 rows)

-- select mysql_regexp_like with group by having (explain)
--Testcase 1689:
EXPLAIN VERBOSE
SELECT count(value1), mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 GROUP BY mysql_regexp_like('   XyZ   ', str2, 'i'), str2 HAVING mysql_regexp_like('   XyZ   ', str2, 'i') > 0;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=44)
   Output: (count(value1)), (mysql_regexp_like('   XyZ   '::text, str2, 'i'::text)), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), regexp_like('   XyZ   ', `str2`, 'i'), `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((regexp_like('   XyZ   ', `str2`, 'i') > 0))
(5 rows)

-- select mysql_regexp_like with group by having (result)
--Testcase 1690:
SELECT count(value1), mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 GROUP BY mysql_regexp_like('   XyZ   ', str2, 'i'), str2 HAVING mysql_regexp_like('   XyZ   ', str2, 'i') > 0;
 count | mysql_regexp_like 
-------+-------------------
     6 |                 1
(1 row)

-- select mysql_regexp_like with group by index having (result)
--Testcase 1691:
SELECT value1, mysql_regexp_like('   XyZ   ', str2, 'i') FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | mysql_regexp_like 
--------+-------------------
    1.1 |                 1
    2.2 |                 1
    3.3 |                 1
(3 rows)

-- ===============================================================================
-- test mysql_regexp_replace()
-- ===============================================================================
-- select mysql_regexp_replace (stub function, explain)
--Testcase 1692:
EXPLAIN VERBOSE
SELECT mysql_regexp_replace(str1, 'X', 'x') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_replace(str1, 'X'::text, 'x'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_replace (stub function, result)
--Testcase 1693:
SELECT mysql_regexp_replace(str1, 'X', 'x') FROM s3;
ERROR:  stub mysql_regexp_replace(text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text) line 3 at RAISE
-- select mysql_regexp_replace (stub function, explain)
--Testcase 1694:
EXPLAIN VERBOSE
SELECT mysql_regexp_replace(str1, 'Y', 'y', 3) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_replace(str1, 'Y'::text, 'y'::text, 3)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_replace (stub function, result)
--Testcase 1695:
SELECT mysql_regexp_replace(str1, 'Y', 'y', 3) FROM s3;
ERROR:  stub mysql_regexp_replace(text, text, text, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer) line 3 at RAISE
-- select mysql_regexp_replace (stub function, explain)
--Testcase 1696:
EXPLAIN VERBOSE
SELECT mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_replace(str1, 'Y'::text, 'y'::text, 3, 3)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_replace (stub function, result)
--Testcase 1697:
SELECT mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3;
ERROR:  stub mysql_regexp_replace(text, text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_replace (stub function, explain)
--Testcase 1698:
EXPLAIN VERBOSE
SELECT mysql_regexp_replace(str1, 'y', 'K', 3, 0, 'i') FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_replace(str1, 'y'::text, 'K'::text, 3, 0, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_replace (stub function, result)
--Testcase 1699:
SELECT mysql_regexp_replace(str1, 'y', 'K', 3, 0, 'i') FROM s3;
ERROR:  stub mysql_regexp_replace(text, text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_replace (stub function, explain)
--Testcase 1700:
EXPLAIN VERBOSE
SELECT mysql_regexp_replace(str1, 'y', NULL, 3, 3, 'i') FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_replace(str1, 'y'::text, NULL::text, 3, 3, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_replace (stub function, result)
--Testcase 1701:
SELECT mysql_regexp_replace(str1, 'y', NULL, 3, 3, 'i') FROM s3;
ERROR:  stub mysql_regexp_replace(text, text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_replace (stub function, not pushdown constraints, explain)
--Testcase 1702:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, mysql_regexp_replace(str1, 'Y'::text, 'y'::text, 3, 3)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select mysql_regexp_replace (stub function, not pushdown constraints, result)
--Testcase 1703:
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub mysql_regexp_replace(text, text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_replace (stub function, pushdown constraints, explain)
--Testcase 1704:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, mysql_regexp_replace(str1, 'Y'::text, 'y'::text, 3, 3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select mysql_regexp_replace (stub function, pushdown constraints, result)
--Testcase 1705:
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 WHERE value2 != 200;
ERROR:  stub mysql_regexp_replace(text, text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_replace with non pushdown func and explicit constant (explain)
--Testcase 1706:
EXPLAIN VERBOSE
SELECT mysql_regexp_replace(str1, 'Y', 'y', 3, 3), pi(), 4.1 FROM s3;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: mysql_regexp_replace(str1, 'Y'::text, 'y'::text, 3, 3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_replace with non pushdown func and explicit constant (result)
--Testcase 1707:
SELECT mysql_regexp_replace(str1, 'Y', 'y', 3, 3), pi(), 4.1 FROM s3;
ERROR:  stub mysql_regexp_replace(text, text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_replace with order by (explain)
--Testcase 1708:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 ORDER BY mysql_regexp_replace(str1, 'Y', 'y', 3, 3);
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, mysql_regexp_replace(str1, 'Y'::text, 'y'::text, 3, 3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY regexp_replace(`str1`, 'Y', 'y', 3, 3) IS NULL ASC, regexp_replace(`str1`, 'Y', 'y', 3, 3) ASC
(4 rows)

-- select mysql_regexp_replace with order by (result)
--Testcase 1709:
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 ORDER BY mysql_regexp_replace(str1, 'Y', 'y', 3, 3);
ERROR:  stub mysql_regexp_replace(text, text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_replace with order by index (result)
--Testcase 1710:
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 ORDER BY 2,1;
ERROR:  stub mysql_regexp_replace(text, text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_replace with order by index (result)
--Testcase 1711:
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 ORDER BY 1,2;
ERROR:  stub mysql_regexp_replace(text, text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_replace(text,text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_replace with group by (explain)
--Testcase 1712:
EXPLAIN VERBOSE
SELECT count(value1), mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 GROUP BY mysql_regexp_replace(str1, 'Y', 'y', 3, 3);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (mysql_regexp_replace(str1, 'Y'::text, 'y'::text, 3, 3))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), regexp_replace(`str1`, 'Y', 'y', 3, 3) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select mysql_regexp_replace with group by (result)
--Testcase 1713:
SELECT count(value1), mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 GROUP BY mysql_regexp_replace(str1, 'Y', 'y', 3, 3);
 count | mysql_regexp_replace 
-------+----------------------
     6 | ---XYZ---
(1 row)

-- select mysql_regexp_replace with group by index (result)
--Testcase 1714:
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 GROUP BY 2,1;
 value1 | mysql_regexp_replace 
--------+----------------------
    0.1 | ---XYZ---
    0.2 | ---XYZ---
    0.3 | ---XYZ---
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(6 rows)

-- select mysql_regexp_replace with group by having (explain)
--Testcase 1715:
EXPLAIN VERBOSE
SELECT count(value1), mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 GROUP BY mysql_regexp_replace(str1, 'Y', 'y', 3, 3), str1 HAVING mysql_regexp_replace(str1, 'Y', 'y', 3, 3) IS NOT NULL;
                                                                                            QUERY PLAN                                                                                            
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (mysql_regexp_replace(str1, 'Y'::text, 'y'::text, 3, 3)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), regexp_replace(`str1`, 'Y', 'y', 3, 3), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((regexp_replace(`str1`, 'Y', 'y', 3, 3) IS NOT NULL))
(5 rows)

-- select mysql_regexp_replace with group by having (result)
--Testcase 1716:
SELECT count(value1), mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 GROUP BY mysql_regexp_replace(str1, 'Y', 'y', 3, 3), str1 HAVING mysql_regexp_replace(str1, 'Y', 'y', 3, 3) IS NOT NULL;
 count | mysql_regexp_replace 
-------+----------------------
     6 | ---XYZ---
(1 row)

-- select mysql_regexp_replace with group by index having (result)
--Testcase 1717:
SELECT value1, mysql_regexp_replace(str1, 'Y', 'y', 3, 3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | mysql_regexp_replace 
--------+----------------------
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(3 rows)

-- ===============================================================================
-- test mysql_regexp_substr()
-- ===============================================================================
-- select mysql_regexp_substr (stub function, explain)
--Testcase 1718:
EXPLAIN VERBOSE
SELECT mysql_regexp_substr(str1, 'XYZ') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_substr(str1, 'XYZ'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_substr (stub function, result)
--Testcase 1719:
SELECT mysql_regexp_substr(str1, 'XYZ') FROM s3;
ERROR:  stub mysql_regexp_substr(text, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text) line 3 at RAISE
-- select mysql_regexp_substr (stub function, explain)
--Testcase 1720:
EXPLAIN VERBOSE
SELECT mysql_regexp_substr(str1, 'XYZ', 3) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_substr(str1, 'XYZ'::text, 3)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_substr (stub function, result)
--Testcase 1721:
SELECT mysql_regexp_substr(str1, 'XYZ', 3) FROM s3;
ERROR:  stub mysql_regexp_substr(text, text, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer) line 3 at RAISE
-- select mysql_regexp_substr (stub function, explain)
--Testcase 1722:
EXPLAIN VERBOSE
SELECT mysql_regexp_substr(str2, 'XYZ', 4, 1) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_substr(str2, 'XYZ'::text, 4, 1)
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_substr (stub function, result)
--Testcase 1723:
SELECT mysql_regexp_substr(str2, 'XYZ', 4, 1) FROM s3;
ERROR:  stub mysql_regexp_substr(text, text, int, int) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer) line 3 at RAISE
-- select mysql_regexp_substr (stub function, explain)
--Testcase 1724:
EXPLAIN VERBOSE
SELECT mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_substr(str1, 'xyz'::text, 4, 1, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_substr (stub function, result)
--Testcase 1725:
SELECT mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3;
ERROR:  stub mysql_regexp_substr(text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_substr (stub function, explain)
--Testcase 1726:
EXPLAIN VERBOSE
SELECT mysql_regexp_substr(str1, NULL, 4, 1, 'i') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_regexp_substr(str1, NULL::text, 4, 1, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_substr (stub function, result)
--Testcase 1727:
SELECT mysql_regexp_substr(str1, NULL, 4, 1, 'i') FROM s3;
ERROR:  stub mysql_regexp_substr(text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_substr (stub function, not pushdown constraints, explain)
--Testcase 1728:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, mysql_regexp_substr(str1, 'xyz'::text, 4, 1, 'i'::text)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select mysql_regexp_substr (stub function, not pushdown constraints, result)
--Testcase 1729:
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub mysql_regexp_substr(text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_substr (stub function, pushdown constraints, explain)
--Testcase 1730:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, mysql_regexp_substr(str1, 'xyz'::text, 4, 1, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select mysql_regexp_substr (stub function, pushdown constraints, result)
--Testcase 1731:
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3 WHERE value2 != 200;
ERROR:  stub mysql_regexp_substr(text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_substr with non pushdown func and explicit constant (explain)
--Testcase 1732:
EXPLAIN VERBOSE
SELECT mysql_regexp_substr(str1, 'xyz', 4, 1, 'i'), pi(), 4.1 FROM s3;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: mysql_regexp_substr(str1, 'xyz'::text, 4, 1, 'i'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select mysql_regexp_substr with non pushdown func and explicit constant (result)
--Testcase 1733:
SELECT mysql_regexp_substr(str1, 'xyz', 4, 1, 'i'), pi(), 4.1 FROM s3;
ERROR:  stub mysql_regexp_substr(text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_substr with order by (explain)
--Testcase 1734:
EXPLAIN VERBOSE
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3 ORDER BY mysql_regexp_substr(str1, 'xyz', 4, 1, 'i');
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, mysql_regexp_substr(str1, 'xyz'::text, 4, 1, 'i'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY regexp_substr(`str1`, 'xyz', 4, 1, 'i') IS NULL ASC, regexp_substr(`str1`, 'xyz', 4, 1, 'i') ASC
(4 rows)

-- select mysql_regexp_substr with order by (result)
--Testcase 1735:
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3 ORDER BY mysql_regexp_substr(str1, 'xyz', 4, 1, 'i');
ERROR:  stub mysql_regexp_substr(text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_substr with order by index (result)
--Testcase 1736:
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3 ORDER BY 2,1;
ERROR:  stub mysql_regexp_substr(text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_substr with order by index (result)
--Testcase 1737:
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 1, 'i') FROM s3 ORDER BY 1,2;
ERROR:  stub mysql_regexp_substr(text, text, int, int, text) is called
CONTEXT:  PL/pgSQL function mysql_regexp_substr(text,text,integer,integer,text) line 3 at RAISE
-- select mysql_regexp_substr with group by (explain)
--Testcase 1738:
EXPLAIN VERBOSE
SELECT count(value1), mysql_regexp_substr(str1, 'xyz', 4, 0, 'i') FROM s3 GROUP BY mysql_regexp_substr(str1, 'xyz', 4, 0, 'i');
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (mysql_regexp_substr(str1, 'xyz'::text, 4, 0, 'i'::text))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), regexp_substr(`str1`, 'xyz', 4, 0, 'i') FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select mysql_regexp_substr with group by (result)
--Testcase 1739:
SELECT count(value1), mysql_regexp_substr(str1, 'xyz', 4, 0, 'i') FROM s3 GROUP BY mysql_regexp_substr(str1, 'xyz', 4, 0, 'i');
 count | mysql_regexp_substr 
-------+---------------------
     6 | XYZ
(1 row)

-- select mysql_regexp_substr with group by index (result)
--Testcase 1740:
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 0, 'i') FROM s3 GROUP BY 2,1;
 value1 | mysql_regexp_substr 
--------+---------------------
    0.1 | XYZ
    0.2 | XYZ
    0.3 | XYZ
    1.1 | XYZ
    2.2 | XYZ
    3.3 | XYZ
(6 rows)

-- select mysql_regexp_substr with group by having (explain)
--Testcase 1741:
EXPLAIN VERBOSE
SELECT count(value1), mysql_regexp_substr(str1, 'xyz', 4, 0, 'i') FROM s3 GROUP BY mysql_regexp_substr(str1, 'xyz', 4, 0, 'i'), str1 HAVING mysql_regexp_substr(str1, 'xyz', 4, 0, 'i') IS NOT NULL;
                                                                                             QUERY PLAN                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (mysql_regexp_substr(str1, 'xyz'::text, 4, 0, 'i'::text)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), regexp_substr(`str1`, 'xyz', 4, 0, 'i'), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((regexp_substr(`str1`, 'xyz', 4, 0, 'i') IS NOT NULL))
(5 rows)

-- select mysql_regexp_substr with group by having (result)
--Testcase 1742:
SELECT count(value1), mysql_regexp_substr(str1, 'xyz', 4, 0, 'i') FROM s3 GROUP BY mysql_regexp_substr(str1, 'xyz', 4, 0, 'i'), str1 HAVING mysql_regexp_substr(str1, 'xyz', 4, 0, 'i') IS NOT NULL;
 count | mysql_regexp_substr 
-------+---------------------
     6 | XYZ
(1 row)

-- select mysql_regexp_substr with group by index having (result)
--Testcase 1743:
SELECT value1, mysql_regexp_substr(str1, 'xyz', 4, 0, 'i') FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | mysql_regexp_substr 
--------+---------------------
    1.1 | XYZ
    2.2 | XYZ
    3.3 | XYZ
(3 rows)

-- ===============================================================================
-- test repeat()
-- ===============================================================================
-- select repeat (stub function, explain)
--Testcase 1744:
EXPLAIN VERBOSE
SELECT repeat(str1, 3), repeat(str2, 3) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: repeat(str1, 3), repeat(str2, 3)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select repeat (stub function, result)
--Testcase 1745:
SELECT repeat(str1, 3), repeat(str2, 3) FROM s3;
           repeat            |           repeat            
-----------------------------+-----------------------------
 ---XYZ------XYZ------XYZ--- |    XYZ      XYZ      XYZ   
 ---XYZ------XYZ------XYZ--- |    XYZ      XYZ      XYZ   
 ---XYZ------XYZ------XYZ--- |    XYZ      XYZ      XYZ   
 ---XYZ------XYZ------XYZ--- |    XYZ      XYZ      XYZ   
 ---XYZ------XYZ------XYZ--- |    XYZ      XYZ      XYZ   
 ---XYZ------XYZ------XYZ--- |    XYZ      XYZ      XYZ   
(6 rows)

-- select repeat (stub function, not pushdown constraints, explain)
--Testcase 1746:
EXPLAIN VERBOSE
SELECT value1, repeat(str1, 3) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, repeat(str1, 3)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select repeat (stub function, not pushdown constraints, result)
--Testcase 1747:
SELECT value1, repeat(str1, 3) FROM s3 WHERE to_hex(value2) = '64';
 value1 |           repeat            
--------+-----------------------------
    0.1 | ---XYZ------XYZ------XYZ---
    0.2 | ---XYZ------XYZ------XYZ---
    0.3 | ---XYZ------XYZ------XYZ---
(3 rows)

-- select repeat (stub function, pushdown constraints, explain)
--Testcase 1748:
EXPLAIN VERBOSE
SELECT value1, repeat(str1, 3) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, repeat(str1, 3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select repeat (stub function, pushdown constraints, result)
--Testcase 1749:
SELECT value1, repeat(str1, 3) FROM s3 WHERE value2 != 200;
 value1 |           repeat            
--------+-----------------------------
    0.1 | ---XYZ------XYZ------XYZ---
    0.2 | ---XYZ------XYZ------XYZ---
    0.3 | ---XYZ------XYZ------XYZ---
(3 rows)

-- select repeat with non pushdown func and explicit constant (explain)
--Testcase 1750:
EXPLAIN VERBOSE
SELECT repeat(str1, 3), pi(), 4.1 FROM s3;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: repeat(str1, 3), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select repeat with non pushdown func and explicit constant (result)
--Testcase 1751:
SELECT repeat(str1, 3), pi(), 4.1 FROM s3;
           repeat            |        pi         | ?column? 
-----------------------------+-------------------+----------
 ---XYZ------XYZ------XYZ--- | 3.141592653589793 |      4.1
 ---XYZ------XYZ------XYZ--- | 3.141592653589793 |      4.1
 ---XYZ------XYZ------XYZ--- | 3.141592653589793 |      4.1
 ---XYZ------XYZ------XYZ--- | 3.141592653589793 |      4.1
 ---XYZ------XYZ------XYZ--- | 3.141592653589793 |      4.1
 ---XYZ------XYZ------XYZ--- | 3.141592653589793 |      4.1
(6 rows)

-- select repeat with order by (explain)
--Testcase 1752:
EXPLAIN VERBOSE
SELECT value1, repeat(str1, 3) FROM s3 ORDER BY repeat(str1, 3);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, repeat(str1, 3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY repeat(`str1`, 3) IS NULL ASC, repeat(`str1`, 3) ASC
(4 rows)

-- select repeat with order by (result)
--Testcase 1753:
SELECT value1, repeat(str1, 3) FROM s3 ORDER BY repeat(str1, 3);
 value1 |           repeat            
--------+-----------------------------
    0.1 | ---XYZ------XYZ------XYZ---
    0.2 | ---XYZ------XYZ------XYZ---
    0.3 | ---XYZ------XYZ------XYZ---
    1.1 | ---XYZ------XYZ------XYZ---
    2.2 | ---XYZ------XYZ------XYZ---
    3.3 | ---XYZ------XYZ------XYZ---
(6 rows)

-- select repeat with order by index (result)
--Testcase 1754:
SELECT value1, repeat(str1, 3) FROM s3 ORDER BY 2,1;
 value1 |           repeat            
--------+-----------------------------
    0.1 | ---XYZ------XYZ------XYZ---
    0.2 | ---XYZ------XYZ------XYZ---
    0.3 | ---XYZ------XYZ------XYZ---
    1.1 | ---XYZ------XYZ------XYZ---
    2.2 | ---XYZ------XYZ------XYZ---
    3.3 | ---XYZ------XYZ------XYZ---
(6 rows)

-- select repeat with order by index (result)
--Testcase 1755:
SELECT value1, repeat(str1, 3) FROM s3 ORDER BY 1,2;
 value1 |           repeat            
--------+-----------------------------
    0.1 | ---XYZ------XYZ------XYZ---
    0.2 | ---XYZ------XYZ------XYZ---
    0.3 | ---XYZ------XYZ------XYZ---
    1.1 | ---XYZ------XYZ------XYZ---
    2.2 | ---XYZ------XYZ------XYZ---
    3.3 | ---XYZ------XYZ------XYZ---
(6 rows)

-- select repeat with group by (explain)
--Testcase 1756:
EXPLAIN VERBOSE
SELECT count(value1), repeat(str1, 3) FROM s3 GROUP BY repeat(str1, 3);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (repeat(str1, 3))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), repeat(`str1`, 3) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select repeat with group by (result)
--Testcase 1757:
SELECT count(value1), repeat(str1, 3) FROM s3 GROUP BY repeat(str1, 3);
 count |           repeat            
-------+-----------------------------
     6 | ---XYZ------XYZ------XYZ---
(1 row)

-- select repeat with group by index (result)
--Testcase 1758:
SELECT value1, repeat(str1, 3) FROM s3 GROUP BY 2,1;
 value1 |           repeat            
--------+-----------------------------
    0.1 | ---XYZ------XYZ------XYZ---
    0.2 | ---XYZ------XYZ------XYZ---
    0.3 | ---XYZ------XYZ------XYZ---
    1.1 | ---XYZ------XYZ------XYZ---
    2.2 | ---XYZ------XYZ------XYZ---
    3.3 | ---XYZ------XYZ------XYZ---
(6 rows)

-- select repeat with group by having (explain)
--Testcase 1759:
EXPLAIN VERBOSE
SELECT count(value1), repeat(str1, 3) FROM s3 GROUP BY repeat(str1, 3), str1 HAVING repeat(str1, 3) IS NOT NULL;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (repeat(str1, 3)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), repeat(`str1`, 3), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((repeat(`str1`, 3) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select repeat with group by having (result)
--Testcase 1760:
SELECT count(value1), repeat(str1, 3) FROM s3 GROUP BY repeat(str1, 3), str1 HAVING repeat(str1, 3) IS NOT NULL;
 count |           repeat            
-------+-----------------------------
     6 | ---XYZ------XYZ------XYZ---
(1 row)

-- select repeat with group by index having (result)
--Testcase 1761:
SELECT value1, repeat(str1, 3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |           repeat            
--------+-----------------------------
    1.1 | ---XYZ------XYZ------XYZ---
    2.2 | ---XYZ------XYZ------XYZ---
    3.3 | ---XYZ------XYZ------XYZ---
(3 rows)

-- ===============================================================================
-- test replace()
-- ===============================================================================
-- select replace (stub function, explain)
--Testcase 1762:
EXPLAIN VERBOSE
SELECT replace(str1, 'XYZ', 'ABC'), replace(str2, 'XYZ', 'ABC') FROM s3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: replace(str1, 'XYZ'::text, 'ABC'::text), replace(str2, 'XYZ'::text, 'ABC'::text)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select replace (stub function, result)
--Testcase 1763:
SELECT replace(str1, 'XYZ', 'ABC'), replace(str2, 'XYZ', 'ABC') FROM s3;
  replace  |  replace  
-----------+-----------
 ---ABC--- |    ABC   
 ---ABC--- |    ABC   
 ---ABC--- |    ABC   
 ---ABC--- |    ABC   
 ---ABC--- |    ABC   
 ---ABC--- |    ABC   
(6 rows)

-- select replace (stub function, not pushdown constraints, explain)
--Testcase 1764:
EXPLAIN VERBOSE
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, replace(str1, 'XYZ'::text, 'ABC'::text)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select replace (stub function, not pushdown constraints, result)
--Testcase 1765:
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 WHERE to_hex(value2) = '64';
 value1 |  replace  
--------+-----------
    0.1 | ---ABC---
    0.2 | ---ABC---
    0.3 | ---ABC---
(3 rows)

-- select replace (stub function, pushdown constraints, explain)
--Testcase 1766:
EXPLAIN VERBOSE
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, replace(str1, 'XYZ'::text, 'ABC'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select replace (stub function, pushdown constraints, result)
--Testcase 1767:
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 WHERE value2 != 200;
 value1 |  replace  
--------+-----------
    0.1 | ---ABC---
    0.2 | ---ABC---
    0.3 | ---ABC---
(3 rows)

-- select replace with non pushdown func and explicit constant (explain)
--Testcase 1768:
EXPLAIN VERBOSE
SELECT replace(str1, 'XYZ', 'ABC'), pi(), 4.1 FROM s3;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: replace(str1, 'XYZ'::text, 'ABC'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select replace with non pushdown func and explicit constant (result)
--Testcase 1769:
SELECT replace(str1, 'XYZ', 'ABC'), pi(), 4.1 FROM s3;
  replace  |        pi         | ?column? 
-----------+-------------------+----------
 ---ABC--- | 3.141592653589793 |      4.1
 ---ABC--- | 3.141592653589793 |      4.1
 ---ABC--- | 3.141592653589793 |      4.1
 ---ABC--- | 3.141592653589793 |      4.1
 ---ABC--- | 3.141592653589793 |      4.1
 ---ABC--- | 3.141592653589793 |      4.1
(6 rows)

-- select replace with order by (explain)
--Testcase 1770:
EXPLAIN VERBOSE
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 ORDER BY replace(str1, 'XYZ', 'ABC');
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, replace(str1, 'XYZ'::text, 'ABC'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY replace(`str1`, 'XYZ', 'ABC') IS NULL ASC, replace(`str1`, 'XYZ', 'ABC') ASC
(4 rows)

-- select replace with order by (result)
--Testcase 1771:
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 ORDER BY replace(str1, 'XYZ', 'ABC');
 value1 |  replace  
--------+-----------
    0.1 | ---ABC---
    0.2 | ---ABC---
    0.3 | ---ABC---
    1.1 | ---ABC---
    2.2 | ---ABC---
    3.3 | ---ABC---
(6 rows)

-- select replace with order by index (result)
--Testcase 1772:
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 ORDER BY 2,1;
 value1 |  replace  
--------+-----------
    0.1 | ---ABC---
    0.2 | ---ABC---
    0.3 | ---ABC---
    1.1 | ---ABC---
    2.2 | ---ABC---
    3.3 | ---ABC---
(6 rows)

-- select replace with order by index (result)
--Testcase 1773:
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 ORDER BY 1,2;
 value1 |  replace  
--------+-----------
    0.1 | ---ABC---
    0.2 | ---ABC---
    0.3 | ---ABC---
    1.1 | ---ABC---
    2.2 | ---ABC---
    3.3 | ---ABC---
(6 rows)

-- select replace with group by (explain)
--Testcase 1774:
EXPLAIN VERBOSE
SELECT count(value1), replace(str1, 'XYZ', 'ABC') FROM s3 GROUP BY replace(str1, 'XYZ', 'ABC');
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (replace(str1, 'XYZ'::text, 'ABC'::text))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), replace(`str1`, 'XYZ', 'ABC') FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select replace with group by (result)
--Testcase 1775:
SELECT count(value1), replace(str1, 'XYZ', 'ABC') FROM s3 GROUP BY replace(str1, 'XYZ', 'ABC');
 count |  replace  
-------+-----------
     6 | ---ABC---
(1 row)

-- select replace with group by index (result)
--Testcase 1776:
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 GROUP BY 2,1;
 value1 |  replace  
--------+-----------
    0.1 | ---ABC---
    0.2 | ---ABC---
    0.3 | ---ABC---
    1.1 | ---ABC---
    2.2 | ---ABC---
    3.3 | ---ABC---
(6 rows)

-- select replace with group by having (explain)
--Testcase 1777:
EXPLAIN VERBOSE
SELECT count(value1), replace(str1, 'XYZ', 'ABC') FROM s3 GROUP BY replace(str1, 'XYZ', 'ABC'), str1 HAVING replace(str1, 'XYZ', 'ABC') IS NOT NULL;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (replace(str1, 'XYZ'::text, 'ABC'::text)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), replace(`str1`, 'XYZ', 'ABC'), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((replace(`str1`, 'XYZ', 'ABC') IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select replace with group by having (result)
--Testcase 1778:
SELECT count(value1), replace(str1, 'XYZ', 'ABC') FROM s3 GROUP BY replace(str1, 'XYZ', 'ABC'), str1 HAVING replace(str1, 'XYZ', 'ABC') IS NOT NULL;
 count |  replace  
-------+-----------
     6 | ---ABC---
(1 row)

-- select replace with group by index having (result)
--Testcase 1779:
SELECT value1, replace(str1, 'XYZ', 'ABC') FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |  replace  
--------+-----------
    1.1 | ---ABC---
    2.2 | ---ABC---
    3.3 | ---ABC---
(3 rows)

-- ===============================================================================
-- test reverse()
-- ===============================================================================
-- select reverse (stub function, explain)
--Testcase 1780:
EXPLAIN VERBOSE
SELECT reverse(str1), reverse(str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: reverse(str1), reverse(str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select reverse (stub function, result)
--Testcase 1781:
SELECT reverse(str1), reverse(str2) FROM s3;
  reverse  |  reverse  
-----------+-----------
 ---ZYX--- |    ZYX   
 ---ZYX--- |    ZYX   
 ---ZYX--- |    ZYX   
 ---ZYX--- |    ZYX   
 ---ZYX--- |    ZYX   
 ---ZYX--- |    ZYX   
(6 rows)

-- select reverse (stub function, not pushdown constraints, explain)
--Testcase 1782:
EXPLAIN VERBOSE
SELECT value1, reverse(str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, reverse(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select reverse (stub function, not pushdown constraints, result)
--Testcase 1783:
SELECT value1, reverse(str1) FROM s3 WHERE to_hex(value2) = '64';
 value1 |  reverse  
--------+-----------
    0.1 | ---ZYX---
    0.2 | ---ZYX---
    0.3 | ---ZYX---
(3 rows)

-- select reverse (stub function, pushdown constraints, explain)
--Testcase 1784:
EXPLAIN VERBOSE
SELECT value1, reverse(str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, reverse(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select reverse (stub function, pushdown constraints, result)
--Testcase 1785:
SELECT value1, reverse(str1) FROM s3 WHERE value2 != 200;
 value1 |  reverse  
--------+-----------
    0.1 | ---ZYX---
    0.2 | ---ZYX---
    0.3 | ---ZYX---
(3 rows)

-- select reverse with non pushdown func and explicit constant (explain)
--Testcase 1786:
EXPLAIN VERBOSE
SELECT reverse(str1), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: reverse(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select reverse with non pushdown func and explicit constant (result)
--Testcase 1787:
SELECT reverse(str1), pi(), 4.1 FROM s3;
  reverse  |        pi         | ?column? 
-----------+-------------------+----------
 ---ZYX--- | 3.141592653589793 |      4.1
 ---ZYX--- | 3.141592653589793 |      4.1
 ---ZYX--- | 3.141592653589793 |      4.1
 ---ZYX--- | 3.141592653589793 |      4.1
 ---ZYX--- | 3.141592653589793 |      4.1
 ---ZYX--- | 3.141592653589793 |      4.1
(6 rows)

-- select reverse with order by (explain)
--Testcase 1788:
EXPLAIN VERBOSE
SELECT value1, reverse(str1) FROM s3 ORDER BY reverse(str1);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, reverse(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY reverse(`str1`) IS NULL ASC, reverse(`str1`) ASC
(4 rows)

-- select reverse with order by (result)
--Testcase 1789:
SELECT value1, reverse(str1) FROM s3 ORDER BY reverse(str1);
 value1 |  reverse  
--------+-----------
    0.1 | ---ZYX---
    0.2 | ---ZYX---
    0.3 | ---ZYX---
    1.1 | ---ZYX---
    2.2 | ---ZYX---
    3.3 | ---ZYX---
(6 rows)

-- select reverse with order by index (result)
--Testcase 1790:
SELECT value1, reverse(str1) FROM s3 ORDER BY 2,1;
 value1 |  reverse  
--------+-----------
    0.1 | ---ZYX---
    0.2 | ---ZYX---
    0.3 | ---ZYX---
    1.1 | ---ZYX---
    2.2 | ---ZYX---
    3.3 | ---ZYX---
(6 rows)

-- select reverse with order by index (result)
--Testcase 1791:
SELECT value1, reverse(str1) FROM s3 ORDER BY 1,2;
 value1 |  reverse  
--------+-----------
    0.1 | ---ZYX---
    0.2 | ---ZYX---
    0.3 | ---ZYX---
    1.1 | ---ZYX---
    2.2 | ---ZYX---
    3.3 | ---ZYX---
(6 rows)

-- select reverse with group by (explain)
--Testcase 1792:
EXPLAIN VERBOSE
SELECT count(value1), reverse(str1) FROM s3 GROUP BY reverse(str1);
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (reverse(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), reverse(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select reverse with group by (result)
--Testcase 1793:
SELECT count(value1), reverse(str1) FROM s3 GROUP BY reverse(str1);
 count |  reverse  
-------+-----------
     6 | ---ZYX---
(1 row)

-- select reverse with group by index (result)
--Testcase 1794:
SELECT value1, reverse(str1) FROM s3 GROUP BY 2,1;
 value1 |  reverse  
--------+-----------
    0.1 | ---ZYX---
    0.2 | ---ZYX---
    0.3 | ---ZYX---
    1.1 | ---ZYX---
    2.2 | ---ZYX---
    3.3 | ---ZYX---
(6 rows)

-- select reverse with group by having (explain)
--Testcase 1795:
EXPLAIN VERBOSE
SELECT count(value1), reverse(str1) FROM s3 GROUP BY reverse(str1), str1 HAVING reverse(str1) IS NOT NULL;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (reverse(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), reverse(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((reverse(`str1`) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select reverse with group by having (result)
--Testcase 1796:
SELECT count(value1), reverse(str1) FROM s3 GROUP BY reverse(str1), str1 HAVING reverse(str1) IS NOT NULL;
 count |  reverse  
-------+-----------
     6 | ---ZYX---
(1 row)

-- select reverse with group by index having (result)
--Testcase 1797:
SELECT value1, reverse(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |  reverse  
--------+-----------
    1.1 | ---ZYX---
    2.2 | ---ZYX---
    3.3 | ---ZYX---
(3 rows)

-- ===============================================================================
-- test right()
-- ===============================================================================
-- select right (stub function, explain)
--Testcase 1798:
EXPLAIN VERBOSE
SELECT right(str1, 4), right(str2, 4) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: "right"(str1, 4), "right"(str2, 4)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select right (stub function, result)
--Testcase 1799:
SELECT right(str1, 4), right(str2, 4) FROM s3;
 right | right 
-------+-------
 Z---  | Z   
 Z---  | Z   
 Z---  | Z   
 Z---  | Z   
 Z---  | Z   
 Z---  | Z   
(6 rows)

-- select right (stub function, not pushdown constraints, explain)
--Testcase 1800:
EXPLAIN VERBOSE
SELECT value1, right(str1, 6) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, "right"(str1, 6)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select right (stub function, not pushdown constraints, result)
--Testcase 1801:
SELECT value1, right(str1, 6) FROM s3 WHERE to_hex(value2) = '64';
 value1 | right  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
(3 rows)

-- select right (stub function, pushdown constraints, explain)
--Testcase 1802:
EXPLAIN VERBOSE
SELECT value1, right(str1, 6) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, "right"(str1, 6)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select right (stub function, pushdown constraints, result)
--Testcase 1803:
SELECT value1, right(str1, 6) FROM s3 WHERE value2 != 200;
 value1 | right  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
(3 rows)

-- select right with non pushdown func and explicit constant (explain)
--Testcase 1804:
EXPLAIN VERBOSE
SELECT right(str1, 6), pi(), 4.1 FROM s3;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: "right"(str1, 6), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select right with non pushdown func and explicit constant (result)
--Testcase 1805:
SELECT right(str1, 6), pi(), 4.1 FROM s3;
 right  |        pi         | ?column? 
--------+-------------------+----------
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
 XYZ--- | 3.141592653589793 |      4.1
(6 rows)

-- select right with order by (explain)
--Testcase 1806:
EXPLAIN VERBOSE
SELECT value1, right(str1, 6) FROM s3 ORDER BY right(str1, 6);
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, "right"(str1, 6)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY right(`str1`, 6) IS NULL ASC, right(`str1`, 6) ASC
(4 rows)

-- select right with order by (result)
--Testcase 1807:
SELECT value1, right(str1, 6) FROM s3 ORDER BY right(str1, 6);
 value1 | right  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(6 rows)

-- select right with order by index (result)
--Testcase 1808:
SELECT value1, right(str1, 6) FROM s3 ORDER BY 2,1;
 value1 | right  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(6 rows)

-- select right with order by index (result)
--Testcase 1809:
SELECT value1, right(str1, 6) FROM s3 ORDER BY 1,2;
 value1 | right  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(6 rows)

-- select right with group by (explain)
--Testcase 1810:
EXPLAIN VERBOSE
SELECT count(value1), right(str1, 6) FROM s3 GROUP BY right(str1, 6);
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), ("right"(str1, 6))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), right(`str1`, 6) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select right with group by (result)
--Testcase 1811:
SELECT count(value1), right(str1, 6) FROM s3 GROUP BY right(str1, 6);
 count | right  
-------+--------
     6 | XYZ---
(1 row)

-- select right with group by index (result)
--Testcase 1812:
SELECT value1, right(str1, 6) FROM s3 GROUP BY 2,1;
 value1 | right  
--------+--------
    0.1 | XYZ---
    0.2 | XYZ---
    0.3 | XYZ---
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(6 rows)

-- select right with group by having (explain)
--Testcase 1813:
EXPLAIN VERBOSE
SELECT count(value1), right(str1, 6) FROM s3 GROUP BY right(str1, 6), str1 HAVING right(str1, 6) IS NOT NULL;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), ("right"(str1, 6)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), right(`str1`, 6), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((right(`str1`, 6) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select right with group by having (result)
--Testcase 1814:
SELECT count(value1), right(str1, 6) FROM s3 GROUP BY right(str1, 6), str1 HAVING right(str1, 6) IS NOT NULL;
 count | right  
-------+--------
     6 | XYZ---
(1 row)

-- select right with group by index having (result)
--Testcase 1815:
SELECT value1, right(str1, 6) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | right  
--------+--------
    1.1 | XYZ---
    2.2 | XYZ---
    3.3 | XYZ---
(3 rows)

-- ===============================================================================
-- test rpad()
-- ===============================================================================
-- select rpad (stub function, explain)
--Testcase 1816:
EXPLAIN VERBOSE
SELECT rpad(str1, 16, str2), rpad(str1, 4, str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: rpad(str1, 16, str2), rpad(str1, 4, str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select rpad (stub function, result)
--Testcase 1817:
SELECT rpad(str1, 16, str2), rpad(str1, 4, str2) FROM s3;
       rpad       | rpad 
------------------+------
 ---XYZ---   XYZ  | ---X
 ---XYZ---   XYZ  | ---X
 ---XYZ---   XYZ  | ---X
 ---XYZ---   XYZ  | ---X
 ---XYZ---   XYZ  | ---X
 ---XYZ---   XYZ  | ---X
(6 rows)

-- select rpad (stub function, not pushdown constraints, explain)
--Testcase 1818:
EXPLAIN VERBOSE
SELECT value1, rpad(str1, 16, str2) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=40)
   Output: value1, rpad(str1, 16, str2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select rpad (stub function, not pushdown constraints, result)
--Testcase 1819:
SELECT value1, rpad(str1, 16, str2) FROM s3 WHERE to_hex(value2) = '64';
 value1 |       rpad       
--------+------------------
    0.1 | ---XYZ---   XYZ 
    0.2 | ---XYZ---   XYZ 
    0.3 | ---XYZ---   XYZ 
(3 rows)

-- select rpad (stub function, pushdown constraints, explain)
--Testcase 1820:
EXPLAIN VERBOSE
SELECT value1, rpad(str1, 16, str2) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=40)
   Output: value1, rpad(str1, 16, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select rpad (stub function, pushdown constraints, result)
--Testcase 1821:
SELECT value1, rpad(str1, 16, str2) FROM s3 WHERE value2 != 200;
 value1 |       rpad       
--------+------------------
    0.1 | ---XYZ---   XYZ 
    0.2 | ---XYZ---   XYZ 
    0.3 | ---XYZ---   XYZ 
(3 rows)

-- select rpad with non pushdown func and explicit constant (explain)
--Testcase 1822:
EXPLAIN VERBOSE
SELECT rpad(str1, 16, str2), pi(), 4.1 FROM s3;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=72)
   Output: rpad(str1, 16, str2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select rpad with non pushdown func and explicit constant (result)
--Testcase 1823:
SELECT rpad(str1, 16, str2), pi(), 4.1 FROM s3;
       rpad       |        pi         | ?column? 
------------------+-------------------+----------
 ---XYZ---   XYZ  | 3.141592653589793 |      4.1
 ---XYZ---   XYZ  | 3.141592653589793 |      4.1
 ---XYZ---   XYZ  | 3.141592653589793 |      4.1
 ---XYZ---   XYZ  | 3.141592653589793 |      4.1
 ---XYZ---   XYZ  | 3.141592653589793 |      4.1
 ---XYZ---   XYZ  | 3.141592653589793 |      4.1
(6 rows)

-- select rpad with order by (explain)
--Testcase 1824:
EXPLAIN VERBOSE
SELECT value1, rpad(str1, 16, str2) FROM s3 ORDER BY rpad(str1, 16, str2);
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, rpad(str1, 16, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY rpad(`str1`, 16, `str2`) IS NULL ASC, rpad(`str1`, 16, `str2`) ASC
(4 rows)

-- select rpad with order by (result)
--Testcase 1825:
SELECT value1, rpad(str1, 16, str2) FROM s3 ORDER BY rpad(str1, 16, str2);
 value1 |       rpad       
--------+------------------
    0.1 | ---XYZ---   XYZ 
    0.2 | ---XYZ---   XYZ 
    0.3 | ---XYZ---   XYZ 
    1.1 | ---XYZ---   XYZ 
    2.2 | ---XYZ---   XYZ 
    3.3 | ---XYZ---   XYZ 
(6 rows)

-- select rpad with order by index (result)
--Testcase 1826:
SELECT value1, rpad(str1, 16, str2) FROM s3 ORDER BY 2,1;
 value1 |       rpad       
--------+------------------
    0.1 | ---XYZ---   XYZ 
    0.2 | ---XYZ---   XYZ 
    0.3 | ---XYZ---   XYZ 
    1.1 | ---XYZ---   XYZ 
    2.2 | ---XYZ---   XYZ 
    3.3 | ---XYZ---   XYZ 
(6 rows)

-- select rpad with order by index (result)
--Testcase 1827:
SELECT value1, rpad(str1, 16, str2) FROM s3 ORDER BY 1,2;
 value1 |       rpad       
--------+------------------
    0.1 | ---XYZ---   XYZ 
    0.2 | ---XYZ---   XYZ 
    0.3 | ---XYZ---   XYZ 
    1.1 | ---XYZ---   XYZ 
    2.2 | ---XYZ---   XYZ 
    3.3 | ---XYZ---   XYZ 
(6 rows)

-- select rpad with group by (explain)
--Testcase 1828:
EXPLAIN VERBOSE
SELECT count(value1), rpad(str1, 16, str2) FROM s3 GROUP BY rpad(str1, 16, str2);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (rpad(str1, 16, str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), rpad(`str1`, 16, `str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select rpad with group by (result)
--Testcase 1829:
SELECT count(value1), rpad(str1, 16, str2) FROM s3 GROUP BY rpad(str1, 16, str2);
 count |       rpad       
-------+------------------
     6 | ---XYZ---   XYZ 
(1 row)

-- select rpad with group by index (result)
--Testcase 1830:
SELECT value1, rpad(str1, 16, str2) FROM s3 GROUP BY 2,1;
 value1 |       rpad       
--------+------------------
    0.1 | ---XYZ---   XYZ 
    0.2 | ---XYZ---   XYZ 
    0.3 | ---XYZ---   XYZ 
    1.1 | ---XYZ---   XYZ 
    2.2 | ---XYZ---   XYZ 
    3.3 | ---XYZ---   XYZ 
(6 rows)

-- select rpad with group by having (explain)
--Testcase 1831:
EXPLAIN VERBOSE
SELECT count(value1), rpad(str1, 16, str2) FROM s3 GROUP BY rpad(str1, 16, str2) HAVING rpad(str1, 16, str2) IS NOT NULL;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (rpad(str1, 16, str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), rpad(`str1`, 16, `str2`) FROM `mysql_fdw_regress`.`s3` WHERE ((rpad(`str1`, 16, `str2`) IS NOT NULL)) GROUP BY 2
(5 rows)

-- select rpad with group by having (result)
--Testcase 1832:
SELECT count(value1), rpad(str1, 16, str2) FROM s3 GROUP BY rpad(str1, 16, str2) HAVING rpad(str1, 16, str2) IS NOT NULL;
 count |       rpad       
-------+------------------
     6 | ---XYZ---   XYZ 
(1 row)

-- select rpad with group by index having (result)
--Testcase 1833:
SELECT value1, rpad(str1, 16, str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |       rpad       
--------+------------------
    1.1 | ---XYZ---   XYZ 
    2.2 | ---XYZ---   XYZ 
    3.3 | ---XYZ---   XYZ 
(3 rows)

-- ===============================================================================
-- test rtrim()
-- ===============================================================================
-- select rtrim (stub function, explain)
--Testcase 1834:
EXPLAIN VERBOSE
SELECT rtrim(str1), rtrim(str2, ' ') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: rtrim(str1), rtrim(str2, ' '::text)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select rtrim (stub function, result)
--Testcase 1835:
SELECT rtrim(str1), rtrim(str2, ' ') FROM s3;
   rtrim   | rtrim  
-----------+--------
 ---XYZ--- |    XYZ
 ---XYZ--- |    XYZ
 ---XYZ--- |    XYZ
 ---XYZ--- |    XYZ
 ---XYZ--- |    XYZ
 ---XYZ--- |    XYZ
(6 rows)

-- select rtrim (stub function, not pushdown constraints, explain)
--Testcase 1836:
EXPLAIN VERBOSE
SELECT value1, rtrim(str1, '-') FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, rtrim(str1, '-'::text)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select rtrim (stub function, not pushdown constraints, result)
--Testcase 1837:
SELECT value1, rtrim(str1, '-') FROM s3 WHERE to_hex(value2) = '64';
 value1 | rtrim  
--------+--------
    0.1 | ---XYZ
    0.2 | ---XYZ
    0.3 | ---XYZ
(3 rows)

-- select rtrim (stub function, pushdown constraints, explain)
--Testcase 1838:
EXPLAIN VERBOSE
SELECT value1, rtrim(str1, '-') FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, rtrim(str1, '-'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select rtrim (stub function, pushdown constraints, result)
--Testcase 1839:
SELECT value1, rtrim(str1, '-') FROM s3 WHERE value2 != 200;
 value1 | rtrim  
--------+--------
    0.1 | ---XYZ
    0.2 | ---XYZ
    0.3 | ---XYZ
(3 rows)

-- select rtrim with non pushdown func and explicit constant (explain)
--Testcase 1840:
EXPLAIN VERBOSE
SELECT rtrim(str1, '-'), pi(), 4.1 FROM s3;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: rtrim(str1, '-'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select rtrim with non pushdown func and explicit constant (result)
--Testcase 1841:
SELECT rtrim(str1, '-'), pi(), 4.1 FROM s3;
 rtrim  |        pi         | ?column? 
--------+-------------------+----------
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
(6 rows)

-- select rtrim with order by (explain)
--Testcase 1842:
EXPLAIN VERBOSE
SELECT value1, rtrim(str1, '-') FROM s3 ORDER BY rtrim(str1, '-');
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, rtrim(str1, '-'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY trim(TRAILING '-' FROM `str1`) IS NULL ASC, trim(TRAILING '-' FROM `str1`) ASC
(4 rows)

-- select rtrim with order by (result)
--Testcase 1843:
SELECT value1, rtrim(str1, '-') FROM s3 ORDER BY rtrim(str1, '-');
 value1 | rtrim  
--------+--------
    0.1 | ---XYZ
    0.2 | ---XYZ
    0.3 | ---XYZ
    1.1 | ---XYZ
    2.2 | ---XYZ
    3.3 | ---XYZ
(6 rows)

-- select rtrim with order by index (result)
--Testcase 1844:
SELECT value1, rtrim(str1, '-') FROM s3 ORDER BY 2,1;
 value1 | rtrim  
--------+--------
    0.1 | ---XYZ
    0.2 | ---XYZ
    0.3 | ---XYZ
    1.1 | ---XYZ
    2.2 | ---XYZ
    3.3 | ---XYZ
(6 rows)

-- select rtrim with order by index (result)
--Testcase 1845:
SELECT value1, rtrim(str1, '-') FROM s3 ORDER BY 1,2;
 value1 | rtrim  
--------+--------
    0.1 | ---XYZ
    0.2 | ---XYZ
    0.3 | ---XYZ
    1.1 | ---XYZ
    2.2 | ---XYZ
    3.3 | ---XYZ
(6 rows)

-- select rtrim with group by (explain)
--Testcase 1846:
EXPLAIN VERBOSE
SELECT count(value1), rtrim(str1, '-') FROM s3 GROUP BY rtrim(str1, '-');
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (rtrim(str1, '-'::text))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), trim(TRAILING '-' FROM `str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select rtrim with group by (result)
--Testcase 1847:
SELECT count(value1), rtrim(str1, '-') FROM s3 GROUP BY rtrim(str1, '-');
 count | rtrim  
-------+--------
     6 | ---XYZ
(1 row)

-- select rtrim with group by index (result)
--Testcase 1848:
SELECT value1, rtrim(str2) FROM s3 GROUP BY 2,1;
 value1 | rtrim  
--------+--------
    0.1 |    XYZ
    0.2 |    XYZ
    0.3 |    XYZ
    1.1 |    XYZ
    2.2 |    XYZ
    3.3 |    XYZ
(6 rows)

-- select rtrim with group by having (explain)
--Testcase 1849:
EXPLAIN VERBOSE
SELECT count(value1), rtrim(str1, '-') FROM s3 GROUP BY rtrim(str1, '-') HAVING rtrim(str1, '-') IS NOT NULL;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (rtrim(str1, '-'::text))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), trim(TRAILING '-' FROM `str1`) FROM `mysql_fdw_regress`.`s3` WHERE ((trim(TRAILING '-' FROM `str1`) IS NOT NULL)) GROUP BY 2
(5 rows)

-- select rtrim with group by having (result)
--Testcase 1850:
SELECT count(value1), rtrim(str1, '-') FROM s3 GROUP BY rtrim(str1, '-') HAVING rtrim(str1, '-') IS NOT NULL;
 count | rtrim  
-------+--------
     6 | ---XYZ
(1 row)

-- select rtrim with group by index having (result)
--Testcase 1851:
SELECT value1, rtrim(str1, '-') FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | rtrim  
--------+--------
    1.1 | ---XYZ
    2.2 | ---XYZ
    3.3 | ---XYZ
(3 rows)

-- ===============================================================================
-- test space()
-- ===============================================================================
-- select space (stub function, explain)
--Testcase 1852:
EXPLAIN VERBOSE
SELECT space(value2), space(value4) FROM s3;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.40 rows=2560 width=64)
   Output: space((value2)::bigint), space((value4)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value2`, `value4` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select space (stub function, result)
--Testcase 1853:
SELECT space(value2), space(value4) FROM s3;
ERROR:  stub space(bigint) is called
CONTEXT:  PL/pgSQL function space(bigint) line 3 at RAISE
-- select space (stub function, not pushdown constraints, explain)
--Testcase 1854:
EXPLAIN VERBOSE
SELECT value1, space(id) FROM s3 WHERE to_hex(value2) = '64';
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..144.40 rows=11 width=40)
   Output: value1, space((id)::bigint)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select space (stub function, not pushdown constraints, result)
--Testcase 1855:
SELECT value1, space(id) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub space(bigint) is called
CONTEXT:  PL/pgSQL function space(bigint) line 3 at RAISE
-- select space (stub function, pushdown constraints, explain)
--Testcase 1856:
EXPLAIN VERBOSE
SELECT value1, space(id) FROM s3 WHERE value2 != 200;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..195.04 rows=2264 width=40)
   Output: value1, space((id)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select space (stub function, pushdown constraints, result)
--Testcase 1857:
SELECT value1, space(id) FROM s3 WHERE value2 != 200;
ERROR:  stub space(bigint) is called
CONTEXT:  PL/pgSQL function space(bigint) line 3 at RAISE
-- select space as nest function with agg (pushdown, explain)
--Testcase 1858:
EXPLAIN VERBOSE
SELECT sum(value3), space(sum(id)) FROM s3;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(value3)), (space(sum(id)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT sum(`value3`), space(sum(`id`)) FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select space as nest function with agg (pushdown, result)
--Testcase 1859:
SELECT sum(value3), space(sum(id)) FROM s3;
        sum         |      space      
--------------------+-----------------
 -7.200000040233135 |                
(1 row)

-- select space with non pushdown func and explicit constant (explain)
--Testcase 1860:
EXPLAIN VERBOSE
SELECT space(id), pi(), 4.1 FROM s3;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..212.38 rows=2925 width=72)
   Output: space((id)::bigint), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select space with non pushdown func and explicit constant (result)
--Testcase 1861:
SELECT space(id), pi(), 4.1 FROM s3;
ERROR:  stub space(bigint) is called
CONTEXT:  PL/pgSQL function space(bigint) line 3 at RAISE
-- select space with order by (explain)
--Testcase 1862:
EXPLAIN VERBOSE
SELECT value1, space(id) FROM s3 ORDER BY space(id);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=40)
   Output: value1, space((id)::bigint)
   Local server startup cost: 10
   Remote query: SELECT `id`, `value1` FROM `mysql_fdw_regress`.`s3` ORDER BY space(`id`) IS NULL ASC, space(`id`) ASC
(4 rows)

-- select space with order by (result)
--Testcase 1863:
SELECT value1, space(id) FROM s3 ORDER BY space(id);
ERROR:  stub space(bigint) is called
CONTEXT:  PL/pgSQL function space(bigint) line 3 at RAISE
-- select space with order by index (result)
--Testcase 1864:
SELECT value1, space(id) FROM s3 ORDER BY 2,1;
ERROR:  stub space(bigint) is called
CONTEXT:  PL/pgSQL function space(bigint) line 3 at RAISE
-- select space with order by index (result)
--Testcase 1865:
SELECT value1, space(id) FROM s3 ORDER BY 1,2;
ERROR:  stub space(bigint) is called
CONTEXT:  PL/pgSQL function space(bigint) line 3 at RAISE
-- select space with group by (explain)
--Testcase 1866:
EXPLAIN VERBOSE
SELECT value1, space(id) FROM s3 GROUP BY value1, space(id);
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=40)
   Output: value1, (space((id)::bigint))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT `value1`, space(`id`) FROM `mysql_fdw_regress`.`s3` GROUP BY 1, 2
(5 rows)

-- select space with group by (result)
--Testcase 1867:
SELECT value1, space(id) FROM s3 GROUP BY value1, space(id);
 value1 | space 
--------+-------
    0.1 | 
    0.2 |  
    0.3 |   
    1.1 |    
    2.2 |     
    3.3 |      
(6 rows)

-- select space with group by index (result)
--Testcase 1868:
SELECT value1, space(id) FROM s3 GROUP BY 2,1;
 value1 | space 
--------+-------
    0.1 | 
    0.2 |  
    0.3 |   
    1.1 |    
    2.2 |     
    3.3 |      
(6 rows)

-- select space with group by having (explain)
--Testcase 1869:
EXPLAIN VERBOSE
SELECT count(value1), space(id) FROM s3 GROUP BY space(id), id HAVING space(id) IS NOT NULL;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=44)
   Output: (count(value1)), (space((id)::bigint)), id
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), space(`id`), `id` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((space(`id`) IS NOT NULL))
(5 rows)

-- select space with group by having (result)
--Testcase 1870:
SELECT count(value1), space(id) FROM s3 GROUP BY space(id), id HAVING space(id) IS NOT NULL;
 count | space 
-------+-------
     1 | 
     1 |  
     1 |   
     1 |    
     1 |     
     1 |      
(6 rows)

-- select space with group by index having (result)
--Testcase 1871:
SELECT value1, space(id) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | space 
--------+-------
    1.1 |    
    2.2 |     
    3.3 |      
(3 rows)

-- ===============================================================================
-- test strcmp()
-- ===============================================================================
-- select strcmp (stub function, explain)
--Testcase 1872:
EXPLAIN VERBOSE
SELECT strcmp(str1, str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=4)
   Output: strcmp(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select strcmp (stub function, result)
--Testcase 1873:
SELECT strcmp(str1, str2) FROM s3;
ERROR:  stub strcmp(text, text) is called
CONTEXT:  PL/pgSQL function strcmp(text,text) line 3 at RAISE
-- select strcmp (stub function, not pushdown constraints, explain)
--Testcase 1874:
EXPLAIN VERBOSE
SELECT value1, strcmp(str1, str2) FROM s3 WHERE to_hex(value2) = '64';
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..122.89 rows=4 width=12)
   Output: value1, strcmp(str1, str2)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select strcmp (stub function, not pushdown constraints, result)
--Testcase 1875:
SELECT value1, strcmp(str1, str2) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub strcmp(text, text) is called
CONTEXT:  PL/pgSQL function strcmp(text,text) line 3 at RAISE
-- select strcmp (stub function, pushdown constraints, explain)
--Testcase 1876:
EXPLAIN VERBOSE
SELECT value1, strcmp(str1, str2) FROM s3 WHERE value2 != 200;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..139.77 rows=849 width=12)
   Output: value1, strcmp(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select strcmp (stub function, pushdown constraints, result)
--Testcase 1877:
SELECT value1, strcmp(str1, str2) FROM s3 WHERE value2 != 200;
ERROR:  stub strcmp(text, text) is called
CONTEXT:  PL/pgSQL function strcmp(text,text) line 3 at RAISE
-- select strcmp with non pushdown func and explicit constant (explain)
--Testcase 1878:
EXPLAIN VERBOSE
SELECT strcmp(str1, str2), pi(), 4.1 FROM s3;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..140.22 rows=930 width=44)
   Output: strcmp(str1, str2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select strcmp with non pushdown func and explicit constant (result)
--Testcase 1879:
SELECT strcmp(str1, str2), pi(), 4.1 FROM s3;
ERROR:  stub strcmp(text, text) is called
CONTEXT:  PL/pgSQL function strcmp(text,text) line 3 at RAISE
-- select strcmp with order by (explain)
--Testcase 1880:
EXPLAIN VERBOSE
SELECT value1, strcmp(str1, str2) FROM s3 ORDER BY strcmp(str1, str2);
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=12)
   Output: value1, strcmp(str1, str2)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY strcmp(`str1`, `str2`) IS NULL ASC, strcmp(`str1`, `str2`) ASC
(4 rows)

-- select strcmp with order by (result)
--Testcase 1881:
SELECT value1, strcmp(str1, str2) FROM s3 ORDER BY strcmp(str1, str2);
ERROR:  stub strcmp(text, text) is called
CONTEXT:  PL/pgSQL function strcmp(text,text) line 3 at RAISE
-- select strcmp with order by index (result)
--Testcase 1882:
SELECT value1, strcmp(str1, str2) FROM s3 ORDER BY 2,1;
ERROR:  stub strcmp(text, text) is called
CONTEXT:  PL/pgSQL function strcmp(text,text) line 3 at RAISE
-- select strcmp with order by index (result)
--Testcase 1883:
SELECT value1, strcmp(str1, str2) FROM s3 ORDER BY 1,2;
ERROR:  stub strcmp(text, text) is called
CONTEXT:  PL/pgSQL function strcmp(text,text) line 3 at RAISE
-- select strcmp with group by (explain)
--Testcase 1884:
EXPLAIN VERBOSE
SELECT count(value1), strcmp(str1, str2) FROM s3 GROUP BY strcmp(str1, str2);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(value1)), (strcmp(str1, str2))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), strcmp(`str1`, `str2`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select strcmp with group by (result)
--Testcase 1885:
SELECT count(value1), strcmp(str1, str2) FROM s3 GROUP BY strcmp(str1, str2);
 count | strcmp 
-------+--------
     6 |      1
(1 row)

-- select strcmp with group by index (result)
--Testcase 1886:
SELECT value1, strcmp(str1, str2) FROM s3 GROUP BY 2,1;
 value1 | strcmp 
--------+--------
    0.1 |      1
    0.2 |      1
    0.3 |      1
    1.1 |      1
    2.2 |      1
    3.3 |      1
(6 rows)

-- select strcmp with group by having (explain)
--Testcase 1887:
EXPLAIN VERBOSE
SELECT count(value1), strcmp(str1, str2) FROM s3 GROUP BY strcmp(str1, str2), str1, str2 HAVING strcmp(str1, str2) IS NOT NULL;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=76)
   Output: (count(value1)), (strcmp(str1, str2)), str1, str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), strcmp(`str1`, `str2`), `str1`, `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3, 4 HAVING ((strcmp(`str1`, `str2`) IS NOT NULL))
(5 rows)

-- select strcmp with group by having (result)
--Testcase 1888:
SELECT count(value1), strcmp(str1, str2) FROM s3 GROUP BY strcmp(str1, str2), str1, str2 HAVING strcmp(str1, str2) IS NOT NULL;
 count | strcmp 
-------+--------
     6 |      1
(1 row)

-- select strcmp with group by index having (result)
--Testcase 1889:
SELECT value1, strcmp(str1, str2) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | strcmp 
--------+--------
    1.1 |      1
    2.2 |      1
    3.3 |      1
(3 rows)

-- ===============================================================================
-- test substr()
-- ===============================================================================
-- select substr (stub function, explain)
--Testcase 1890:
EXPLAIN VERBOSE
SELECT substr(str1, 3), substr(str2, 3, 4) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: substr(str1, 3), substr(str2, 3, 4)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select substr (stub function, result)
--Testcase 1891:
SELECT substr(str1, 3), substr(str2, 3, 4) FROM s3;
 substr  | substr 
---------+--------
 -XYZ--- |  XYZ
 -XYZ--- |  XYZ
 -XYZ--- |  XYZ
 -XYZ--- |  XYZ
 -XYZ--- |  XYZ
 -XYZ--- |  XYZ
(6 rows)

-- select substr (stub function, not pushdown constraints, explain)
--Testcase 1892:
EXPLAIN VERBOSE
SELECT value1, substr(str2, 3, 4) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, substr(str2, 3, 4)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select substr (stub function, not pushdown constraints, result)
--Testcase 1893:
SELECT value1, substr(str2, 3, 4) FROM s3 WHERE to_hex(value2) = '64';
 value1 | substr 
--------+--------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
(3 rows)

-- select substr (stub function, pushdown constraints, explain)
--Testcase 1894:
EXPLAIN VERBOSE
SELECT value1, substr(str2, 3, 4) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, substr(str2, 3, 4)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select substr (stub function, pushdown constraints, result)
--Testcase 1895:
SELECT value1, substr(str2, 3, 4) FROM s3 WHERE value2 != 200;
 value1 | substr 
--------+--------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
(3 rows)

-- select substr with non pushdown func and explicit constant (explain)
--Testcase 1896:
EXPLAIN VERBOSE
SELECT substr(str2, 3, 4), pi(), 4.1 FROM s3;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: substr(str2, 3, 4), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select substr with non pushdown func and explicit constant (result)
--Testcase 1897:
SELECT substr(str2, 3, 4), pi(), 4.1 FROM s3;
 substr |        pi         | ?column? 
--------+-------------------+----------
  XYZ   | 3.141592653589793 |      4.1
  XYZ   | 3.141592653589793 |      4.1
  XYZ   | 3.141592653589793 |      4.1
  XYZ   | 3.141592653589793 |      4.1
  XYZ   | 3.141592653589793 |      4.1
  XYZ   | 3.141592653589793 |      4.1
(6 rows)

-- select substr with order by (explain)
--Testcase 1898:
EXPLAIN VERBOSE
SELECT value1, substr(str2, 3, 4) FROM s3 ORDER BY substr(str2, 3, 4);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, substr(str2, 3, 4)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY substr(`str2`, 3, 4) IS NULL ASC, substr(`str2`, 3, 4) ASC
(4 rows)

-- select substr with order by (result)
--Testcase 1899:
SELECT value1, substr(str2, 3, 4) FROM s3 ORDER BY substr(str2, 3, 4);
 value1 | substr 
--------+--------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(6 rows)

-- select substr with order by index (result)
--Testcase 1900:
SELECT value1, substr(str2, 3, 4) FROM s3 ORDER BY 2,1;
 value1 | substr 
--------+--------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(6 rows)

-- select substr with order by index (result)
--Testcase 1901:
SELECT value1, substr(str2, 3, 4) FROM s3 ORDER BY 1,2;
 value1 | substr 
--------+--------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(6 rows)

-- select substr with group by (explain)
--Testcase 1902:
EXPLAIN VERBOSE
SELECT count(value1), substr(str2, 3, 4) FROM s3 GROUP BY substr(str2, 3, 4);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (substr(str2, 3, 4))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), substr(`str2`, 3, 4) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select substr with group by (result)
--Testcase 1903:
SELECT count(value1), substr(str2, 3, 4) FROM s3 GROUP BY substr(str2, 3, 4);
 count | substr 
-------+--------
     6 |  XYZ
(1 row)

-- select substr with group by index (result)
--Testcase 1904:
SELECT value1, substr(str2, 3, 4) FROM s3 GROUP BY 2,1;
 value1 | substr 
--------+--------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(6 rows)

-- select substr with group by having (explain)
--Testcase 1905:
EXPLAIN VERBOSE
SELECT count(value1), substr(str2, 3, 4) FROM s3 GROUP BY substr(str2, 3, 4), str2 HAVING substr(str2, 3, 4) IS NOT NULL;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (substr(str2, 3, 4)), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), substr(`str2`, 3, 4), `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((substr(`str2`, 3, 4) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select substr with group by having (result)
--Testcase 1906:
SELECT count(value1), substr(str2, 3, 4) FROM s3 GROUP BY substr(str2, 3, 4), str2 HAVING substr(str2, 3, 4) IS NOT NULL;
 count | substr 
-------+--------
     6 |  XYZ
(1 row)

-- select substr with group by index having (result)
--Testcase 1907:
SELECT value1, substr(str2, 3, 4) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | substr 
--------+--------
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(3 rows)

-- ===============================================================================
-- test substring()
-- ===============================================================================
-- select substring (stub function, explain)
--Testcase 1908:
EXPLAIN VERBOSE
SELECT substring(str1, 3), substring(str2, 3, 4) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: "substring"(str1, 3), "substring"(str2, 3, 4)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select substring (stub function, result)
--Testcase 1909:
SELECT substring(str1, 3), substring(str2, 3, 4) FROM s3;
 substring | substring 
-----------+-----------
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
(6 rows)

-- select substring (stub function, explain)
--Testcase 1910:
EXPLAIN VERBOSE
SELECT substring(str1 FROM 3), substring(str2 FROM 3 FOR 4) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: SUBSTRING(str1 FROM 3), SUBSTRING(str2 FROM 3 FOR 4)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select substring (stub function, result)
--Testcase 1911:
SELECT substring(str1 FROM 3), substring(str2 FROM 3 FOR 4) FROM s3;
 substring | substring 
-----------+-----------
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
 -XYZ---   |  XYZ
(6 rows)

-- select substring (stub function, not pushdown constraints, explain)
--Testcase 1912:
EXPLAIN VERBOSE
SELECT value1, substring(str2, 3, 4) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, "substring"(str2, 3, 4)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select substring (stub function, not pushdown constraints, result)
--Testcase 1913:
SELECT value1, substring(str2, 3, 4) FROM s3 WHERE to_hex(value2) = '64';
 value1 | substring 
--------+-----------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
(3 rows)

-- select substring (stub function, pushdown constraints, explain)
--Testcase 1914:
EXPLAIN VERBOSE
SELECT value1, substring(str2 FROM 3 FOR 4) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, SUBSTRING(str2 FROM 3 FOR 4)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select substring (stub function, pushdown constraints, result)
--Testcase 1915:
SELECT value1, substring(str2 FROM 3 FOR 4) FROM s3 WHERE value2 != 200;
 value1 | substring 
--------+-----------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
(3 rows)

-- select substring with non pushdown func and explicit constant (explain)
--Testcase 1916:
EXPLAIN VERBOSE
SELECT substring(str2 FROM 3 FOR 4), pi(), 4.1 FROM s3;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: SUBSTRING(str2 FROM 3 FOR 4), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select substring with non pushdown func and explicit constant (result)
--Testcase 1917:
SELECT substring(str2 FROM 3 FOR 4), pi(), 4.1 FROM s3;
 substring |        pi         | ?column? 
-----------+-------------------+----------
  XYZ      | 3.141592653589793 |      4.1
  XYZ      | 3.141592653589793 |      4.1
  XYZ      | 3.141592653589793 |      4.1
  XYZ      | 3.141592653589793 |      4.1
  XYZ      | 3.141592653589793 |      4.1
  XYZ      | 3.141592653589793 |      4.1
(6 rows)

-- select substring with order by (explain)
--Testcase 1918:
EXPLAIN VERBOSE
SELECT value1, substring(str2 FROM 3 FOR 4) FROM s3 ORDER BY substring(str2 FROM 3 FOR 4);
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, SUBSTRING(str2 FROM 3 FOR 4)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY substring(`str2`, 3, 4) IS NULL ASC, substring(`str2`, 3, 4) ASC
(4 rows)

-- select substring with order by (result)
--Testcase 1919:
SELECT value1, substring(str2 FROM 3 FOR 4) FROM s3 ORDER BY substring(str2 FROM 3 FOR 4);
 value1 | substring 
--------+-----------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(6 rows)

-- select substring with order by index (result)
--Testcase 1920:
SELECT value1, substring(str2 FROM 3 FOR 4) FROM s3 ORDER BY 2,1;
 value1 | substring 
--------+-----------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(6 rows)

-- select substring with order by index (result)
--Testcase 1921:
SELECT value1, substring(str2 FROM 3 FOR 4) FROM s3 ORDER BY 1,2;
 value1 | substring 
--------+-----------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(6 rows)

-- select substring with group by (explain)
--Testcase 1922:
EXPLAIN VERBOSE
SELECT count(value1), substring(str2, 3, 4) FROM s3 GROUP BY substring(str2, 3, 4);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), ("substring"(str2, 3, 4))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), substring(`str2`, 3, 4) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select substring with group by (result)
--Testcase 1923:
SELECT count(value1), substring(str2, 3, 4) FROM s3 GROUP BY substring(str2, 3, 4);
 count | substring 
-------+-----------
     6 |  XYZ
(1 row)

-- select substring with group by index (result)
--Testcase 1924:
SELECT value1, substring(str2, 3, 4) FROM s3 GROUP BY 2,1;
 value1 | substring 
--------+-----------
    0.1 |  XYZ
    0.2 |  XYZ
    0.3 |  XYZ
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(6 rows)

-- select substring with group by having (explain)
--Testcase 1925:
EXPLAIN VERBOSE
SELECT count(value1), substring(str2, 3, 4) FROM s3 GROUP BY substring(str2, 3, 4), str2 HAVING substring(str2, 3, 4) IS NOT NULL;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), ("substring"(str2, 3, 4)), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), substring(`str2`, 3, 4), `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((substring(`str2`, 3, 4) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select substring with group by having (result)
--Testcase 1926:
SELECT count(value1), substring(str2, 3, 4) FROM s3 GROUP BY substring(str2, 3, 4), str2 HAVING substring(str2, 3, 4) IS NOT NULL;
 count | substring 
-------+-----------
     6 |  XYZ
(1 row)

-- select substring with group by index having (result)
--Testcase 1927:
SELECT value1, substring(str2, 3, 4) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | substring 
--------+-----------
    1.1 |  XYZ
    2.2 |  XYZ
    3.3 |  XYZ
(3 rows)

-- ===============================================================================
-- test substring_index()
-- ===============================================================================
-- select substring_index (stub function, explain)
--Testcase 1928:
EXPLAIN VERBOSE
SELECT substring_index(str1, '-', 5), substring_index(str1, '-', -5) FROM s3;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..161.17 rows=1462 width=64)
   Output: substring_index(str1, '-'::text, '5'::bigint), substring_index(str1, '-'::text, '-5'::bigint)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select substring_index (stub function, result)
--Testcase 1929:
SELECT substring_index(str1, '-', 5), substring_index(str1, '-', -5) FROM s3;
ERROR:  stub substring_index(text, text, bigint) is called
CONTEXT:  PL/pgSQL function substring_index(text,text,bigint) line 3 at RAISE
-- select substring_index (stub function, not pushdown constraints, explain)
--Testcase 1930:
EXPLAIN VERBOSE
SELECT value1, substring_index(str1, '-', 5) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, substring_index(str1, '-'::text, '5'::bigint)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select substring_index (stub function, not pushdown constraints, result)
--Testcase 1931:
SELECT value1, substring_index(str1, '-', 5) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub substring_index(text, text, bigint) is called
CONTEXT:  PL/pgSQL function substring_index(text,text,bigint) line 3 at RAISE
-- select substring_index (stub function, pushdown constraints, explain)
--Testcase 1932:
EXPLAIN VERBOSE
SELECT value1, substring_index(str1, '-', 5) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, substring_index(str1, '-'::text, '5'::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select substring_index (stub function, pushdown constraints, result)
--Testcase 1933:
SELECT value1, substring_index(str1, '-', 5) FROM s3 WHERE value2 != 200;
ERROR:  stub substring_index(text, text, bigint) is called
CONTEXT:  PL/pgSQL function substring_index(text,text,bigint) line 3 at RAISE
-- select substring_index with non pushdown func and explicit constant (explain)
--Testcase 1934:
EXPLAIN VERBOSE
SELECT substring_index(str1, '-', 5), pi(), 4.1 FROM s3;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: substring_index(str1, '-'::text, '5'::bigint), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select substring_index with non pushdown func and explicit constant (result)
--Testcase 1935:
SELECT substring_index(str1, '-', 5), pi(), 4.1 FROM s3;
ERROR:  stub substring_index(text, text, bigint) is called
CONTEXT:  PL/pgSQL function substring_index(text,text,bigint) line 3 at RAISE
-- select substring_index with order by (explain)
--Testcase 1936:
EXPLAIN VERBOSE
SELECT value1, substring_index(str1, '-', 5) FROM s3 ORDER BY substring_index(str1, '-', 5);
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, substring_index(str1, '-'::text, '5'::bigint)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY substring_index(`str1`, '-', 5) IS NULL ASC, substring_index(`str1`, '-', 5) ASC
(4 rows)

-- select substring_index with order by (result)
--Testcase 1937:
SELECT value1, substring_index(str1, '-', 5) FROM s3 ORDER BY substring_index(str1, '-', 5);
ERROR:  stub substring_index(text, text, bigint) is called
CONTEXT:  PL/pgSQL function substring_index(text,text,bigint) line 3 at RAISE
-- select substring_index with order by index (result)
--Testcase 1938:
SELECT value1, substring_index(str1, '-', 5) FROM s3 ORDER BY 2,1;
ERROR:  stub substring_index(text, text, bigint) is called
CONTEXT:  PL/pgSQL function substring_index(text,text,bigint) line 3 at RAISE
-- select substring_index with order by index (result)
--Testcase 1939:
SELECT value1, substring_index(str1, '-', 5) FROM s3 ORDER BY 1,2;
ERROR:  stub substring_index(text, text, bigint) is called
CONTEXT:  PL/pgSQL function substring_index(text,text,bigint) line 3 at RAISE
-- select substring_index with group by (explain)
--Testcase 1940:
EXPLAIN VERBOSE
SELECT count(value1), substring_index(str1, '-', 5) FROM s3 GROUP BY substring_index(str1, '-', 5);
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (substring_index(str1, '-'::text, '5'::bigint))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), substring_index(`str1`, '-', 5) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select substring_index with group by (result)
--Testcase 1941:
SELECT count(value1), substring_index(str1, '-', 5) FROM s3 GROUP BY substring_index(str1, '-', 5);
 count | substring_index 
-------+-----------------
     6 | ---XYZ-
(1 row)

-- select substring_index with group by index (result)
--Testcase 1942:
SELECT value1, substring_index(str1, '-', 5) FROM s3 GROUP BY 2,1;
 value1 | substring_index 
--------+-----------------
    0.1 | ---XYZ-
    0.2 | ---XYZ-
    0.3 | ---XYZ-
    1.1 | ---XYZ-
    2.2 | ---XYZ-
    3.3 | ---XYZ-
(6 rows)

-- select substring_index with group by having (explain)
--Testcase 1943:
EXPLAIN VERBOSE
SELECT count(value1), substring_index(str1, '-', 5) FROM s3 GROUP BY substring_index(str1, '-', 5), str1 HAVING substring_index(str1, '-', 5) IS NOT NULL;
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (substring_index(str1, '-'::text, '5'::bigint)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), substring_index(`str1`, '-', 5), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((substring_index(`str1`, '-', 5) IS NOT NULL))
(5 rows)

-- select substring_index with group by having (result)
--Testcase 1944:
SELECT count(value1), substring_index(str1, '-', 5) FROM s3 GROUP BY substring_index(str1, '-', 5), str1 HAVING substring_index(str1, '-', 5) IS NOT NULL;
 count | substring_index 
-------+-----------------
     6 | ---XYZ-
(1 row)

-- select substring_index with group by index having (result)
--Testcase 1945:
SELECT value1, substring_index(str1, '-', 5) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | substring_index 
--------+-----------------
    1.1 | ---XYZ-
    2.2 | ---XYZ-
    3.3 | ---XYZ-
(3 rows)

-- ===============================================================================
-- test to_base64()
-- ===============================================================================
-- select to_base64 (stub function, explain)
--Testcase 1946:
EXPLAIN VERBOSE
SELECT id, to_base64(tag1), to_base64(str1), to_base64(str2) FROM s3;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..134.75 rows=660 width=100)
   Output: id, to_base64(tag1), to_base64(str1), to_base64(str2)
   Local server startup cost: 10
   Remote query: SELECT `id`, `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select to_base64 (stub function, result)
--Testcase 1947:
SELECT id, to_base64(tag1), to_base64(str1), to_base64(str2) FROM s3;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select to_base64 (stub function, not pushdown constraints, explain)
--Testcase 1948:
EXPLAIN VERBOSE
SELECT value1, to_base64(str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, to_base64(str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select to_base64 (stub function, not pushdown constraints, result)
--Testcase 1949:
SELECT value1, to_base64(str1) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select to_base64 (stub function, pushdown constraints, explain)
--Testcase 1950:
EXPLAIN VERBOSE
SELECT value1, to_base64(str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, to_base64(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select to_base64 (stub function, pushdown constraints, result)
--Testcase 1951:
SELECT value1, to_base64(str1) FROM s3 WHERE value2 != 200;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select to_base64 with non pushdown func and explicit constant (explain)
--Testcase 1952:
EXPLAIN VERBOSE
SELECT to_base64(str1), pi(), 4.1 FROM s3;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: to_base64(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select to_base64 with non pushdown func and explicit constant (result)
--Testcase 1953:
SELECT to_base64(str1), pi(), 4.1 FROM s3;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select to_base64 with order by (explain)
--Testcase 1954:
EXPLAIN VERBOSE
SELECT value1, to_base64(str1) FROM s3 ORDER BY to_base64(str1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, to_base64(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY to_base64(`str1`) IS NULL ASC, to_base64(`str1`) ASC
(4 rows)

-- select to_base64 with order by (result)
--Testcase 1955:
SELECT value1, to_base64(str1) FROM s3 ORDER BY to_base64(str1);
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select to_base64 with order by index (result)
--Testcase 1956:
SELECT value1, to_base64(str1) FROM s3 ORDER BY 2,1;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select to_base64 with order by index (result)
--Testcase 1957:
SELECT value1, to_base64(str1) FROM s3 ORDER BY 2,1;
ERROR:  stub to_base64(text) is called
CONTEXT:  PL/pgSQL function to_base64(text) line 3 at RAISE
-- select to_base64 with group by (explain)
--Testcase 1958:
EXPLAIN VERBOSE
SELECT count(value1), to_base64(str1) FROM s3 GROUP BY to_base64(str1);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (to_base64(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), to_base64(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select to_base64 with group by (result)
--Testcase 1959:
SELECT count(value1), to_base64(str1) FROM s3 GROUP BY to_base64(str1);
 count |  to_base64   
-------+--------------
     6 | LS0tWFlaLS0t
(1 row)

-- select to_base64 with group by index (result)
--Testcase 1960:
SELECT value1, to_base64(str1) FROM s3 GROUP BY 2,1;
 value1 |  to_base64   
--------+--------------
    0.1 | LS0tWFlaLS0t
    0.2 | LS0tWFlaLS0t
    0.3 | LS0tWFlaLS0t
    1.1 | LS0tWFlaLS0t
    2.2 | LS0tWFlaLS0t
    3.3 | LS0tWFlaLS0t
(6 rows)

-- select to_base64 with group by having (explain)
--Testcase 1961:
EXPLAIN VERBOSE
SELECT count(value1), to_base64(str1) FROM s3 GROUP BY to_base64(str1), str1 HAVING to_base64(str1) IS NOT NULL;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (to_base64(str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), to_base64(`str1`), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((to_base64(`str1`) IS NOT NULL))
(5 rows)

-- select to_base64 with group by having (result)
--Testcase 1962:
SELECT count(value1), to_base64(str1) FROM s3 GROUP BY to_base64(str1), str1 HAVING to_base64(str1) IS NOT NULL;
 count |  to_base64   
-------+--------------
     6 | LS0tWFlaLS0t
(1 row)

-- select to_base64 with group by index having (result)
--Testcase 1963:
SELECT value1, to_base64(str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |  to_base64   
--------+--------------
    1.1 | LS0tWFlaLS0t
    2.2 | LS0tWFlaLS0t
    3.3 | LS0tWFlaLS0t
(3 rows)

-- ===============================================================================
-- test trim()
-- ===============================================================================
-- select trim (stub function, explain)
--Testcase 1964:
EXPLAIN VERBOSE
SELECT trim(str1), trim(str2) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: TRIM(BOTH FROM str1), TRIM(BOTH FROM str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select trim (stub function, result)
--Testcase 1965:
SELECT trim(str1), trim(str2) FROM s3;
   btrim   | btrim 
-----------+-------
 ---XYZ--- | XYZ
 ---XYZ--- | XYZ
 ---XYZ--- | XYZ
 ---XYZ--- | XYZ
 ---XYZ--- | XYZ
 ---XYZ--- | XYZ
(6 rows)

-- select trim (stub function, explain)
--Testcase 1966:
EXPLAIN VERBOSE
SELECT trim(LEADING '-' FROM str1), trim(LEADING ' ' FROM str2) FROM s3;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: TRIM(LEADING '-'::text FROM str1), TRIM(LEADING ' '::text FROM str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select trim (stub function, result)
--Testcase 1967:
SELECT trim(LEADING '-' FROM str1), trim(LEADING ' ' FROM str2) FROM s3;
 ltrim  | ltrim  
--------+--------
 XYZ--- | XYZ   
 XYZ--- | XYZ   
 XYZ--- | XYZ   
 XYZ--- | XYZ   
 XYZ--- | XYZ   
 XYZ--- | XYZ   
(6 rows)

-- select trim (stub function, explain)
--Testcase 1968:
EXPLAIN VERBOSE
SELECT trim(BOTH '-' FROM str1), trim(BOTH ' ' FROM str2) FROM s3;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: TRIM(BOTH '-'::text FROM str1), TRIM(BOTH ' '::text FROM str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select trim (stub function, result)
--Testcase 1969:
SELECT trim(BOTH '-' FROM str1), trim(BOTH ' ' FROM str2) FROM s3;
 btrim | btrim 
-------+-------
 XYZ   | XYZ
 XYZ   | XYZ
 XYZ   | XYZ
 XYZ   | XYZ
 XYZ   | XYZ
 XYZ   | XYZ
(6 rows)

-- select trim (stub function, explain)
--Testcase 1970:
EXPLAIN VERBOSE
SELECT trim(TRAILING '-' FROM str1), trim(TRAILING ' ' FROM str2) FROM s3;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: TRIM(TRAILING '-'::text FROM str1), TRIM(TRAILING ' '::text FROM str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select trim (stub function, result)
--Testcase 1971:
SELECT trim(TRAILING '-' FROM str1), trim(TRAILING ' ' FROM str2) FROM s3;
 rtrim  | rtrim  
--------+--------
 ---XYZ |    XYZ
 ---XYZ |    XYZ
 ---XYZ |    XYZ
 ---XYZ |    XYZ
 ---XYZ |    XYZ
 ---XYZ |    XYZ
(6 rows)

-- select trim (stub function, explain)
--Testcase 1972:
EXPLAIN VERBOSE
SELECT trim('-' FROM str1), trim(' ' FROM str2) FROM s3;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..142.55 rows=930 width=64)
   Output: TRIM(BOTH '-'::text FROM str1), TRIM(BOTH ' '::text FROM str2)
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select trim (stub function, result)
--Testcase 1973:
SELECT trim('-' FROM str1), trim(' ' FROM str2) FROM s3;
 btrim | btrim 
-------+-------
 XYZ   | XYZ
 XYZ   | XYZ
 XYZ   | XYZ
 XYZ   | XYZ
 XYZ   | XYZ
 XYZ   | XYZ
(6 rows)

-- select trim (stub function, not pushdown constraints, explain)
--Testcase 1974:
EXPLAIN VERBOSE
SELECT value1, trim('-' FROM str1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, TRIM(BOTH '-'::text FROM str1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select trim (stub function, not pushdown constraints, result)
--Testcase 1975:
SELECT value1, trim('-' FROM str1)  FROM s3 WHERE to_hex(value2) = '64';
 value1 | btrim 
--------+-------
    0.1 | XYZ
    0.2 | XYZ
    0.3 | XYZ
(3 rows)

-- select trim (stub function, pushdown constraints, explain)
--Testcase 1976:
EXPLAIN VERBOSE
SELECT value1, trim(TRAILING '-' FROM str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, TRIM(TRAILING '-'::text FROM str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select trim (stub function, pushdown constraints, result)
--Testcase 1977:
SELECT value1, trim(TRAILING '-' FROM str1) FROM s3 WHERE value2 != 200;
 value1 | rtrim  
--------+--------
    0.1 | ---XYZ
    0.2 | ---XYZ
    0.3 | ---XYZ
(3 rows)

-- select trim with non pushdown func and explicit constant (explain)
--Testcase 1978:
EXPLAIN VERBOSE
SELECT trim(TRAILING '-' FROM str1), pi(), 4.1 FROM s3;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: TRIM(TRAILING '-'::text FROM str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select trim with non pushdown func and explicit constant (result)
--Testcase 1979:
SELECT trim(TRAILING '-' FROM str1), pi(), 4.1 FROM s3;
 rtrim  |        pi         | ?column? 
--------+-------------------+----------
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
 ---XYZ | 3.141592653589793 |      4.1
(6 rows)

-- select trim with order by (explain)
--Testcase 1980:
EXPLAIN VERBOSE
SELECT value1, trim(TRAILING '-' FROM str1) FROM s3 ORDER BY trim(TRAILING '-' FROM str1);
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, TRIM(TRAILING '-'::text FROM str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY trim(TRAILING '-' FROM `str1`) IS NULL ASC, trim(TRAILING '-' FROM `str1`) ASC
(4 rows)

-- select trim with order by (result)
--Testcase 1981:
SELECT value1, trim(TRAILING '-' FROM str1) FROM s3 ORDER BY trim(TRAILING '-' FROM str1);
 value1 | rtrim  
--------+--------
    0.1 | ---XYZ
    0.2 | ---XYZ
    0.3 | ---XYZ
    1.1 | ---XYZ
    2.2 | ---XYZ
    3.3 | ---XYZ
(6 rows)

-- select trim with order by index (result)
--Testcase 1982:
SELECT value1, trim('-' FROM str1) FROM s3 ORDER BY 2,1;
 value1 | btrim 
--------+-------
    0.1 | XYZ
    0.2 | XYZ
    0.3 | XYZ
    1.1 | XYZ
    2.2 | XYZ
    3.3 | XYZ
(6 rows)

-- select trim with order by index (result)
--Testcase 1983:
SELECT value1, trim('-' FROM str1) FROM s3 ORDER BY 1,2;
 value1 | btrim 
--------+-------
    0.1 | XYZ
    0.2 | XYZ
    0.3 | XYZ
    1.1 | XYZ
    2.2 | XYZ
    3.3 | XYZ
(6 rows)

-- select trim with group by (explain)
--Testcase 1984:
EXPLAIN VERBOSE
SELECT count(value1), trim('-' FROM str1) FROM s3 GROUP BY trim('-' FROM str1);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (TRIM(BOTH '-'::text FROM str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), trim(BOTH '-' FROM `str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select trim with group by (result)
--Testcase 1985:
SELECT count(value1), trim('-' FROM str1) FROM s3 GROUP BY trim('-' FROM str1);
 count | btrim 
-------+-------
     6 | XYZ
(1 row)

-- select trim with group by index (result)
--Testcase 1986:
SELECT value1, trim('-' FROM str1) FROM s3 GROUP BY 2,1;
 value1 | btrim 
--------+-------
    0.1 | XYZ
    0.2 | XYZ
    0.3 | XYZ
    1.1 | XYZ
    2.2 | XYZ
    3.3 | XYZ
(6 rows)

-- select trim with group by having (explain)
--Testcase 1987:
EXPLAIN VERBOSE
SELECT count(value1), trim('-' FROM str1) FROM s3 GROUP BY trim('-' FROM str1) , str1 HAVING trim('-' FROM str1) IS NOT NULL;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (TRIM(BOTH '-'::text FROM str1)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), trim(BOTH '-' FROM `str1`), `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((trim(BOTH '-' FROM `str1`) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select trim with group by having (result)
--Testcase 1988:
SELECT count(value1), trim('-' FROM str1) FROM s3 GROUP BY trim('-' FROM str1) , str1 HAVING trim('-' FROM str1) IS NOT NULL;
 count | btrim 
-------+-------
     6 | XYZ
(1 row)

-- select trim with group by index having (result)
--Testcase 1989:
SELECT value1, trim('-' FROM str1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | btrim 
--------+-------
    1.1 | XYZ
    2.2 | XYZ
    3.3 | XYZ
(3 rows)

-- ===============================================================================
-- test ucase()
-- ===============================================================================
-- select ucase (stub function, explain)
--Testcase 1990:
EXPLAIN VERBOSE
SELECT ucase(tag1) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=32)
   Output: ucase(tag1)
   Local server startup cost: 10
   Remote query: SELECT `tag1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ucase (stub function, result)
--Testcase 1991:
SELECT ucase(tag1) FROM s3;
ERROR:  stub ucase(text) is called
CONTEXT:  PL/pgSQL function ucase(text) line 3 at RAISE
-- select ucase (stub function, not pushdown constraints, explain)
--Testcase 1992:
EXPLAIN VERBOSE
SELECT value1, ucase(tag1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, ucase(tag1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select ucase (stub function, not pushdown constraints, result)
--Testcase 1993:
SELECT value1, ucase(tag1) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub ucase(text) is called
CONTEXT:  PL/pgSQL function ucase(text) line 3 at RAISE
-- select ucase (stub function, pushdown constraints, explain)
--Testcase 1994:
EXPLAIN VERBOSE
SELECT value1, ucase(tag1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, ucase(tag1)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `value1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select ucase (stub function, pushdown constraints, result)
--Testcase 1995:
SELECT value1, ucase(tag1) FROM s3 WHERE value2 != 200;
ERROR:  stub ucase(text) is called
CONTEXT:  PL/pgSQL function ucase(text) line 3 at RAISE
-- select ucase with non pushdown func and explicit constant (explain)
--Testcase 1996:
EXPLAIN VERBOSE
SELECT ucase(tag1), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: ucase(tag1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `tag1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ucase with non pushdown func and explicit constant (result)
--Testcase 1997:
SELECT ucase(tag1), pi(), 4.1 FROM s3;
ERROR:  stub ucase(text) is called
CONTEXT:  PL/pgSQL function ucase(text) line 3 at RAISE
-- select ucase with order by (explain)
--Testcase 1998:
EXPLAIN VERBOSE
SELECT value1, ucase(tag1) FROM s3 ORDER BY ucase(tag1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, ucase(tag1)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `value1` FROM `mysql_fdw_regress`.`s3` ORDER BY ucase(`tag1`) IS NULL ASC, ucase(`tag1`) ASC
(4 rows)

-- select ucase with order by (result)
--Testcase 1999:
SELECT value1, ucase(tag1) FROM s3 ORDER BY ucase(tag1);
ERROR:  stub ucase(text) is called
CONTEXT:  PL/pgSQL function ucase(text) line 3 at RAISE
-- select ucase with order by index (result)
--Testcase 2000:
SELECT value1, ucase(tag1) FROM s3 ORDER BY 2,1;
ERROR:  stub ucase(text) is called
CONTEXT:  PL/pgSQL function ucase(text) line 3 at RAISE
-- select ucase with order by index (result)
--Testcase 2001:
SELECT value1, ucase(tag1) FROM s3 ORDER BY 1,2;
ERROR:  stub ucase(text) is called
CONTEXT:  PL/pgSQL function ucase(text) line 3 at RAISE
-- select ucase with group by (explain)
--Testcase 2002:
EXPLAIN VERBOSE
SELECT count(value1), ucase(tag1) FROM s3 GROUP BY ucase(tag1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (ucase(tag1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ucase(`tag1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select ucase with group by (result)
--Testcase 2003:
SELECT count(value1), ucase(tag1) FROM s3 GROUP BY ucase(tag1);
 count | ucase 
-------+-------
     3 | A
     3 | B
(2 rows)

-- select ucase with group by index (result)
--Testcase 2004:
SELECT value1, ucase(tag1) FROM s3 GROUP BY 2,1;
 value1 | ucase 
--------+-------
    0.1 | A
    0.2 | A
    0.3 | A
    1.1 | B
    2.2 | B
    3.3 | B
(6 rows)

-- select ucase with group by having (explain)
--Testcase 2005:
EXPLAIN VERBOSE
SELECT count(value1), ucase(tag1) FROM s3 GROUP BY ucase(tag1), tag1 HAVING ucase(tag1) IS NOT NULL;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (ucase(tag1)), tag1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), ucase(`tag1`), `tag1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((ucase(`tag1`) IS NOT NULL))
(5 rows)

-- select ucase with group by having (result)
--Testcase 2006:
SELECT count(value1), ucase(tag1) FROM s3 GROUP BY ucase(tag1), tag1 HAVING ucase(tag1) IS NOT NULL;
 count | ucase 
-------+-------
     3 | A
     3 | B
(2 rows)

-- select ucase with group by index having (result)
--Testcase 2007:
SELECT value1, ucase(tag1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | ucase 
--------+-------
    1.1 | B
    2.2 | B
    3.3 | B
(3 rows)

-- ===============================================================================
-- test unhex()
-- ===============================================================================
-- select unhex (stub function, explain)
--Testcase 2008:
EXPLAIN VERBOSE
SELECT unhex(hex(str1)), unhex(hex(str2)) FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..147.20 rows=930 width=64)
   Output: unhex(hex(str1)), unhex(hex(str2))
   Local server startup cost: 10
   Remote query: SELECT `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select unhex (stub function, result)
--Testcase 2009:
SELECT unhex(hex(str1)), unhex(hex(str2)) FROM s3;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select unhex (stub function, not pushdown constraints, explain)
--Testcase 2010:
EXPLAIN VERBOSE
SELECT value1, unhex(hex(str2)) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.35 rows=6 width=40)
   Output: value1, unhex(hex(str2))
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select unhex (stub function, not pushdown constraints, result)
--Testcase 2011:
SELECT value1, unhex(hex(str2)) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select unhex (stub function, pushdown constraints, explain)
--Testcase 2012:
EXPLAIN VERBOSE
SELECT value1, unhex(hex(str2)) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.85 rows=1274 width=40)
   Output: value1, unhex(hex(str2))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select unhex (stub function, pushdown constraints, result)
--Testcase 2013:
SELECT value1, unhex(hex(str2)) FROM s3 WHERE value2 != 200;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select unhex with non pushdown func and explicit constant (explain)
--Testcase 2014:
EXPLAIN VERBOSE
SELECT unhex(hex(str2)), pi(), 4.1 FROM s3;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..161.17 rows=1462 width=72)
   Output: unhex(hex(str2)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select unhex with non pushdown func and explicit constant (result)
--Testcase 2015:
SELECT unhex(hex(str2)), pi(), 4.1 FROM s3;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select unhex with order by (explain)
--Testcase 2016:
EXPLAIN VERBOSE
SELECT value1, unhex(hex(str2)) FROM s3 ORDER BY unhex(hex(str2));
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.15 rows=30 width=40)
   Output: value1, unhex(hex(str2))
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str2` FROM `mysql_fdw_regress`.`s3` ORDER BY unhex(hex(`str2`)) IS NULL ASC, unhex(hex(`str2`)) ASC
(4 rows)

-- select unhex with order by (result)
--Testcase 2017:
SELECT value1, unhex(hex(str2)) FROM s3 ORDER BY unhex(hex(str2));
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select unhex with order by index (result)
--Testcase 2018:
SELECT value1, unhex(hex(str2)) FROM s3 ORDER BY 2,1;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select unhex with order by index (result)
--Testcase 2019:
SELECT value1, unhex(hex(str2)) FROM s3 ORDER BY 1,2;
ERROR:  stub hex(text) is called
CONTEXT:  PL/pgSQL function hex(text) line 3 at RAISE
-- select unhex with group by (explain)
--Testcase 2020:
EXPLAIN VERBOSE
SELECT count(value1), unhex(hex(str2)) FROM s3 GROUP BY unhex(hex(str2));
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (unhex(hex(str2)))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), unhex(hex(`str2`)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select unhex with group by (result)
--Testcase 2021:
SELECT count(value1), unhex(hex(str2)) FROM s3 GROUP BY unhex(hex(str2));
 count |   unhex   
-------+-----------
     6 |    XYZ   
(1 row)

-- select unhex with group by index (result)
--Testcase 2022:
SELECT value1, unhex(hex(str2)) FROM s3 GROUP BY 2,1;
 value1 |   unhex   
--------+-----------
    0.1 |    XYZ   
    0.2 |    XYZ   
    0.3 |    XYZ   
    1.1 |    XYZ   
    2.2 |    XYZ   
    3.3 |    XYZ   
(6 rows)

-- select unhex with group by having (explain)
--Testcase 2023:
EXPLAIN VERBOSE
SELECT count(value1), unhex(hex(str2)) FROM s3 GROUP BY unhex(hex(str2)), str2 HAVING unhex(hex(str2)) IS NOT NULL;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (unhex(hex(str2))), str2
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), unhex(hex(`str2`)), `str2` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((unhex(hex(`str2`)) IS NOT NULL))
(5 rows)

-- select unhex with group by having (result)
--Testcase 2024:
SELECT count(value1), unhex(hex(str2)) FROM s3 GROUP BY unhex(hex(str2)), str2 HAVING unhex(hex(str2)) IS NOT NULL;
 count |   unhex   
-------+-----------
     6 |    XYZ   
(1 row)

-- select unhex with group by index having (result)
--Testcase 2025:
SELECT value1, unhex(hex(str2)) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |   unhex   
--------+-----------
    1.1 |    XYZ   
    2.2 |    XYZ   
    3.3 |    XYZ   
(3 rows)

-- ===============================================================================
-- test upper()
-- ===============================================================================
-- select upper (stub function, explain)
--Testcase 2026:
EXPLAIN VERBOSE
SELECT upper(tag1), upper(str1), upper(str2) FROM s3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..135.57 rows=682 width=96)
   Output: upper(tag1), upper(str1), upper(str2)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `str1`, `str2` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select upper (stub function, result)
--Testcase 2027:
SELECT upper(tag1), upper(str1), upper(str2) FROM s3;
 upper |   upper   |   upper   
-------+-----------+-----------
 A     | ---XYZ--- |    XYZ   
 A     | ---XYZ--- |    XYZ   
 A     | ---XYZ--- |    XYZ   
 B     | ---XYZ--- |    XYZ   
 B     | ---XYZ--- |    XYZ   
 B     | ---XYZ--- |    XYZ   
(6 rows)

-- select upper (stub function, not pushdown constraints, explain)
--Testcase 2028:
EXPLAIN VERBOSE
SELECT value1, upper(tag1) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, upper(tag1)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `tag1`, `value1`, `value2` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select upper (stub function, not pushdown constraints, result)
--Testcase 2029:
SELECT value1, upper(tag1) FROM s3 WHERE to_hex(value2) = '64';
 value1 | upper 
--------+-------
    0.1 | A
    0.2 | A
    0.3 | A
(3 rows)

-- select upper (stub function, pushdown constraints, explain)
--Testcase 2030:
EXPLAIN VERBOSE
SELECT value1, upper(str1) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, upper(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select upper (stub function, pushdown constraints, result)
--Testcase 2031:
SELECT value1, upper(str1) FROM s3 WHERE value2 != 200;
 value1 |   upper   
--------+-----------
    0.1 | ---XYZ---
    0.2 | ---XYZ---
    0.3 | ---XYZ---
(3 rows)

-- select upper with non pushdown func and explicit constant (explain)
--Testcase 2032:
EXPLAIN VERBOSE
SELECT upper(str1), pi(), 4.1 FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: upper(str1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select ucase with non pushdown func and explicit constant (result)
--Testcase 2033:
SELECT upper(str1), pi(), 4.1 FROM s3;
   upper   |        pi         | ?column? 
-----------+-------------------+----------
 ---XYZ--- | 3.141592653589793 |      4.1
 ---XYZ--- | 3.141592653589793 |      4.1
 ---XYZ--- | 3.141592653589793 |      4.1
 ---XYZ--- | 3.141592653589793 |      4.1
 ---XYZ--- | 3.141592653589793 |      4.1
 ---XYZ--- | 3.141592653589793 |      4.1
(6 rows)

-- select upper with order by (explain)
--Testcase 2034:
EXPLAIN VERBOSE
SELECT value1, upper(str1) FROM s3 ORDER BY upper(str1);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, upper(str1)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY upper(`str1`) IS NULL ASC, upper(`str1`) ASC
(4 rows)

-- select upper with order by (result)
--Testcase 2035:
SELECT value1, upper(str1) FROM s3 ORDER BY upper(str1);
 value1 |   upper   
--------+-----------
    0.1 | ---XYZ---
    0.2 | ---XYZ---
    0.3 | ---XYZ---
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(6 rows)

-- select upper with order by index (result)
--Testcase 2036:
SELECT value1, upper(str1) FROM s3 ORDER BY 2,1;
 value1 |   upper   
--------+-----------
    0.1 | ---XYZ---
    0.2 | ---XYZ---
    0.3 | ---XYZ---
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(6 rows)

-- select upper with order by index (result)
--Testcase 2037:
SELECT value1, upper(str1) FROM s3 ORDER BY 1,2;
 value1 |   upper   
--------+-----------
    0.1 | ---XYZ---
    0.2 | ---XYZ---
    0.3 | ---XYZ---
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(6 rows)

-- select upper with group by (explain)
--Testcase 2038:
EXPLAIN VERBOSE
SELECT count(value1), upper(str1) FROM s3 GROUP BY upper(str1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (upper(str1))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), upper(`str1`) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select upper with group by (result)
--Testcase 2039:
SELECT count(value1), upper(str1) FROM s3 GROUP BY upper(str1);
 count |   upper   
-------+-----------
     6 | ---XYZ---
(1 row)

-- select upper with group by index (result)
--Testcase 2040:
SELECT value1, upper(str1) FROM s3 GROUP BY 2,1;
 value1 |   upper   
--------+-----------
    0.1 | ---XYZ---
    0.2 | ---XYZ---
    0.3 | ---XYZ---
    1.1 | ---XYZ---
    2.2 | ---XYZ---
    3.3 | ---XYZ---
(6 rows)

-- select upper with group by having (explain)
--Testcase 2041:
EXPLAIN VERBOSE
SELECT count(value1), upper(str1) FROM s3 GROUP BY upper(str1), tag1 HAVING upper(str1) IS NOT NULL;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (count(value1)), (upper(str1)), tag1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), upper(`str1`), `tag1` FROM `mysql_fdw_regress`.`s3` WHERE ((upper(`str1`) IS NOT NULL)) GROUP BY 2, 3
(5 rows)

-- select upper with group by having (result)
--Testcase 2042:
SELECT count(value1), upper(str1) FROM s3 GROUP BY upper(str1), tag1 HAVING upper(str1) IS NOT NULL;
 count |   upper   
-------+-----------
     3 | ---XYZ---
     3 | ---XYZ---
(2 rows)

-- select upper with group by index having (result)
--Testcase 2043:
SELECT value1, upper(tag1) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 | upper 
--------+-------
    1.1 | B
    2.2 | B
    3.3 | B
(3 rows)

-- ===============================================================================
-- test weight_string()
-- ===============================================================================
-- select weight_string (stub function, explain)
--Testcase 2044:
EXPLAIN VERBOSE
SELECT weight_string('NULL') FROM s3;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..220.92 rows=3413 width=32)
   Output: weight_string('NULL'::text)
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select weight_string (stub function, result)
--Testcase 2045:
SELECT weight_string('NULL') FROM s3;
ERROR:  stub weight_string(text) is called
CONTEXT:  PL/pgSQL function weight_string(text) line 3 at RAISE
-- select weight_string (stub function, explain)
--Testcase 2046:
EXPLAIN VERBOSE
SELECT weight_string(str1), weight_string(str1, 'CHAR', 3), weight_string(str1, 'BINARY', 5) FROM s3;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..164.83 rows=1462 width=96)
   Output: weight_string(str1), weight_string(str1, 'CHAR'::mysql_string_type, 3), weight_string(str1, 'BINARY'::mysql_string_type, 5)
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select weight_string (stub function, result)
--Testcase 2047:
SELECT weight_string(str1), weight_string(str1, 'CHAR', 3), weight_string(str1, 'BINARY', 5) FROM s3;
ERROR:  stub weight_string(text) is called
CONTEXT:  PL/pgSQL function weight_string(text) line 3 at RAISE
-- select weight_string (stub function, not pushdown constraints, explain)
--Testcase 2048:
EXPLAIN VERBOSE
SELECT value1, weight_string(str1, 'CHAR', 3) FROM s3 WHERE to_hex(value2) = '64';
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..129.33 rows=6 width=40)
   Output: value1, weight_string(str1, 'CHAR'::mysql_string_type, 3)
   Filter: (to_hex(s3.value2) = '64'::text)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `value2`, `str1` FROM `mysql_fdw_regress`.`s3`
(5 rows)

-- select weight_string (stub function, not pushdown constraints, result)
--Testcase 2049:
SELECT value1, weight_string(str1, 'CHAR', 3) FROM s3 WHERE to_hex(value2) = '64';
ERROR:  stub weight_string(text, mysql_string_type, int) is called
CONTEXT:  PL/pgSQL function weight_string(text,mysql_string_type,integer) line 3 at RAISE
-- select weight_string (stub function, pushdown constraints, explain)
--Testcase 2050:
EXPLAIN VERBOSE
SELECT value1, weight_string(str1, 'BINARY', 5) FROM s3 WHERE value2 != 200;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..154.67 rows=1274 width=40)
   Output: value1, weight_string(str1, 'BINARY'::mysql_string_type, 5)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` WHERE ((`value2` <> 200))
(4 rows)

-- select weight_string (stub function, pushdown constraints, result)
--Testcase 2051:
SELECT value1, weight_string(str1, 'BINARY', 5) FROM s3 WHERE value2 != 200;
ERROR:  stub weight_string(text, mysql_string_type, int) is called
CONTEXT:  PL/pgSQL function weight_string(text,mysql_string_type,integer) line 3 at RAISE
-- select weight_string with non pushdown func and explicit constant (explain)
--Testcase 2052:
EXPLAIN VERBOSE
SELECT weight_string(str1, 'BINARY', 5), pi(), 4.1 FROM s3;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=100.00..157.52 rows=1462 width=72)
   Output: weight_string(str1, 'BINARY'::mysql_string_type, 5), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `str1` FROM `mysql_fdw_regress`.`s3`
(4 rows)

-- select weight_string with non pushdown func and explicit constant (result)
--Testcase 2053:
SELECT weight_string(str1, 'BINARY', 5), pi(), 4.1 FROM s3;
ERROR:  stub weight_string(text, mysql_string_type, int) is called
CONTEXT:  PL/pgSQL function weight_string(text,mysql_string_type,integer) line 3 at RAISE
-- select weight_string with order by (explain)
--Testcase 2054:
EXPLAIN VERBOSE
SELECT value1, weight_string(str1, 'BINARY', 5) FROM s3 ORDER BY weight_string(str1, 'BINARY', 5);
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s3  (cost=30.00..30.07 rows=30 width=40)
   Output: value1, weight_string(str1, 'BINARY'::mysql_string_type, 5)
   Local server startup cost: 10
   Remote query: SELECT `value1`, `str1` FROM `mysql_fdw_regress`.`s3` ORDER BY weight_string(`str1` AS BINARY(5)) IS NULL ASC, weight_string(`str1` AS BINARY(5)) ASC
(4 rows)

-- select weight_string with order by (result)
--Testcase 2055:
SELECT value1, weight_string(str1, 'BINARY', 5) FROM s3 ORDER BY weight_string(str1, 'BINARY', 5);
ERROR:  stub weight_string(text, mysql_string_type, int) is called
CONTEXT:  PL/pgSQL function weight_string(text,mysql_string_type,integer) line 3 at RAISE
-- select weight_string with order by index (result)
--Testcase 2056:
SELECT value1, weight_string(str1, 'CHAR', 3) FROM s3 ORDER BY 2,1;
ERROR:  stub weight_string(text, mysql_string_type, int) is called
CONTEXT:  PL/pgSQL function weight_string(text,mysql_string_type,integer) line 3 at RAISE
-- select weight_string with order by index (result)
--Testcase 2057:
SELECT value1, weight_string(str1, 'CHAR', 3) FROM s3 ORDER BY 1,2;
ERROR:  stub weight_string(text, mysql_string_type, int) is called
CONTEXT:  PL/pgSQL function weight_string(text,mysql_string_type,integer) line 3 at RAISE
-- select weight_string with group by (explain)
--Testcase 2058:
EXPLAIN VERBOSE
SELECT count(value1), weight_string(str1, 'CHAR', 3) FROM s3 GROUP BY weight_string(str1, 'CHAR', 3);
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(value1)), (weight_string(str1, 'CHAR'::mysql_string_type, 3))
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), weight_string(`str1` AS CHAR(3)) FROM `mysql_fdw_regress`.`s3` GROUP BY 2
(5 rows)

-- select weight_string with group by (result)
--Testcase 2059:
SELECT count(value1), weight_string(str1, 'CHAR', 3) FROM s3 GROUP BY weight_string(str1, 'CHAR', 3);
 count |   weight_string    
-------+--------------------
     6 | \x02\r\x02\r\x02\r
(1 row)

-- select weight_string with group by index (result)
--Testcase 2060:
SELECT value1, weight_string(str1, 'CHAR', 3) FROM s3 GROUP BY 2,1;
 value1 |   weight_string    
--------+--------------------
    0.1 | \x02\r\x02\r\x02\r
    0.2 | \x02\r\x02\r\x02\r
    0.3 | \x02\r\x02\r\x02\r
    1.1 | \x02\r\x02\r\x02\r
    2.2 | \x02\r\x02\r\x02\r
    3.3 | \x02\r\x02\r\x02\r
(6 rows)

-- select weight_string with group by having (explain)
--Testcase 2061:
EXPLAIN VERBOSE
SELECT count(value1), weight_string(str1, 'CHAR', 3) FROM s3 GROUP BY weight_string(str1, 'CHAR', 3), str1 HAVING weight_string(str1, 'CHAR', 3) IS NOT NULL;
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=72)
   Output: (count(value1)), (weight_string(str1, 'CHAR'::mysql_string_type, 3)), str1
   Relations: Aggregate on (mysql_fdw_regress.s3)
   Local server startup cost: 10
   Remote query: SELECT count(`value1`), weight_string(`str1` AS CHAR(3)), `str1` FROM `mysql_fdw_regress`.`s3` GROUP BY 2, 3 HAVING ((weight_string(`str1` AS CHAR(3)) IS NOT NULL))
(5 rows)

-- select weight_string with group by having (result)
--Testcase 2062:
SELECT count(value1), weight_string(str1, 'CHAR', 3) FROM s3 GROUP BY weight_string(str1, 'CHAR', 3), str1 HAVING weight_string(str1, 'CHAR', 3) IS NOT NULL;
 count |   weight_string    
-------+--------------------
     6 | \x02\r\x02\r\x02\r
(1 row)

-- select weight_string with group by index having (result)
--Testcase 2063:
SELECT value1, weight_string(str1, 'CHAR', 3) FROM s3 GROUP BY 1,2 HAVING value1 > 1;
 value1 |   weight_string    
--------+--------------------
    1.1 | \x02\r\x02\r\x02\r
    2.2 | \x02\r\x02\r\x02\r
    3.3 | \x02\r\x02\r\x02\r
(3 rows)

--Testcase 2064:
DROP FOREIGN TABLE s3;
--Testcase 2065:
DROP FOREIGN TABLE s5;
--Testcase 2066:
CREATE FOREIGN TABLE time_tbl(id int, c1 time without time zone, c2 date, c3 timestamp) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 'time_tbl');
--Testcase 2067:
SELECT * FROM time_tbl;
 id |    c1    |     c2     |         c3          
----+----------+------------+---------------------
  0 | 12:10:30 | 2021-01-02 | 2021-01-03 12:10:30
  1 | 23:12:13 | 2021-01-01 | 2021-01-04 23:12:13
  2 | 11:12:12 | 2021-01-10 | 2021-01-05 11:12:12
  3 | 16:00:00 | 2021-01-15 | 2021-01-06 16:00:00
  4 | 00:59:59 | 2021-01-29 | 2021-01-07 00:59:59
(5 rows)

--
-- test for date/time function
--
-- ADDDATE()
-- select adddate (stub function, explain)
--Testcase 2068:
EXPLAIN VERBOSE
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl;
                                                                                                                                                   QUERY PLAN                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..241.62 rows=2925 width=24)
   Output: adddate((c2)::timestamp without time zone, 31), adddate((c2)::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, 31)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select adddate (stub function, result)
--Testcase 2069:
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl;
ERROR:  stub adddate(timestamp, int) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,integer) line 3 at RAISE
-- select adddate (stub function, not pushdown constraints, explain)
--Testcase 2070:
EXPLAIN VERBOSE
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                                                   QUERY PLAN                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..154.40 rows=15 width=24)
   Output: adddate((c2)::timestamp without time zone, 31), adddate((c2)::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, 31)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select adddate (stub function, not pushdown constraints, result)
--Testcase 2071:
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub adddate(timestamp, int) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,integer) line 3 at RAISE
-- select adddate (stub function, pushdown constraints, explain)
--Testcase 2072:
EXPLAIN VERBOSE
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl WHERE id != 0;
                                                                                                                                                   QUERY PLAN                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..248.41 rows=2910 width=24)
   Output: adddate((c2)::timestamp without time zone, 31), adddate((c2)::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, 31)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select adddate (stub function, pushdown constraints, result)
--Testcase 2073:
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl WHERE id != 0;
ERROR:  stub adddate(timestamp, int) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,integer) line 3 at RAISE
-- select adddate (stub function, adddate in constraints, explain)
--Testcase 2074:
EXPLAIN VERBOSE
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl WHERE adddate(c2, 31) != '2021-01-02';
                                                                                                                                                   QUERY PLAN                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..263.04 rows=2910 width=24)
   Output: adddate((c2)::timestamp without time zone, 31), adddate((c2)::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, 31)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((adddate(`c2`, 31) <> '2021-01-02'))
(4 rows)

-- select adddate (stub function, adddate in constraints, result)
--Testcase 2075:
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl WHERE adddate(c2, 31) != '2021-01-02';
ERROR:  stub adddate(timestamp, int) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,integer) line 3 at RAISE
-- select adddate (stub function, adddate in constraints, explain)
--Testcase 2076:
EXPLAIN VERBOSE
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl WHERE adddate('2021-01-02'::date, 31) > '2021-01-02';
                                                                                                                                                   QUERY PLAN                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..188.00 rows=975 width=24)
   Output: adddate((c2)::timestamp without time zone, 31), adddate((c2)::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), adddate('2021-01-02 00:00:00'::timestamp without time zone, 31)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((adddate('2021-01-02 00:00:00', 31) > '2021-01-02'))
(4 rows)

-- select adddate (stub function, adddate in constraints, result)
--Testcase 2077:
SELECT adddate(c2, 31), adddate(c2, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), adddate('2021-01-02'::date, 31) FROM time_tbl WHERE adddate('2021-01-02'::date, 31) > '2021-01-02';
ERROR:  stub adddate(timestamp, int) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,integer) line 3 at RAISE
-- select adddate as nest function with agg (pushdown, explain)
--Testcase 2078:
EXPLAIN VERBOSE
SELECT max(id), adddate('2021-01-02'::date, max(id)) FROM time_tbl;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
   Output: (max(id)), (adddate('2021-01-02 00:00:00'::timestamp without time zone, max(id)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`id`), adddate('2021-01-02 00:00:00', max(`id`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select adddate as nest function with agg (pushdown, result)
--Testcase 2079:
SELECT max(id), adddate('2021-01-02'::date, max(id)) FROM time_tbl;
 max |  adddate   
-----+------------
   4 | 2021-01-06
(1 row)

-- select adddate as nest with stub (pushdown, explain)
--Testcase 2080:
EXPLAIN VERBOSE
SELECT adddate(makedate(2019, id), 31) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=4)
   Output: adddate((makedate(2019, id))::timestamp without time zone, 31)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select adddate as nest with stub (pushdown, result)
--Testcase 2081:
SELECT adddate(makedate(2019, id), 31) FROM time_tbl;
ERROR:  stub makedate(integer, integer) is called
CONTEXT:  PL/pgSQL function makedate(integer,integer) line 3 at RAISE
-- select adddate with non pushdown func and explicit constant (explain)
--Testcase 2082:
EXPLAIN VERBOSE
SELECT adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), pi(), 4.1 FROM time_tbl;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=48)
   Output: adddate('2021-01-02 00:00:00'::timestamp without time zone, '@ 6 mons 2 hours 30 mins'::interval), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select adddate with non pushdown func and explicit constant (result)
--Testcase 2083:
SELECT adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes'), pi(), 4.1 FROM time_tbl;
ERROR:  stub adddate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,interval) line 3 at RAISE
-- select adddate with order by (explain)
--Testcase 2084:
EXPLAIN VERBOSE
SELECT id, adddate(c2, id + 5) FROM time_tbl order by adddate(c2, id + 5);
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=8)
   Output: id, adddate((c2)::timestamp without time zone, (id + 5))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY adddate(`c2`, (`id` + 5)) IS NULL ASC, adddate(`c2`, (`id` + 5)) ASC
(4 rows)

-- select adddate with order by (result)
--Testcase 2085:
SELECT id, adddate(c2, id + 5) FROM time_tbl order by adddate(c2, id + 5);
ERROR:  stub adddate(timestamp, int) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,integer) line 3 at RAISE
-- select adddate with order by index (explain)
--Testcase 2086:
EXPLAIN VERBOSE
SELECT id, adddate(c2, id + 5) FROM time_tbl order by 1,2;
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=8)
   Output: id, adddate((c2)::timestamp without time zone, (id + 5))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `id` IS NULL ASC, `id` ASC, adddate(`c2`, (`id` + 5)) IS NULL ASC, adddate(`c2`, (`id` + 5)) ASC
(4 rows)

-- select adddate with order by index (result)
--Testcase 2087:
SELECT id, adddate(c2, id + 5) FROM time_tbl order by 1,2;
ERROR:  stub adddate(timestamp, int) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,integer) line 3 at RAISE
-- select adddate with group by (explain)
--Testcase 2088:
EXPLAIN VERBOSE
SELECT count(id), adddate(c2, id + 5) FROM time_tbl group by adddate(c2, id + 5);
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=256 width=12)
   Output: (count(id)), (adddate((c2)::timestamp without time zone, (id + 5)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), adddate(`c2`, (`id` + 5)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select adddate with group by (result)
--Testcase 2089:
SELECT count(id), adddate(c2, id + 5) FROM time_tbl group by adddate(c2, id + 5);
 count |  adddate   
-------+------------
     2 | 2021-01-07
     1 | 2021-01-17
     1 | 2021-01-23
     1 | 2021-02-07
(4 rows)

-- select adddate with group by index (result)
--Testcase 2090:
SELECT id, adddate(c2, id + 5) FROM time_tbl group by 2,1;
 id |  adddate   
----+------------
  0 | 2021-01-07
  1 | 2021-01-07
  2 | 2021-01-17
  3 | 2021-01-23
  4 | 2021-02-07
(5 rows)

-- select adddate with group by index (result)
--Testcase 2091:
SELECT id, adddate(c2, id + 5) FROM time_tbl group by 1,2;
 id |  adddate   
----+------------
  0 | 2021-01-07
  1 | 2021-01-07
  2 | 2021-01-17
  3 | 2021-01-23
  4 | 2021-02-07
(5 rows)

-- select adddate with group by having (explain)
--Testcase 2092:
EXPLAIN VERBOSE
SELECT count(id), adddate(c2, id + 5) FROM time_tbl group by adddate(c2, id + 5), id,c2 HAVING adddate(c2, id + 5) > '2000-01-02';
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=85 width=20)
   Output: (count(id)), (adddate((c2)::timestamp without time zone, (id + 5))), id, c2
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), adddate(`c2`, (`id` + 5)), `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 4 HAVING ((adddate(`c2`, (`id` + 5)) > '2000-01-02'))
(5 rows)

-- select adddate with group by having (result)
--Testcase 2093:
SELECT count(id), adddate(c2, id + 5) FROM time_tbl group by adddate(c2, id + 5), id,c2 HAVING adddate(c2, id + 5) > '2000-01-02';
 count |  adddate   
-------+------------
     1 | 2021-01-07
     1 | 2021-01-07
     1 | 2021-01-17
     1 | 2021-01-23
     1 | 2021-02-07
(5 rows)

-- select adddate with group by index having (result)
--Testcase 2094:
SELECT id, adddate(c2, id + 5), c2 FROM time_tbl group by 3,2,1 HAVING adddate(c2, id + 5) > '2000-01-02';
 id |  adddate   |     c2     
----+------------+------------
  0 | 2021-01-07 | 2021-01-02
  1 | 2021-01-07 | 2021-01-01
  2 | 2021-01-17 | 2021-01-10
  3 | 2021-01-23 | 2021-01-15
  4 | 2021-02-07 | 2021-01-29
(5 rows)

-- select adddate with group by index having (result)
--Testcase 2095:
SELECT id, adddate(c2, id + 5), c2 FROM time_tbl group by 1,2,3 HAVING adddate(c2, id + 5) > '2000-01-02';
 id |  adddate   |     c2     
----+------------+------------
  0 | 2021-01-07 | 2021-01-02
  1 | 2021-01-07 | 2021-01-01
  2 | 2021-01-17 | 2021-01-10
  3 | 2021-01-23 | 2021-01-15
  4 | 2021-02-07 | 2021-01-29
(5 rows)

-- select adddate and as
--Testcase 2096:
SELECT adddate('2021-01-02'::date, INTERVAL '6 months 2 hours 30 minutes') as adddate1 FROM time_tbl;
ERROR:  stub adddate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,interval) line 3 at RAISE
-- ADDTIME()
-- select addtime (stub function, explain)
--Testcase 2097:
EXPLAIN VERBOSE
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl;
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..218.80 rows=2560 width=48)
   Output: addtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), addtime(c3, '@ 6 mons 2 hours 30 mins'::interval), addtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), addtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select addtime (stub function, result)
--Testcase 2098:
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl;
ERROR:  stub addtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function addtime(timestamp without time zone,interval) line 3 at RAISE
-- select addtime (stub function, not pushdown constraints, explain)
--Testcase 2099:
EXPLAIN VERBOSE
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.82 rows=13 width=48)
   Output: addtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), addtime(c3, '@ 6 mons 2 hours 30 mins'::interval), addtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), addtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select addtime (stub function, not pushdown constraints, result)
--Testcase 2100:
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub addtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function addtime(timestamp without time zone,interval) line 3 at RAISE
-- select addtime (stub function, pushdown constraints, explain)
--Testcase 2101:
EXPLAIN VERBOSE
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE id != 0;
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..224.78 rows=2547 width=48)
   Output: addtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), addtime(c3, '@ 6 mons 2 hours 30 mins'::interval), addtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), addtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select addtime (stub function, pushdown constraints, result)
--Testcase 2102:
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE id != 0;
ERROR:  stub addtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function addtime(timestamp without time zone,interval) line 3 at RAISE
-- select addtime (stub function, addtime in constraints, explain)
--Testcase 2103:
EXPLAIN VERBOSE
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE addtime(c3, '1 12:59:10') != '2000-01-01';
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..231.18 rows=2547 width=48)
   Output: addtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), addtime(c3, '@ 6 mons 2 hours 30 mins'::interval), addtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), addtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(`c3`, '1 12:59:10.0') <> '2000-01-01 00:00:00'))
(4 rows)

-- select addtime (stub function, addtime in constraints, result)
--Testcase 2104:
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE addtime(c3, '1 12:59:10') != '2000-01-01';
ERROR:  stub addtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function addtime(timestamp without time zone,interval) line 3 at RAISE
-- select addtime (stub function, addtime in constraints, explain)
--Testcase 2105:
EXPLAIN VERBOSE
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') > '1';
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..176.12 rows=853 width=48)
   Output: addtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), addtime(c3, '@ 6 mons 2 hours 30 mins'::interval), addtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), addtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime('1 12:59:10.0', '180 2:30:0.0') > '0 0:0:1.0'))
(4 rows)

-- select addtime (stub function, addtime in constraints, result)
--Testcase 2106:
SELECT addtime(c3, '1 12:59:10'), addtime(c3, INTERVAL '6 months 2 hours 30 minutes'), addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE addtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') > '1';
ERROR:  stub addtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function addtime(timestamp without time zone,interval) line 3 at RAISE
-- select addtime with agg (pushdown, explain)
--Testcase 2107:
EXPLAIN VERBOSE
SELECT max(c1), addtime('2021-01-02'::date, max(c1)) FROM time_tbl;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c1)), (addtime('2021-01-02 00:00:00'::timestamp without time zone, (max(c1))::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c1`), addtime('2021-01-02 00:00:00', max(`c1`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select addtime as nest function with agg (pushdown, result)
--Testcase 2108:
SELECT max(c1), addtime('2021-01-02'::date, max(c1)) FROM time_tbl;
   max    |       addtime       
----------+---------------------
 23:12:13 | 2021-01-02 23:12:13
(1 row)

-- select addtime as nest with stub (pushdown, explain)
--Testcase 2109:
EXPLAIN VERBOSE
SELECT addtime(maketime(12, 15, 30), '1 12:59:10') FROM time_tbl;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..237.99 rows=3413 width=16)
   Output: addtime((maketime(12, 15, 30))::interval, '@ 1 day 12 hours 59 mins 10 secs'::interval)
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select addtime as nest with stub (pushdown, result)
--Testcase 2110:
SELECT addtime(maketime(12, 15, 30), '1 12:59:10') FROM time_tbl;
ERROR:  stub maketime(integer, integer, integer) is called
CONTEXT:  PL/pgSQL function maketime(integer,integer,integer) line 3 at RAISE
-- select addtime with non pushdown func and explicit constant (explain)
--Testcase 2111:
EXPLAIN VERBOSE
SELECT addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), pi(), 4.1 FROM time_tbl;
                                                                                  QUERY PLAN                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=56)
   Output: addtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select addtime with non pushdown func and explicit constant (result)
--Testcase 2112:
SELECT addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), pi(), 4.1 FROM time_tbl;
ERROR:  stub timediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select addtime with order by (explain)
--Testcase 2113:
EXPLAIN VERBOSE
SELECT id, addtime(c1, c1 + '1 12:59:10') FROM time_tbl order by addtime(c1, c1 + '1 12:59:10');
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=20)
   Output: id, addtime((c1)::interval, ((c1 + '@ 1 day 12 hours 59 mins 10 secs'::interval))::interval)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY addtime(`c1`, (`c1` + '1 12:59:10.0')) IS NULL ASC, addtime(`c1`, (`c1` + '1 12:59:10.0')) ASC
(4 rows)

-- select addtime with order by (result)
--Testcase 2114:
SELECT id, addtime(c1, c1 + '1 12:59:10') FROM time_tbl order by addtime(c1, c1 + '1 12:59:10');
ERROR:  stub addtime(interval, interval) is called
CONTEXT:  PL/pgSQL function addtime(interval,interval) line 3 at RAISE
-- select addtime with order by index (result)
--Testcase 2115:
SELECT id, addtime(c1, c1 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub addtime(interval, interval) is called
CONTEXT:  PL/pgSQL function addtime(interval,interval) line 3 at RAISE
-- select addtime with order by index (result)
--Testcase 2116:
SELECT id, addtime(c1, c1 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub addtime(interval, interval) is called
CONTEXT:  PL/pgSQL function addtime(interval,interval) line 3 at RAISE
-- select addtime with group by (explain)
--Testcase 2117:
EXPLAIN VERBOSE
SELECT count(id), addtime(c1, c1 + '1 12:59:10') FROM time_tbl group by addtime(c1, c1 + '1 12:59:10');
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=24)
   Output: (count(id)), (addtime((c1)::interval, ((c1 + '@ 1 day 12 hours 59 mins 10 secs'::interval))::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), addtime(`c1`, (`c1` + '1 12:59:10.0')) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select addtime with group by (result)
--Testcase 2118:
SELECT count(id), addtime(c1, c1 + '1 12:59:10') FROM time_tbl group by addtime(c1, c1 + '1 12:59:10');
 count |          addtime           
-------+----------------------------
     1 | @ 24 hours 21 mins 1 sec
     1 | @ 46 hours 24 mins 27 secs
     1 | @ 22 hours 24 mins 25 secs
     1 | @ 32 hours 1 sec
     1 | 
(5 rows)

-- select addtime with group by index (result)
--Testcase 2119:
SELECT id, addtime(c1, c1 + '1 12:59:10') FROM time_tbl group by 2,1;
 id |          addtime           
----+----------------------------
  0 | @ 24 hours 21 mins 1 sec
  1 | @ 46 hours 24 mins 27 secs
  2 | @ 22 hours 24 mins 25 secs
  3 | @ 32 hours 1 sec
  4 | 
(5 rows)

-- select addtime with group by index (result)
--Testcase 2120:
SELECT id, addtime(c1, c1 + '1 12:59:10') FROM time_tbl group by 1,2;
 id |          addtime           
----+----------------------------
  0 | @ 24 hours 21 mins 1 sec
  1 | @ 46 hours 24 mins 27 secs
  2 | @ 22 hours 24 mins 25 secs
  3 | @ 32 hours 1 sec
  4 | 
(5 rows)

-- select addtime with group by having (explain)
--Testcase 2121:
EXPLAIN VERBOSE
SELECT count(id), addtime(c1, c1 + '1 12:59:10') FROM time_tbl group by addtime(c1, c1 + '1 12:59:10'), c1 HAVING addtime(c1, c1 + '1 12:59:10') > '1 12:59:10';
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=32)
   Output: (count(id)), (addtime((c1)::interval, ((c1 + '@ 1 day 12 hours 59 mins 10 secs'::interval))::interval)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), addtime(`c1`, (`c1` + '1 12:59:10.0')), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((addtime(`c1`, (`c1` + '1 12:59:10.0')) > '1 12:59:10.0'))
(5 rows)

-- select addtime with group by having (result)
--Testcase 2122:
SELECT count(id), addtime(c1, c1 + '1 12:59:10') FROM time_tbl group by addtime(c1, c1 + '1 12:59:10'), c1 HAVING addtime(c1, c1 + '1 12:59:10') > '1 12:59:10';
 count |          addtime           
-------+----------------------------
     1 | @ 24 hours 21 mins 1 sec
     1 | @ 46 hours 24 mins 27 secs
     1 | @ 22 hours 24 mins 25 secs
     1 | @ 32 hours 1 sec
(4 rows)

-- select addtime and as
--Testcase 2123:
SELECT addtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes') as addtime1 FROM time_tbl;
ERROR:  stub timediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- CONVERT_TZ
-- select convert_tz (stub function, explain)
--Testcase 2124:
EXPLAIN VERBOSE
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl;
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..218.80 rows=2560 width=32)
   Output: convert_tz(c3, '+00:00'::text, '+10:00'::text), convert_tz(c3, 'GMT'::text, 'MET'::text), convert_tz(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), 'GMT'::text, 'MET'::text), convert_tz('2021-01-01 12:00:00'::timestamp without time zone, '+00:00'::text, '+10:00'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select convert_tz (stub function, result)
--Testcase 2125:
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl;
ERROR:  stub convert_tz(timestamp, text, text) is called
CONTEXT:  PL/pgSQL function convert_tz(timestamp without time zone,text,text) line 3 at RAISE
-- select convert_tz (stub function, not pushdown constraints, explain)
--Testcase 2126:
EXPLAIN VERBOSE
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.82 rows=13 width=32)
   Output: convert_tz(c3, '+00:00'::text, '+10:00'::text), convert_tz(c3, 'GMT'::text, 'MET'::text), convert_tz(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), 'GMT'::text, 'MET'::text), convert_tz('2021-01-01 12:00:00'::timestamp without time zone, '+00:00'::text, '+10:00'::text)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select convert_tz (stub function, not pushdown constraints, result)
--Testcase 2127:
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub convert_tz(timestamp, text, text) is called
CONTEXT:  PL/pgSQL function convert_tz(timestamp without time zone,text,text) line 3 at RAISE
-- select convert_tz (stub function, pushdown constraints, explain)
--Testcase 2128:
EXPLAIN VERBOSE
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl WHERE id != 0;
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..224.78 rows=2547 width=32)
   Output: convert_tz(c3, '+00:00'::text, '+10:00'::text), convert_tz(c3, 'GMT'::text, 'MET'::text), convert_tz(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), 'GMT'::text, 'MET'::text), convert_tz('2021-01-01 12:00:00'::timestamp without time zone, '+00:00'::text, '+10:00'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select convert_tz (stub function, pushdown constraints, result)
--Testcase 2129:
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl WHERE id != 0;
ERROR:  stub convert_tz(timestamp, text, text) is called
CONTEXT:  PL/pgSQL function convert_tz(timestamp without time zone,text,text) line 3 at RAISE
-- select convert_tz (stub function, convert_tz in constraints, explain)
--Testcase 2130:
EXPLAIN VERBOSE
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl WHERE convert_tz(c3,'+00:00','+10:00') != '2000-01-01';
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..231.18 rows=2547 width=32)
   Output: convert_tz(c3, '+00:00'::text, '+10:00'::text), convert_tz(c3, 'GMT'::text, 'MET'::text), convert_tz(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), 'GMT'::text, 'MET'::text), convert_tz('2021-01-01 12:00:00'::timestamp without time zone, '+00:00'::text, '+10:00'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((convert_tz(`c3`, '+00:00', '+10:00') <> '2000-01-01 00:00:00'))
(4 rows)

-- select convert_tz (stub function, convert_tz in constraints, result)
--Testcase 2131:
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl WHERE convert_tz(c3,'+00:00','+10:00') != '2000-01-01';
ERROR:  stub convert_tz(timestamp, text, text) is called
CONTEXT:  PL/pgSQL function convert_tz(timestamp without time zone,text,text) line 3 at RAISE
-- select convert_tz (stub function, convert_tz in constraints, explain)
--Testcase 2132:
EXPLAIN VERBOSE
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl WHERE convert_tz('2021-01-01 12:00:00','+00:00','+10:00') > '2000-01-01';
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..176.12 rows=853 width=32)
   Output: convert_tz(c3, '+00:00'::text, '+10:00'::text), convert_tz(c3, 'GMT'::text, 'MET'::text), convert_tz(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), 'GMT'::text, 'MET'::text), convert_tz('2021-01-01 12:00:00'::timestamp without time zone, '+00:00'::text, '+10:00'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((convert_tz('2021-01-01 12:00:00', '+00:00', '+10:00') > '2000-01-01 00:00:00'))
(4 rows)

-- select convert_tz (stub function, convert_tz in constraints, result)
--Testcase 2133:
SELECT convert_tz(c3,'+00:00','+10:00'), convert_tz(c3, 'GMT', 'MET'), convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), convert_tz('2021-01-01 12:00:00','+00:00','+10:00') FROM time_tbl WHERE convert_tz('2021-01-01 12:00:00','+00:00','+10:00') > '2000-01-01';
ERROR:  stub convert_tz(timestamp, text, text) is called
CONTEXT:  PL/pgSQL function convert_tz(timestamp without time zone,text,text) line 3 at RAISE
-- select convert_tz with agg (pushdown, explain)
--Testcase 2134:
EXPLAIN VERBOSE
SELECT max(c3), convert_tz(max(c3), '+00:00','+10:00') FROM time_tbl;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c3)), (convert_tz(max(c3), '+00:00'::text, '+10:00'::text))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), convert_tz(max(`c3`), '+00:00', '+10:00') FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select convert_tz as nest function with agg (pushdown, result)
--Testcase 2135:
SELECT max(c3), convert_tz(max(c3), '+00:00','+10:00') FROM time_tbl;
         max         |     convert_tz      
---------------------+---------------------
 2021-01-07 00:59:59 | 2021-01-07 10:59:59
(1 row)

-- select convert_tz with non pushdown func and explicit constant (explain)
--Testcase 2136:
EXPLAIN VERBOSE
SELECT convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), pi(), 4.1 FROM time_tbl;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=48)
   Output: convert_tz(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), 'GMT'::text, 'MET'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select convert_tz with non pushdown func and explicit constant (result)
--Testcase 2137:
SELECT convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET'), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select convert_tz with order by (explain)
--Testcase 2138:
EXPLAIN VERBOSE
SELECT id, convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl order by convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00');
                                                                                                                                                                QUERY PLAN                                                                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: id, convert_tz((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '+00:00'::text, '+10:00'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY convert_tz((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '+00:00', '+10:00') IS NULL ASC, convert_tz((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '+00:00', '+10:00') ASC
(4 rows)

-- select convert_tz with order by (result)
--Testcase 2139:
SELECT id, convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl order by convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00');
ERROR:  stub convert_tz(timestamp, text, text) is called
CONTEXT:  PL/pgSQL function convert_tz(timestamp without time zone,text,text) line 3 at RAISE
-- select convert_tz with order by index (result)
--Testcase 2140:
SELECT id, convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl order by 2,1;
ERROR:  stub convert_tz(timestamp, text, text) is called
CONTEXT:  PL/pgSQL function convert_tz(timestamp without time zone,text,text) line 3 at RAISE
-- select convert_tz with order by index (result)
--Testcase 2141:
SELECT id, convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl order by 1,2;
ERROR:  stub convert_tz(timestamp, text, text) is called
CONTEXT:  PL/pgSQL function convert_tz(timestamp without time zone,text,text) line 3 at RAISE
-- select convert_tz with group by (explain)
--Testcase 2142:
EXPLAIN VERBOSE
SELECT count(id), convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl group by convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00');
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(id)), (convert_tz((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '+00:00'::text, '+10:00'::text))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), convert_tz((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '+00:00', '+10:00') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select convert_tz with group by (result)
--Testcase 2143:
SELECT count(id), convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl group by convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00');
 count |     convert_tz      
-------+---------------------
     1 | 2021-01-05 11:09:40
     1 | 2021-01-06 22:11:23
     1 | 2021-01-07 10:11:22
     1 | 2021-01-08 14:59:10
     1 | 2021-01-08 23:59:09
(5 rows)

-- select convert_tz with group by index (result)
--Testcase 2144:
SELECT id, convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl group by 2,1;
 id |     convert_tz      
----+---------------------
  0 | 2021-01-05 11:09:40
  1 | 2021-01-06 22:11:23
  2 | 2021-01-07 10:11:22
  3 | 2021-01-08 14:59:10
  4 | 2021-01-08 23:59:09
(5 rows)

-- select convert_tz with group by index (result)
--Testcase 2145:
SELECT id, convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl group by 1,2;
 id |     convert_tz      
----+---------------------
  0 | 2021-01-05 11:09:40
  1 | 2021-01-06 22:11:23
  2 | 2021-01-07 10:11:22
  3 | 2021-01-08 14:59:10
  4 | 2021-01-08 23:59:09
(5 rows)

-- select convert_tz with group by having (explain)
--Testcase 2146:
EXPLAIN VERBOSE
SELECT count(id), convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl group by convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00'),id,c3 HAVING convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') > '2000-01-01 12:59:10';
                                                                                                                                                                                    QUERY PLAN                                                                                                                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=76 width=28)
   Output: (count(id)), (convert_tz((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '+00:00'::text, '+10:00'::text)), id, c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), convert_tz((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '+00:00', '+10:00'), `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 4 HAVING ((convert_tz((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '+00:00', '+10:00') > '2000-01-01 12:59:10'))
(5 rows)

-- select convert_tz with group by having (result)
--Testcase 2147:
SELECT count(id), convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl group by convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00'),id,c3 HAVING convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') > '2000-01-01 12:59:10';
 count |     convert_tz      
-------+---------------------
     1 | 2021-01-05 11:09:40
     1 | 2021-01-06 22:11:23
     1 | 2021-01-07 10:11:22
     1 | 2021-01-08 14:59:10
     1 | 2021-01-08 23:59:09
(5 rows)

-- select convert_tz with group by index having (result)
--Testcase 2148:
SELECT id, c3, convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') FROM time_tbl group by 3,2,1 HAVING convert_tz(c3 + '1 12:59:10' , '+00:00','+10:00') > '2000-01-01 12:59:10';
 id |         c3          |     convert_tz      
----+---------------------+---------------------
  0 | 2021-01-03 12:10:30 | 2021-01-05 11:09:40
  1 | 2021-01-04 23:12:13 | 2021-01-06 22:11:23
  2 | 2021-01-05 11:12:12 | 2021-01-07 10:11:22
  3 | 2021-01-06 16:00:00 | 2021-01-08 14:59:10
  4 | 2021-01-07 00:59:59 | 2021-01-08 23:59:09
(5 rows)

-- select convert_tz and as
--Testcase 2149:
SELECT convert_tz(date_sub(c3, '1 12:59:10'), 'GMT', 'MET') as convert_tz1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- CURDATE()
-- curdate is mutable function, some executes will return different result
-- select curdate (stub function, explain)
--Testcase 2150:
EXPLAIN VERBOSE
SELECT curdate() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=4)
   Output: curdate()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select curdate (stub function, not pushdown constraints, explain)
--Testcase 2151:
EXPLAIN VERBOSE
SELECT curdate() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=4)
   Output: curdate()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select curdate (stub function, pushdown constraints, explain)
--Testcase 2152:
EXPLAIN VERBOSE
SELECT curdate() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=4)
   Output: curdate()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select curdate (stub function, curdate in constraints, explain)
--Testcase 2153:
EXPLAIN VERBOSE
SELECT curdate() FROM time_tbl WHERE curdate() > '2000-01-01';
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=4)
   Output: curdate()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((curdate() > '2000-01-01'))
(4 rows)

-- curdate in constrains (stub function, explain)
--Testcase 2154:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE curdate() > '2000-01-01';
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((curdate() > '2000-01-01'))
(4 rows)

-- curdate in constrains (stub function, result)
--Testcase 2155:
SELECT c1 FROM time_tbl WHERE curdate() > '2000-01-01';
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- curdate as parameter of adddate(stub function, explain)
--Testcase 2156:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE adddate(curdate(), 31) > '2000-01-01';
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.26 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((adddate(curdate(), 31) > '2000-01-01'))
(4 rows)

-- curdate as parameter of adddate(stub function, result)
--Testcase 2157:
SELECT c1 FROM time_tbl WHERE adddate(curdate(), 31) > '2000-01-01';
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select curdate and agg (pushdown, explain)
--Testcase 2158:
EXPLAIN VERBOSE
SELECT curdate(), sum(id) FROM time_tbl;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (curdate()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curdate(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select curdate and log2 (pushdown, explain)
--Testcase 2159:
EXPLAIN VERBOSE
SELECT curdate(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=12)
   Output: curdate(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select curdate with non pushdown func and explicit constant (explain)
--Testcase 2160:
EXPLAIN VERBOSE
SELECT curdate(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=40)
   Output: curdate(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select curdate with order by (explain)
--Testcase 2161:
EXPLAIN VERBOSE
SELECT curdate(), c1 FROM time_tbl ORDER BY c1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=12)
   Output: (curdate()), c1
   Local server startup cost: 10
   Remote query: SELECT curdate(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select curdate with order by index (explain)
--Testcase 2162:
EXPLAIN VERBOSE
SELECT curdate(), c1 FROM time_tbl ORDER BY 2;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=12)
   Output: (curdate()), c1
   Local server startup cost: 10
   Remote query: SELECT curdate(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- curdate constraints with order by (explain)
--Testcase 2163:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE adddate(curdate(), 31) > '2000-01-01' ORDER BY c1;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((adddate(curdate(), 31) > '2000-01-01')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- curdate constraints with order by (result)
--Testcase 2164:
SELECT c1 FROM time_tbl WHERE adddate(curdate(), 31) > '2000-01-01' ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select curdate with group by (explain)
--Testcase 2165:
EXPLAIN VERBOSE
SELECT curdate(), c1 FROM time_tbl GROUP BY c1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (curdate()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curdate(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select curdate with group by index (explain)
--Testcase 2166:
EXPLAIN VERBOSE
SELECT curdate(), c1 FROM time_tbl GROUP BY 2;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (curdate()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curdate(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select curdate with group by having (explain)
--Testcase 2167:
EXPLAIN VERBOSE
SELECT curdate(), c1 FROM time_tbl GROUP BY curdate(),c1 HAVING curdate() > '2000-01-01';
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=12)
   Output: (curdate()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curdate(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((curdate() > '2000-01-01'))
(5 rows)

-- select curdate with group by index having (explain)
--Testcase 2168:
EXPLAIN VERBOSE
SELECT curdate(), c1 FROM time_tbl GROUP BY 1,2 HAVING curdate() > '2000-01-01';
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=12)
   Output: (curdate()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curdate(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((curdate() > '2000-01-01'))
(5 rows)

-- curdate constraints with group by (explain)
--Testcase 2169:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE adddate(curdate(), 31) > '2000-01-01' GROUP BY c1;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((adddate(curdate(), 31) > '2000-01-01')) GROUP BY 1
(5 rows)

-- curdate constraints with group by (result)
--Testcase 2170:
SELECT c1 FROM time_tbl WHERE adddate(curdate(), 31) > '2000-01-01' GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select curdate and as
--Testcase 2171:
EXPLAIN VERBOSE
SELECT curdate() as curdate1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=4)
   Output: curdate()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- CURRENT_DATE()
-- mysql_current_date is mutable function, some executes will return different result
-- select mysql_current_date (stub function, explain)
--Testcase 2172:
EXPLAIN VERBOSE
SELECT mysql_current_date() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=4)
   Output: mysql_current_date()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_date (stub function, not pushdown constraints, explain)
--Testcase 2173:
EXPLAIN VERBOSE
SELECT mysql_current_date() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=4)
   Output: mysql_current_date()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_current_date (stub function, pushdown constraints, explain)
--Testcase 2174:
EXPLAIN VERBOSE
SELECT mysql_current_date() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=4)
   Output: mysql_current_date()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select mysql_current_date (stub function, mysql_current_date in constraints, explain)
--Testcase 2175:
EXPLAIN VERBOSE
SELECT mysql_current_date() FROM time_tbl WHERE mysql_current_date() > '2000-01-01';
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=4)
   Output: mysql_current_date()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((current_date() > '2000-01-01'))
(4 rows)

-- mysql_current_date in constrains (stub function, explain)
--Testcase 2176:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE mysql_current_date() > '2000-01-01';
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((current_date() > '2000-01-01'))
(4 rows)

-- mysql_current_date in constrains (stub function, result)
--Testcase 2177:
SELECT c1 FROM time_tbl WHERE mysql_current_date() > '2000-01-01';
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- mysql_current_date as parameter of adddate(stub function, explain)
--Testcase 2178:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE adddate(mysql_current_date(), 31) > '2000-01-01';
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.26 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((adddate(current_date(), 31) > '2000-01-01'))
(4 rows)

-- mysql_current_date as parameter of adddate(stub function, result)
--Testcase 2179:
SELECT c1 FROM time_tbl WHERE adddate(mysql_current_date(), 31) > '2000-01-01';
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_current_date and agg (pushdown, explain)
--Testcase 2180:
EXPLAIN VERBOSE
SELECT mysql_current_date(), sum(id) FROM time_tbl;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (mysql_current_date()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_date(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_current_date and log2 (pushdown, explain)
--Testcase 2181:
EXPLAIN VERBOSE
SELECT mysql_current_date(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=12)
   Output: mysql_current_date(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_date with non pushdown func and explicit constant (explain)
--Testcase 2182:
EXPLAIN VERBOSE
SELECT mysql_current_date(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=40)
   Output: mysql_current_date(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_date with order by (explain)
--Testcase 2183:
EXPLAIN VERBOSE
SELECT mysql_current_date(), c1 FROM time_tbl ORDER BY c1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=12)
   Output: (mysql_current_date()), c1
   Local server startup cost: 10
   Remote query: SELECT current_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select mysql_current_date with order by index (explain)
--Testcase 2184:
EXPLAIN VERBOSE
SELECT mysql_current_date(), c1 FROM time_tbl ORDER BY 2;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=12)
   Output: (mysql_current_date()), c1
   Local server startup cost: 10
   Remote query: SELECT current_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- mysql_current_date constraints with order by (explain)
--Testcase 2185:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE adddate(mysql_current_date(), 31) > '2000-01-01' ORDER BY c1;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((adddate(current_date(), 31) > '2000-01-01')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- mysql_current_date constraints with order by (result)
--Testcase 2186:
SELECT c1 FROM time_tbl WHERE adddate(mysql_current_date(), 31) > '2000-01-01' ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select mysql_current_date with group by (explain)
--Testcase 2187:
EXPLAIN VERBOSE
SELECT mysql_current_date(), c1 FROM time_tbl GROUP BY c1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (mysql_current_date()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_current_date with group by index (explain)
--Testcase 2188:
EXPLAIN VERBOSE
SELECT mysql_current_date(), c1 FROM time_tbl GROUP BY 2;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (mysql_current_date()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_current_date with group by having (explain)
--Testcase 2189:
EXPLAIN VERBOSE
SELECT mysql_current_date(), c1 FROM time_tbl GROUP BY mysql_current_date(), c1 HAVING mysql_current_date() > '2000-01-01';
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=12)
   Output: (mysql_current_date()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((current_date() > '2000-01-01'))
(5 rows)

-- select mysql_current_date with group by index having (explain)
--Testcase 2190:
EXPLAIN VERBOSE
SELECT mysql_current_date(), c1 FROM time_tbl GROUP BY 2,1 HAVING mysql_current_date() > '2000-01-01';
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=12)
   Output: (mysql_current_date()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((current_date() > '2000-01-01'))
(5 rows)

-- mysql_current_date constraints with group by (explain)
--Testcase 2191:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE adddate(mysql_current_date(), 31) > '2000-01-01' GROUP BY c1;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((adddate(current_date(), 31) > '2000-01-01')) GROUP BY 1
(5 rows)

-- mysql_current_date constraints with group by (result)
--Testcase 2192:
SELECT c1 FROM time_tbl WHERE adddate(mysql_current_date(), 31) > '2000-01-01' GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_current_date and as
--Testcase 2193:
EXPLAIN VERBOSE
SELECT mysql_current_date() as mysql_current_date1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=4)
   Output: mysql_current_date()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- CURTIME()
-- curtime is mutable function, some executes will return different result
-- select curtime (stub function, explain)
--Testcase 2194:
EXPLAIN VERBOSE
SELECT curtime() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: curtime()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select curtime (stub function, not pushdown constraints, explain)
--Testcase 2195:
EXPLAIN VERBOSE
SELECT curtime() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: curtime()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select curtime (stub function, pushdown constraints, explain)
--Testcase 2196:
EXPLAIN VERBOSE
SELECT curtime() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=8)
   Output: curtime()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select curtime (stub function, curtime in constraints, explain)
--Testcase 2197:
EXPLAIN VERBOSE
SELECT curtime() FROM time_tbl WHERE curtime() > '00:00:00';
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: curtime()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((curtime() > '00:00:00'))
(4 rows)

-- curtime in constrains (stub function, explain)
--Testcase 2198:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE curtime() > '00:00:00';
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((curtime() > '00:00:00'))
(4 rows)

-- curtime in constrains (stub function, result)
--Testcase 2199:
SELECT c1 FROM time_tbl WHERE curtime() > '00:00:00';
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- curtime as parameter of addtime(stub function, explain)
--Testcase 2200:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(curtime(), '1 12:59:10') > '00:00:00';
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.26 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(curtime(), '1 12:59:10.0') > '0'))
(4 rows)

-- curtime as parameter of addtime(stub function, result)
--Testcase 2201:
SELECT c1 FROM time_tbl WHERE addtime(curtime(), '1 12:59:10') > '00:00:00';
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select curtime and agg (pushdown, explain)
--Testcase 2202:
EXPLAIN VERBOSE
SELECT curtime(), sum(id) FROM time_tbl;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (curtime()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curtime(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select curtime and log2 (pushdown, explain)
--Testcase 2203:
EXPLAIN VERBOSE
SELECT curtime(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: curtime(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select curtime with non pushdown func and explicit constant (explain)
--Testcase 2204:
EXPLAIN VERBOSE
SELECT curtime(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: curtime(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select curtime with order by (explain)
--Testcase 2205:
EXPLAIN VERBOSE
SELECT curtime(), c1 FROM time_tbl ORDER BY c1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: (curtime()), c1
   Local server startup cost: 10
   Remote query: SELECT curtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select curtime with order by index (explain)
--Testcase 2206:
EXPLAIN VERBOSE
SELECT curtime(), c1 FROM time_tbl ORDER BY 2;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: (curtime()), c1
   Local server startup cost: 10
   Remote query: SELECT curtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- curtime constraints with order by (explain)
--Testcase 2207:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(curtime(), '1 12:59:10') > '00:00:00' ORDER BY c1;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(curtime(), '1 12:59:10.0') > '0')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- curtime constraints with order by (result)
--Testcase 2208:
SELECT c1 FROM time_tbl WHERE addtime(curtime(), '1 12:59:10') > '00:00:00' ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select curtime with group by (explain)
--Testcase 2209:
EXPLAIN VERBOSE
SELECT curtime(), c1 FROM time_tbl GROUP BY c1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (curtime()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select curtime with group by index (explain)
--Testcase 2210:
EXPLAIN VERBOSE
SELECT curtime(), c1 FROM time_tbl GROUP BY 2;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (curtime()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select curtime with group by having (explain)
--Testcase 2211:
EXPLAIN VERBOSE
SELECT curtime(), c1 FROM time_tbl GROUP BY curtime(),c1 HAVING curtime() > '00:00:00';
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (curtime()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((curtime() > '00:00:00'))
(5 rows)

-- select curtime with group by index having (explain)
--Testcase 2212:
EXPLAIN VERBOSE
SELECT curtime(), c1 FROM time_tbl GROUP BY 2,1 HAVING curtime() > '00:00:00';
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (curtime()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT curtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((curtime() > '00:00:00'))
(5 rows)

-- curtime constraints with group by (explain)
--Testcase 2213:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(curtime(), '1 12:59:10') > '00:00:00' GROUP BY c1;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(curtime(), '1 12:59:10.0') > '0')) GROUP BY 1
(5 rows)

-- curtime constraints with group by (result)
--Testcase 2214:
SELECT c1 FROM time_tbl WHERE addtime(curtime(), '1 12:59:10') > '00:00:00' GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select curtime and as
--Testcase 2215:
EXPLAIN VERBOSE
SELECT curtime() as curtime1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: curtime()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- CURRENT_TIME()
-- mysql_current_time is mutable function, some executes will return different result
-- select mysql_current_time (stub function, explain)
--Testcase 2216:
EXPLAIN VERBOSE
SELECT mysql_current_time() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_current_time()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_time (stub function, not pushdown constraints, explain)
--Testcase 2217:
EXPLAIN VERBOSE
SELECT mysql_current_time() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_current_time()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_current_time (stub function, pushdown constraints, explain)
--Testcase 2218:
EXPLAIN VERBOSE
SELECT mysql_current_time() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=8)
   Output: mysql_current_time()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select mysql_current_time (stub function, mysql_current_time in constraints, explain)
--Testcase 2219:
EXPLAIN VERBOSE
SELECT mysql_current_time() FROM time_tbl WHERE mysql_current_time() > '00:00:00';
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_current_time()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((current_time() > '00:00:00'))
(4 rows)

-- mysql_current_time in constrains (stub function, explain)
--Testcase 2220:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE mysql_current_time() > '00:00:00';
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((current_time() > '00:00:00'))
(4 rows)

-- mysql_current_time in constrains (stub function, result)
--Testcase 2221:
SELECT c1 FROM time_tbl WHERE mysql_current_time() > '00:00:00';
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- mysql_current_time as parameter of addtime(stub function, explain)
--Testcase 2222:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_time(), '1 12:59:10') > '00:00:00';
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.26 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(current_time(), '1 12:59:10.0') > '0'))
(4 rows)

-- mysql_current_time as parameter of addtime(stub function, result)
--Testcase 2223:
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_time(), '1 12:59:10') > '00:00:00';
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_current_time and agg (pushdown, explain)
--Testcase 2224:
EXPLAIN VERBOSE
SELECT mysql_current_time(), sum(id) FROM time_tbl;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (mysql_current_time()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_time(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_current_time and log2 (pushdown, explain)
--Testcase 2225:
EXPLAIN VERBOSE
SELECT mysql_current_time(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: mysql_current_time(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_time with non pushdown func and explicit constant (explain)
--Testcase 2226:
EXPLAIN VERBOSE
SELECT mysql_current_time(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: mysql_current_time(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_time with order by (explain)
--Testcase 2227:
EXPLAIN VERBOSE
SELECT mysql_current_time(), c1 FROM time_tbl ORDER BY c1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: (mysql_current_time()), c1
   Local server startup cost: 10
   Remote query: SELECT current_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select mysql_current_time with order by index (explain)
--Testcase 2228:
EXPLAIN VERBOSE
SELECT mysql_current_time(), c1 FROM time_tbl ORDER BY 2;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: (mysql_current_time()), c1
   Local server startup cost: 10
   Remote query: SELECT current_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- mysql_current_time constraints with order by (explain)
--Testcase 2229:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_time(), '1 12:59:10') > '00:00:00' ORDER BY c1;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(current_time(), '1 12:59:10.0') > '0')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- mysql_current_time constraints with order by (result)
--Testcase 2230:
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_time(), '1 12:59:10') > '00:00:00' ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select mysql_current_time with group by (explain)
--Testcase 2231:
EXPLAIN VERBOSE
SELECT mysql_current_time(), c1 FROM time_tbl GROUP BY c1;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_current_time()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_current_time with group by index (explain)
--Testcase 2232:
EXPLAIN VERBOSE
SELECT mysql_current_time(), c1 FROM time_tbl GROUP BY 2;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_current_time()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_current_time with group by having (explain)
--Testcase 2233:
EXPLAIN VERBOSE
SELECT mysql_current_time(), c1 FROM time_tbl GROUP BY mysql_current_time(),c1 HAVING mysql_current_time() > '00:00:00';
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_current_time()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((current_time() > '00:00:00'))
(5 rows)

-- select mysql_current_time with group by index having (explain)
--Testcase 2234:
EXPLAIN VERBOSE
SELECT mysql_current_time(), c1 FROM time_tbl GROUP BY 2,1 HAVING mysql_current_time() > '00:00:00';
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_current_time()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((current_time() > '00:00:00'))
(5 rows)

-- mysql_current_time constraints with group by (explain)
--Testcase 2235:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_time(), '1 12:59:10') > '00:00:00' GROUP BY c1;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(current_time(), '1 12:59:10.0') > '0')) GROUP BY 1
(5 rows)

-- mysql_current_time constraints with group by (result)
--Testcase 2236:
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_time(), '1 12:59:10') > '00:00:00' GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_current_time and as
--Testcase 2237:
EXPLAIN VERBOSE
SELECT mysql_current_time() as mysql_current_time1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_current_time()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- CURRENT_TIMESTAMP
-- mysql_current_timestamp is mutable function, some executes will return different result
-- select mysql_current_timestamp (stub function, explain)
--Testcase 2238:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_current_timestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_timestamp (stub function, not pushdown constraints, explain)
--Testcase 2239:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_current_timestamp()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_current_timestamp (stub function, pushdown constraints, explain)
--Testcase 2240:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=8)
   Output: mysql_current_timestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select mysql_current_timestamp (stub function, mysql_current_timestamp in constraints, explain)
--Testcase 2241:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp() FROM time_tbl WHERE mysql_current_timestamp() > '2000-01-01 00:00:00'::timestamp;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_current_timestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((current_timestamp() > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_current_timestamp in constrains (stub function, explain)
--Testcase 2242:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE mysql_current_timestamp() > '2000-01-01 00:00:00'::timestamp;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((current_timestamp() > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_current_timestamp in constrains (stub function, result)
--Testcase 2243:
SELECT c1 FROM time_tbl WHERE mysql_current_timestamp() > '2000-01-01 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- mysql_current_timestamp as parameter of addtime(stub function, explain)
--Testcase 2244:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_timestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..171.86 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(current_timestamp(), '1 12:59:10.0') > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_current_timestamp as parameter of addtime(stub function, result)
--Testcase 2245:
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_timestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_current_timestamp and agg (pushdown, explain)
--Testcase 2246:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), sum(id) FROM time_tbl;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (mysql_current_timestamp()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_timestamp(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_current_timestamp and log2 (pushdown, explain)
--Testcase 2247:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: mysql_current_timestamp(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_timestamp with non pushdown func and explicit constant (explain)
--Testcase 2248:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: mysql_current_timestamp(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_current_timestamp with order by (explain)
--Testcase 2249:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), c1 FROM time_tbl ORDER BY mysql_current_timestamp();
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: mysql_current_timestamp(), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY current_timestamp() IS NULL ASC, current_timestamp() ASC
(4 rows)

-- select mysql_current_timestamp with order by index (explain)
--Testcase 2250:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), c1 FROM time_tbl ORDER BY 1;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: mysql_current_timestamp(), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY current_timestamp() IS NULL ASC, current_timestamp() ASC
(4 rows)

-- mysql_current_timestamp constraints with order by (explain)
--Testcase 2251:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_timestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp ORDER BY c1;
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(current_timestamp(), '1 12:59:10.0') > '2000-01-01 00:00:00')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- mysql_current_timestamp constraints with order by (result)
--Testcase 2252:
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_timestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select mysql_current_timestamp with group by (explain)
--Testcase 2253:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), c1 FROM time_tbl GROUP BY c1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_current_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_current_timestamp with group by index (explain)
--Testcase 2254:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), c1 FROM time_tbl GROUP BY 2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_current_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_current_timestamp with group by having (explain)
--Testcase 2255:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), c1 FROM time_tbl GROUP BY mysql_current_timestamp(),c1 HAVING mysql_current_timestamp() > '2000-01-01 00:00:00'::timestamp;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_current_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((current_timestamp() > '2000-01-01 00:00:00'))
(5 rows)

-- select mysql_current_timestamp with group by index having (explain)
--Testcase 2256:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp(), c1 FROM time_tbl GROUP BY 2,1 HAVING mysql_current_timestamp() > '2000-01-01 00:00:00'::timestamp;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_current_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT current_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((current_timestamp() > '2000-01-01 00:00:00'))
(5 rows)

-- mysql_current_timestamp constraints with group by (explain)
--Testcase 2257:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_timestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp GROUP BY c1;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(current_timestamp(), '1 12:59:10.0') > '2000-01-01 00:00:00')) GROUP BY 1
(5 rows)

-- mysql_current_timestamp constraints with group by (result)
--Testcase 2258:
SELECT c1 FROM time_tbl WHERE addtime(mysql_current_timestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_current_timestamp and as
--Testcase 2259:
EXPLAIN VERBOSE
SELECT mysql_current_timestamp() as mysql_current_timestamp1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_current_timestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- DATE()
-- select date (stub function, explain)
--Testcase 2260:
EXPLAIN VERBOSE
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..195.31 rows=2275 width=16)
   Output: date(c3), c2, date(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '2021-01-01'::date
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date (stub function, result)
--Testcase 2261:
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date (stub function, not pushdown constraints, explain)
--Testcase 2262:
EXPLAIN VERBOSE
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl WHERE to_hex(id) = '1';
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.43 rows=11 width=16)
   Output: date(c3), c2, date(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '2021-01-01'::date
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select date (stub function, not pushdown constraints, result)
--Testcase 2263:
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date (stub function, pushdown constraints, explain)
--Testcase 2264:
EXPLAIN VERBOSE
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl WHERE id != 0;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..200.70 rows=2264 width=16)
   Output: date(c3), c2, date(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '2021-01-01'::date
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select date (stub function, pushdown constraints, result)
--Testcase 2265:
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl WHERE id != 0;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date (stub function, date in constraints, explain)
--Testcase 2266:
EXPLAIN VERBOSE
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl WHERE date(c3) != '2000-01-01';
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.38 rows=2264 width=16)
   Output: date(c3), c2, date(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '2021-01-01'::date
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date(`c3`) <> '2000-01-01'))
(4 rows)

-- select date (stub function, date in constraints, result)
--Testcase 2267:
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl WHERE date(c3) != '2000-01-01';
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date (stub function, date in constraints, explain)
--Testcase 2268:
EXPLAIN VERBOSE
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl WHERE date('2021-01-01 12:00:00') > '2000-01-01';
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..195.31 rows=2275 width=16)
   Output: date(c3), c2, date(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '2021-01-01'::date
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date (stub function, date in constraints, result)
--Testcase 2269:
SELECT date(c3), date(c2), date(date_sub(c3, '1 12:59:10')), date('2021-01-01 12:00:00') FROM time_tbl WHERE date('2021-01-01 12:00:00') > '2000-01-01';
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date with agg (pushdown, explain)
--Testcase 2270:
EXPLAIN VERBOSE
SELECT max(c3), date(max(c3)) FROM time_tbl;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (date(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select date as nest function with agg (pushdown, result)
--Testcase 2271:
SELECT max(c3), date(max(c3)) FROM time_tbl;
         max         |    date    
---------------------+------------
 2021-01-07 00:59:59 | 2021-01-07
(1 row)

-- select date with non pushdown func and explicit constant (explain)
--Testcase 2272:
EXPLAIN VERBOSE
SELECT date(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: date(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date with non pushdown func and explicit constant (result)
--Testcase 2273:
SELECT date(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date with order by (explain)
--Testcase 2274:
EXPLAIN VERBOSE
SELECT id, date(c3 + '1 12:59:10') FROM time_tbl order by date(c3 + '1 12:59:10');
                                                                                                                                      QUERY PLAN                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, date((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY date((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, date((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select date with order by (result)
--Testcase 2275:
SELECT id, date(c3 + '1 12:59:10') FROM time_tbl order by date(c3 + '1 12:59:10');
 id |    date    
----+------------
  0 | 2021-01-05
  1 | 2021-01-06
  2 | 2021-01-07
  3 | 2021-01-08
  4 | 2021-01-08
(5 rows)

-- select date with order by index (result)
--Testcase 2276:
SELECT id, date(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
 id |    date    
----+------------
  0 | 2021-01-05
  1 | 2021-01-06
  2 | 2021-01-07
  3 | 2021-01-08
  4 | 2021-01-08
(5 rows)

-- select date with order by index (result)
--Testcase 2277:
SELECT id, date(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
 id |    date    
----+------------
  0 | 2021-01-05
  1 | 2021-01-06
  2 | 2021-01-07
  3 | 2021-01-08
  4 | 2021-01-08
(5 rows)

-- select date with group by (explain)
--Testcase 2278:
EXPLAIN VERBOSE
SELECT max(c3), date(c3 + '1 12:59:10') FROM time_tbl group by date(c3 + '1 12:59:10');
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (date((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select date with group by (result)
--Testcase 2279:
SELECT max(c3), date(c3 + '1 12:59:10') FROM time_tbl group by date(c3 + '1 12:59:10');
         max         |    date    
---------------------+------------
 2021-01-03 12:10:30 | 2021-01-05
 2021-01-04 23:12:13 | 2021-01-06
 2021-01-05 11:12:12 | 2021-01-07
 2021-01-07 00:59:59 | 2021-01-08
(4 rows)

-- select date with group by index (result)
--Testcase 2280:
SELECT id, date(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id |    date    
----+------------
  0 | 2021-01-05
  1 | 2021-01-06
  2 | 2021-01-07
  3 | 2021-01-08
  4 | 2021-01-08
(5 rows)

-- select date with group by index (result)
--Testcase 2281:
SELECT id, date(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id |    date    
----+------------
  0 | 2021-01-05
  1 | 2021-01-06
  2 | 2021-01-07
  3 | 2021-01-08
  4 | 2021-01-08
(5 rows)

-- select date with group by having (explain)
--Testcase 2282:
EXPLAIN VERBOSE
SELECT max(c3), date(c3 + '1 12:59:10') FROM time_tbl group by date(c3 + '1 12:59:10'), c3 HAVING date(c3) > '2000-01-01';
                                                                                                        QUERY PLAN                                                                                                        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=199 width=20)
   Output: (max(c3)), (date((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date(`c3`) > '2000-01-01')) GROUP BY 2, 3
(5 rows)

-- select date with group by having (result)
--Testcase 2283:
SELECT max(c3), date(c3 + '1 12:59:10') FROM time_tbl group by date(c3 + '1 12:59:10'), c3 HAVING date(c3) > '2000-01-01';
         max         |    date    
---------------------+------------
 2021-01-03 12:10:30 | 2021-01-05
 2021-01-04 23:12:13 | 2021-01-06
 2021-01-05 11:12:12 | 2021-01-07
 2021-01-06 16:00:00 | 2021-01-08
 2021-01-07 00:59:59 | 2021-01-08
(5 rows)

-- select date with group by index having (result)
--Testcase 2284:
SELECT id, date(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING date(c3 + '1 12:59:10') > '2000-01-01';
 id |    date    |         c3          
----+------------+---------------------
  0 | 2021-01-05 | 2021-01-03 12:10:30
  1 | 2021-01-06 | 2021-01-04 23:12:13
  2 | 2021-01-07 | 2021-01-05 11:12:12
  3 | 2021-01-08 | 2021-01-06 16:00:00
  4 | 2021-01-08 | 2021-01-07 00:59:59
(5 rows)

-- select date with group by index having (result)
--Testcase 2285:
SELECT id, date(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING date(c3 + '1 12:59:10') > '2000-01-01';
 id |    date    |         c3          
----+------------+---------------------
  0 | 2021-01-05 | 2021-01-03 12:10:30
  1 | 2021-01-06 | 2021-01-04 23:12:13
  2 | 2021-01-07 | 2021-01-05 11:12:12
  3 | 2021-01-08 | 2021-01-06 16:00:00
  4 | 2021-01-08 | 2021-01-07 00:59:59
(5 rows)

-- select date and as
--Testcase 2286:
SELECT date(date_sub(c3, '1 12:59:10')) as date1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- DATE_ADD()
-- select date_add (stub function, explain)
--Testcase 2287:
EXPLAIN VERBOSE
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl;
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=32)
   Output: date_add((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval), date_add(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 2 mons'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date_add (stub function, result)
--Testcase 2288:
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl;
ERROR:  stub date_add(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_add(timestamp without time zone,interval) line 3 at RAISE
-- select date_add (stub function, not pushdown constraints, explain)
--Testcase 2289:
EXPLAIN VERBOSE
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=32)
   Output: date_add((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval), date_add(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 2 mons'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select date_add (stub function, not pushdown constraints, result)
--Testcase 2290:
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub date_add(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_add(timestamp without time zone,interval) line 3 at RAISE
-- select date_add (stub function, pushdown constraints, explain)
--Testcase 2291:
EXPLAIN VERBOSE
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl WHERE id != 1;
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=32)
   Output: date_add((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval), date_add(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 2 mons'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 1))
(4 rows)

-- select date_add (stub function, pushdown constraints, result)
--Testcase 2292:
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl WHERE id != 1;
ERROR:  stub date_add(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_add(timestamp without time zone,interval) line 3 at RAISE
-- select date_add (stub function, date_add in constraints, explain)
--Testcase 2293:
EXPLAIN VERBOSE
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl WHERE date_add(c2, '1 12:59:10'::interval) != '2000-01-01';
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..229.05 rows=2264 width=32)
   Output: date_add((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval), date_add(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 2 mons'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date_add(`c2`, INTERVAL '1 12:59:10.0' DAY_MICROSECOND) <> '2000-01-01 00:00:00'))
(4 rows)

-- select date_add (stub function, date_add in constraints, result)
--Testcase 2294:
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl WHERE date_add(c2, '1 12:59:10'::interval) != '2000-01-01';
ERROR:  stub date_add(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_add(timestamp without time zone,interval) line 3 at RAISE
-- select date_add (stub function, date_add in constraints, explain)
--Testcase 2295:
EXPLAIN VERBOSE
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl WHERE date_add('2021-01-02', '1-2'::interval) > '2000-01-01';
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=32)
   Output: date_add((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval), date_add(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 2 mons'::interval), date_add('2021-01-02 00:00:00'::timestamp without time zone, '@ 1 year 2 mons'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date_add('2021-01-02 00:00:00', INTERVAL '1-2' YEAR_MONTH) > '2000-01-01 00:00:00'))
(4 rows)

-- select date_add (stub function, date_add in constraints, result)
--Testcase 2296:
SELECT date_add(c2, '1 12:59:10'::interval), date_add('2021-01-02', '1-2'::interval), date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), date_add('2021-01-02', '1-2'::interval) FROM time_tbl WHERE date_add('2021-01-02', '1-2'::interval) > '2000-01-01';
ERROR:  stub date_add(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_add(timestamp without time zone,interval) line 3 at RAISE
-- select date_add with agg (pushdown, explain)
--Testcase 2297:
EXPLAIN VERBOSE
SELECT max(c3), date_add(max(c2) , '1-2'::interval) FROM time_tbl;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c3)), (date_add((max(c2))::timestamp without time zone, '@ 1 year 2 mons'::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_add(max(`c2`), INTERVAL '1-2' YEAR_MONTH) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select date_add as nest function with agg (pushdown, result)
--Testcase 2298:
SELECT max(c3), date_add(max(c2) , '1-2'::interval) FROM time_tbl;
         max         |      date_add       
---------------------+---------------------
 2021-01-07 00:59:59 | 2022-03-29 00:00:00
(1 row)

-- select date_add with non pushdown func and explicit constant (explain)
--Testcase 2299:
EXPLAIN VERBOSE
SELECT date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), pi(), 4.1 FROM time_tbl;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=48)
   Output: date_add(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 2 mons'::interval), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date_add with non pushdown func and explicit constant (result)
--Testcase 2300:
SELECT date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date_add with order by (explain)
--Testcase 2301:
EXPLAIN VERBOSE
SELECT id, date_add(c2 + '1 d'::interval , '1-2'::interval) FROM time_tbl order by date_add(c2 + '1 d'::interval , '1-2'::interval);
                                                                                                                              QUERY PLAN                                                                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: id, date_add((c2 + '@ 1 day'::interval), '@ 1 year 2 mons'::interval)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY date_add((`c2` + INTERVAL '1 0:0:0.0' DAY_MICROSECOND), INTERVAL '1-2' YEAR_MONTH) IS NULL ASC, date_add((`c2` + INTERVAL '1 0:0:0.0' DAY_MICROSECOND), INTERVAL '1-2' YEAR_MONTH) ASC
(4 rows)

-- select date_add with order by (result)
--Testcase 2302:
SELECT id, date_add(c2 + '1 d'::interval , '1-2'::interval) FROM time_tbl order by date_add(c2 + '1 d'::interval , '1-2'::interval);
ERROR:  stub date_add(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_add(timestamp without time zone,interval) line 3 at RAISE
-- select date_add with order by index (result)
--Testcase 2303:
SELECT id, date_add(c2 + '1 d'::interval , '1-2'::interval) FROM time_tbl order by 2,1;
ERROR:  stub date_add(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_add(timestamp without time zone,interval) line 3 at RAISE
-- select date_add with order by index (result)
--Testcase 2304:
SELECT id, date_add(c2 + '1 d'::interval , '1-2'::interval) FROM time_tbl order by 1,2;
ERROR:  stub date_add(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_add(timestamp without time zone,interval) line 3 at RAISE
-- select date_add with group by (explain)
--Testcase 2305:
EXPLAIN VERBOSE
SELECT max(c3), date_add(c2 + '1 d'::interval , '1-2'::interval) FROM time_tbl group by date_add(c2 + '1 d'::interval , '1-2'::interval);
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (max(c3)), (date_add((c2 + '@ 1 day'::interval), '@ 1 year 2 mons'::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_add((`c2` + INTERVAL '1 0:0:0.0' DAY_MICROSECOND), INTERVAL '1-2' YEAR_MONTH) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select date_add with group by (result)
--Testcase 2306:
SELECT max(c3), date_add(c2 + '1 d'::interval , '1-2'::interval) FROM time_tbl group by date_add(c2 + '1 d'::interval , '1-2'::interval);
         max         |      date_add       
---------------------+---------------------
 2021-01-03 12:10:30 | 2022-03-03 00:00:00
 2021-01-04 23:12:13 | 2022-03-02 00:00:00
 2021-01-05 11:12:12 | 2022-03-11 00:00:00
 2021-01-06 16:00:00 | 2022-03-16 00:00:00
 2021-01-07 00:59:59 | 2022-03-30 00:00:00
(5 rows)

-- select date_add with group by index (result)
--Testcase 2307:
SELECT id, date_add(c2 + '1 d'::interval , '1-2'::interval) FROM time_tbl group by 2,1;
 id |      date_add       
----+---------------------
  0 | 2022-03-03 00:00:00
  1 | 2022-03-02 00:00:00
  2 | 2022-03-11 00:00:00
  3 | 2022-03-16 00:00:00
  4 | 2022-03-30 00:00:00
(5 rows)

-- select date_add with group by index (result)
--Testcase 2308:
SELECT id, date_add(c2 + '1 d'::interval , '1-2'::interval) FROM time_tbl group by 1,2;
 id |      date_add       
----+---------------------
  0 | 2022-03-03 00:00:00
  1 | 2022-03-02 00:00:00
  2 | 2022-03-11 00:00:00
  3 | 2022-03-16 00:00:00
  4 | 2022-03-30 00:00:00
(5 rows)

-- select date_add with group by having (explain)
--Testcase 2309:
EXPLAIN VERBOSE
SELECT max(c3), date_add(c2 + '1 d'::interval , '1-2'::interval), c2 FROM time_tbl group by date_add(c2 + '1 d'::interval , '1-2'::interval), c3,c2 HAVING date_add(c2 + '1 d'::interval , '1-2'::interval) > '2000-01-01';
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=76 width=28)
   Output: (max(c3)), (date_add((c2 + '@ 1 day'::interval), '@ 1 year 2 mons'::interval)), c2, c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_add((`c2` + INTERVAL '1 0:0:0.0' DAY_MICROSECOND), INTERVAL '1-2' YEAR_MONTH), `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 4, 3 HAVING ((date_add((`c2` + INTERVAL '1 0:0:0.0' DAY_MICROSECOND), INTERVAL '1-2' YEAR_MONTH) > '2000-01-01 00:00:00'))
(5 rows)

-- select date_add with group by having (result)
--Testcase 2310:
SELECT max(c3), date_add(c2 + '1 d'::interval , '1-2'::interval), c2 FROM time_tbl group by date_add(c2 + '1 d'::interval , '1-2'::interval), c3,c2 HAVING date_add(c2 + '1 d'::interval , '1-2'::interval) > '2000-01-01';
         max         |      date_add       |     c2     
---------------------+---------------------+------------
 2021-01-03 12:10:30 | 2022-03-03 00:00:00 | 2021-01-02
 2021-01-04 23:12:13 | 2022-03-02 00:00:00 | 2021-01-01
 2021-01-05 11:12:12 | 2022-03-11 00:00:00 | 2021-01-10
 2021-01-06 16:00:00 | 2022-03-16 00:00:00 | 2021-01-15
 2021-01-07 00:59:59 | 2022-03-30 00:00:00 | 2021-01-29
(5 rows)

-- select date_add with group by index having (result)
--Testcase 2311:
SELECT c2, date_add(c2 + '1 d'::interval , '1-2'::interval), c3 FROM time_tbl group by 3, 2, 1 HAVING date_add(c2 + '1 d'::interval , '1-2'::interval) > '2000-01-01';
     c2     |      date_add       |         c3          
------------+---------------------+---------------------
 2021-01-02 | 2022-03-03 00:00:00 | 2021-01-03 12:10:30
 2021-01-01 | 2022-03-02 00:00:00 | 2021-01-04 23:12:13
 2021-01-10 | 2022-03-11 00:00:00 | 2021-01-05 11:12:12
 2021-01-15 | 2022-03-16 00:00:00 | 2021-01-06 16:00:00
 2021-01-29 | 2022-03-30 00:00:00 | 2021-01-07 00:59:59
(5 rows)

-- select date_add with group by index having (result)
--Testcase 2312:
SELECT c2, date_add(c2 + '1 d'::interval , '1-2'::interval), c3 FROM time_tbl group by 1, 2, 3 HAVING date_add(c2 + '1 d'::interval , '1-2'::interval) > '2000-01-01';
     c2     |      date_add       |         c3          
------------+---------------------+---------------------
 2021-01-02 | 2022-03-03 00:00:00 | 2021-01-03 12:10:30
 2021-01-01 | 2022-03-02 00:00:00 | 2021-01-04 23:12:13
 2021-01-10 | 2022-03-11 00:00:00 | 2021-01-05 11:12:12
 2021-01-15 | 2022-03-16 00:00:00 | 2021-01-06 16:00:00
 2021-01-29 | 2022-03-30 00:00:00 | 2021-01-07 00:59:59
(5 rows)

-- select date_add and as
--Testcase 2313:
SELECT date_add(date_sub(c3, '1 12:59:10'),  '1-2'::interval) as date_add1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- DATE_FORMAT()
-- select date_format (stub function, explain)
--Testcase 2314:
EXPLAIN VERBOSE
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.69 rows=2275 width=128)
   Output: date_format(c3, '%H %k %I %r %T %S %w'::text), date_format(c3, '%W %M %Y'::text), date_format((c2)::timestamp without time zone, '%X %V'::text), date_format('2009-10-04 22:23:00'::timestamp without time zone, '%W %M %Y'::text)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date_format (stub function, result)
--Testcase 2315:
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl;
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format (stub function, not pushdown constraints, explain)
--Testcase 2316:
EXPLAIN VERBOSE
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.48 rows=11 width=128)
   Output: date_format(c3, '%H %k %I %r %T %S %w'::text), date_format(c3, '%W %M %Y'::text), date_format((c2)::timestamp without time zone, '%X %V'::text), date_format('2009-10-04 22:23:00'::timestamp without time zone, '%W %M %Y'::text)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select date_format (stub function, not pushdown constraints, result)
--Testcase 2317:
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format (stub function, pushdown constraints, explain)
--Testcase 2318:
EXPLAIN VERBOSE
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl WHERE id != 1;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.02 rows=2264 width=128)
   Output: date_format(c3, '%H %k %I %r %T %S %w'::text), date_format(c3, '%W %M %Y'::text), date_format((c2)::timestamp without time zone, '%X %V'::text), date_format('2009-10-04 22:23:00'::timestamp without time zone, '%W %M %Y'::text)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 1))
(4 rows)

-- select date_format (stub function, pushdown constraints, result)
--Testcase 2319:
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl WHERE id != 1;
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format (stub function, date_format in constraints, explain)
--Testcase 2320:
EXPLAIN VERBOSE
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl WHERE date_format(c3,'%H %k %I %r %T %S %w') NOT LIKE '2000-01-01';
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.70 rows=2264 width=128)
   Output: date_format(c3, '%H %k %I %r %T %S %w'::text), date_format(c3, '%W %M %Y'::text), date_format((c2)::timestamp without time zone, '%X %V'::text), date_format('2009-10-04 22:23:00'::timestamp without time zone, '%W %M %Y'::text)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date_format(`c3`, '%H %k %I %r %T %S %w') NOT LIKE BINARY '2000-01-01'))
(4 rows)

-- select date_format (stub function, date_format in constraints, result)
--Testcase 2321:
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl WHERE date_format(c3,'%H %k %I %r %T %S %w') NOT LIKE '2000-01-01';
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format (stub function, date_format in constraints, explain)
--Testcase 2322:
EXPLAIN VERBOSE
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl WHERE date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') IS NOT NULL;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.02 rows=2264 width=128)
   Output: date_format(c3, '%H %k %I %r %T %S %w'::text), date_format(c3, '%W %M %Y'::text), date_format((c2)::timestamp without time zone, '%X %V'::text), date_format('2009-10-04 22:23:00'::timestamp without time zone, '%W %M %Y'::text)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date_format('2009-10-04 22:23:00', '%W %M %Y') IS NOT NULL))
(4 rows)

-- select date_format (stub function, date_format in constraints, result)
--Testcase 2323:
SELECT date_format(c3,'%H %k %I %r %T %S %w'), date_format(c3, '%W %M %Y'), date_format(c2, '%X %V'), date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') FROM time_tbl WHERE date_format('2009-10-04 22:23:00'::timestamp, '%W %M %Y') IS NOT NULL;
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format with agg (pushdown, explain)
--Testcase 2324:
EXPLAIN VERBOSE
SELECT max(c3), date_format(max(c3), '%H %k %I %r %T %S %w') FROM time_tbl;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (max(c3)), (date_format(max(c3), '%H %k %I %r %T %S %w'::text))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_format(max(`c3`), '%H %k %I %r %T %S %w') FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select date_format as nest function with agg (pushdown, result)
--Testcase 2325:
SELECT max(c3), date_format(max(c3), '%H %k %I %r %T %S %w') FROM time_tbl;
         max         |            date_format            
---------------------+-----------------------------------
 2021-01-07 00:59:59 | 00 0 12 12:59:59 AM 00:59:59 59 4
(1 row)

-- select date_format with non pushdown func and explicit constant (explain)
--Testcase 2326:
EXPLAIN VERBOSE
SELECT date_format(c2, '%X %V'), pi(), 4.1 FROM time_tbl;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=72)
   Output: date_format((c2)::timestamp without time zone, '%X %V'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date_format with non pushdown func and explicit constant (result)
--Testcase 2327:
SELECT date_format(c2, '%X %V'), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format with order by (explain)
--Testcase 2328:
EXPLAIN VERBOSE
SELECT id, date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl order by date_format(c3 + '1 12:59:10', '%H:%i:%s');
                                                                                                                                                         QUERY PLAN                                                                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=36)
   Output: id, date_format((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '%H:%i:%s'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY date_format((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '%H:%i:%s') IS NULL ASC, date_format((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '%H:%i:%s') ASC
(4 rows)

-- select date_format with order by (result)
--Testcase 2329:
SELECT id, date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl order by date_format(c3 + '1 12:59:10', '%H:%i:%s');
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format with order by index (result)
--Testcase 2330:
SELECT id, date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl order by 2,1;
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format with order by index (result)
--Testcase 2331:
SELECT id, date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl order by 1,2;
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- select date_format with group by (explain)
--Testcase 2332:
EXPLAIN VERBOSE
SELECT max(c3), date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl group by date_format(c3 + '1 12:59:10', '%H:%i:%s');
                                                                                           QUERY PLAN                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (max(c3)), (date_format((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '%H:%i:%s'::text))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_format((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '%H:%i:%s') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select date_format with group by (result)
--Testcase 2333:
SELECT max(c3), date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl group by date_format(c3 + '1 12:59:10', '%H:%i:%s');
         max         | date_format 
---------------------+-------------
 2021-01-03 12:10:30 | 01:09:40
 2021-01-04 23:12:13 | 12:11:23
 2021-01-05 11:12:12 | 00:11:22
 2021-01-06 16:00:00 | 04:59:10
 2021-01-07 00:59:59 | 13:59:09
(5 rows)

-- select date_format with group by index (result)
--Testcase 2334:
SELECT id, date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl group by 2,1;
 id | date_format 
----+-------------
  0 | 01:09:40
  1 | 12:11:23
  2 | 00:11:22
  3 | 04:59:10
  4 | 13:59:09
(5 rows)

-- select date_format with group by index (result)
--Testcase 2335:
SELECT id, date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl group by 1,2;
 id | date_format 
----+-------------
  0 | 01:09:40
  1 | 12:11:23
  2 | 00:11:22
  3 | 04:59:10
  4 | 13:59:09
(5 rows)

-- select date_format with group by having (explain)
--Testcase 2336:
EXPLAIN VERBOSE
SELECT max(c3), date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl group by date_format(c3 + '1 12:59:10', '%H:%i:%s'), c3 HAVING date_format(c3 + '1 12:59:10', '%H:%i:%s') > '2000-01-01';
                                                                                                                                                                   QUERY PLAN                                                                                                                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=48)
   Output: (max(c3)), (date_format((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '%H:%i:%s'::text)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_format((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '%H:%i:%s'), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((date_format((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), '%H:%i:%s') > '2000-01-01'))
(5 rows)

-- select date_format with group by having (result)
--Testcase 2337:
SELECT max(c3), date_format(c3 + '1 12:59:10', '%H:%i:%s') FROM time_tbl group by date_format(c3 + '1 12:59:10', '%H:%i:%s'), c3 HAVING date_format(c3 + '1 12:59:10', '%H:%i:%s') > '2000-01-01';
 max | date_format 
-----+-------------
(0 rows)

-- select date_format with group by index having (result)
--Testcase 2338:
SELECT id, date_format(c3 + '1 12:59:10', '%H:%i:%s'), c3 FROM time_tbl group by 3, 2, 1 HAVING date_format(c3 + '1 12:59:10', '%H:%i:%s') IS NOT NULL;
 id | date_format |         c3          
----+-------------+---------------------
  0 | 01:09:40    | 2021-01-03 12:10:30
  1 | 12:11:23    | 2021-01-04 23:12:13
  2 | 00:11:22    | 2021-01-05 11:12:12
  3 | 04:59:10    | 2021-01-06 16:00:00
  4 | 13:59:09    | 2021-01-07 00:59:59
(5 rows)

-- select date_format with group by index having (result)
--Testcase 2339:
SELECT id, date_format(c3 + '1 12:59:10', '%H:%i:%s'), c3 FROM time_tbl group by 1, 2, 3 HAVING date_format(c3 + '1 12:59:10', '%H:%i:%s') IS NOT NULL;
 id | date_format |         c3          
----+-------------+---------------------
  0 | 01:09:40    | 2021-01-03 12:10:30
  1 | 12:11:23    | 2021-01-04 23:12:13
  2 | 00:11:22    | 2021-01-05 11:12:12
  3 | 04:59:10    | 2021-01-06 16:00:00
  4 | 13:59:09    | 2021-01-07 00:59:59
(5 rows)

-- select date_format and as
--Testcase 2340:
SELECT date_format(c2, '%X %V') as date_format1 FROM time_tbl;
ERROR:  stub date_format(timestamp, text) is called
CONTEXT:  PL/pgSQL function date_format(timestamp without time zone,text) line 3 at RAISE
-- DATE_SUB()
-- select date_sub (stub function, explain)
--Testcase 2341:
EXPLAIN VERBOSE
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl;
                                                                                                                                                 QUERY PLAN                                                                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.69 rows=2275 width=24)
   Output: date_sub(c2, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_sub(c2, '@ 1 year 1 mon'::interval), date_sub(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 1 mon'::interval), date_sub('2021-01-01 12:00:00'::timestamp without time zone, '@ 1 year 1 mon'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date_sub (stub function, result)
--Testcase 2342:
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl;
ERROR:  stub date_sub(date, interval) is called
CONTEXT:  PL/pgSQL function date_sub(date,interval) line 3 at RAISE
-- select date_sub (stub function, not pushdown constraints, explain)
--Testcase 2343:
EXPLAIN VERBOSE
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                                                 QUERY PLAN                                                                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.48 rows=11 width=24)
   Output: date_sub(c2, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_sub(c2, '@ 1 year 1 mon'::interval), date_sub(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 1 mon'::interval), date_sub('2021-01-01 12:00:00'::timestamp without time zone, '@ 1 year 1 mon'::interval)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select date_sub (stub function, not pushdown constraints, result)
--Testcase 2344:
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub date_sub(date, interval) is called
CONTEXT:  PL/pgSQL function date_sub(date,interval) line 3 at RAISE
-- select date_sub (stub function, pushdown constraints, explain)
--Testcase 2345:
EXPLAIN VERBOSE
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl WHERE id != 1;
                                                                                                                                                 QUERY PLAN                                                                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.02 rows=2264 width=24)
   Output: date_sub(c2, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_sub(c2, '@ 1 year 1 mon'::interval), date_sub(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 1 mon'::interval), date_sub('2021-01-01 12:00:00'::timestamp without time zone, '@ 1 year 1 mon'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 1))
(4 rows)

-- select date_sub (stub function, pushdown constraints, result)
--Testcase 2346:
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl WHERE id != 1;
ERROR:  stub date_sub(date, interval) is called
CONTEXT:  PL/pgSQL function date_sub(date,interval) line 3 at RAISE
-- select date_sub (stub function, date_sub in constraints, explain)
--Testcase 2347:
EXPLAIN VERBOSE
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl WHERE date_sub(c2, '1 12:59:10') != '2000-01-01';
                                                                                                                                                 QUERY PLAN                                                                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.70 rows=2264 width=24)
   Output: date_sub(c2, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_sub(c2, '@ 1 year 1 mon'::interval), date_sub(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 1 mon'::interval), date_sub('2021-01-01 12:00:00'::timestamp without time zone, '@ 1 year 1 mon'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date_sub(`c2`, INTERVAL '1 12:59:10.0' DAY_MICROSECOND) <> '2000-01-01'))
(4 rows)

-- select date_sub (stub function, date_sub in constraints, result)
--Testcase 2348:
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl WHERE date_sub(c2, '1 12:59:10') != '2000-01-01';
ERROR:  stub date_sub(date, interval) is called
CONTEXT:  PL/pgSQL function date_sub(date,interval) line 3 at RAISE
-- select date_sub (stub function, date_sub in constraints, explain)
--Testcase 2349:
EXPLAIN VERBOSE
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl WHERE date_sub('2021-01-01 12:00:00'::timestamp, '1-1') > '2000-01-01';
                                                                                                                                                 QUERY PLAN                                                                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..168.76 rows=758 width=24)
   Output: date_sub(c2, '@ 1 day 12 hours 59 mins 10 secs'::interval), date_sub(c2, '@ 1 year 1 mon'::interval), date_sub(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 1 mon'::interval), date_sub('2021-01-01 12:00:00'::timestamp without time zone, '@ 1 year 1 mon'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date_sub('2021-01-01 12:00:00', INTERVAL '1-1' YEAR_MONTH) > '2000-01-01 00:00:00'))
(4 rows)

-- select date_sub (stub function, date_sub in constraints, result)
--Testcase 2350:
SELECT date_sub(c2, '1 12:59:10'), date_sub(c2, '1-1'), date_sub(date_sub(c3, '1 12:59:10'), '1-1'), date_sub('2021-01-01 12:00:00'::timestamp, '1-1') FROM time_tbl WHERE date_sub('2021-01-01 12:00:00'::timestamp, '1-1') > '2000-01-01';
ERROR:  stub date_sub(date, interval) is called
CONTEXT:  PL/pgSQL function date_sub(date,interval) line 3 at RAISE
-- select date_sub with agg (pushdown, explain)
--Testcase 2351:
EXPLAIN VERBOSE
SELECT max(c3), date_sub(max(c3), '1 12:59:10') FROM time_tbl;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c3)), (date_sub(max(c3), '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_sub(max(`c3`), INTERVAL '1 12:59:10.0' DAY_MICROSECOND) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select date_sub as nest function with agg (pushdown, result)
--Testcase 2352:
SELECT max(c3), date_sub(max(c3), '1 12:59:10') FROM time_tbl;
         max         |      date_sub       
---------------------+---------------------
 2021-01-07 00:59:59 | 2021-01-05 12:00:49
(1 row)

-- select date_sub with non pushdown func and explicit constant (explain)
--Testcase 2353:
EXPLAIN VERBOSE
SELECT date_sub(date_sub(c3, '1 12:59:10'), '1-1'), pi(), 4.1 FROM time_tbl;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=48)
   Output: date_sub(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 year 1 mon'::interval), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select date_sub with non pushdown func and explicit constant (result)
--Testcase 2354:
SELECT date_sub(date_sub(c3, '1 12:59:10'), '1-1'), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date_sub with order by (explain)
--Testcase 2355:
EXPLAIN VERBOSE
SELECT id, date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl order by date_sub(c3 + '1 12:59:10', '1 12:59:10');
                                                                                                                                               QUERY PLAN                                                                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: id, date_sub((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 day 12 hours 59 mins 10 secs'::interval)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY date_sub((`c3` + INTERVAL '1 12:59:10.0' DAY_MICROSECOND), INTERVAL '1 12:59:10.0' DAY_MICROSECOND) IS NULL ASC, date_sub((`c3` + INTERVAL '1 12:59:10.0' DAY_MICROSECOND), INTERVAL '1 12:59:10.0' DAY_MICROSECOND) ASC
(4 rows)

-- select date_sub with order by (result)
--Testcase 2356:
SELECT id, date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl order by date_sub(c3 + '1 12:59:10', '1 12:59:10');
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date_sub with order by index (result)
--Testcase 2357:
SELECT id, date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date_sub with order by index (result)
--Testcase 2358:
SELECT id, date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select date_sub with group by (explain)
--Testcase 2359:
EXPLAIN VERBOSE
SELECT max(c3), date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl group by date_sub(c3 + '1 12:59:10', '1 12:59:10');
                                                                                      QUERY PLAN                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (max(c3)), (date_sub((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_sub((`c3` + INTERVAL '1 12:59:10.0' DAY_MICROSECOND), INTERVAL '1 12:59:10.0' DAY_MICROSECOND) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select date_sub with group by (result)
--Testcase 2360:
SELECT max(c3), date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl group by date_sub(c3 + '1 12:59:10', '1 12:59:10');
         max         |      date_sub       
---------------------+---------------------
 2021-01-03 12:10:30 | 2021-01-03 12:10:30
 2021-01-04 23:12:13 | 2021-01-04 23:12:13
 2021-01-05 11:12:12 | 2021-01-05 11:12:12
 2021-01-06 16:00:00 | 2021-01-06 16:00:00
 2021-01-07 00:59:59 | 2021-01-07 00:59:59
(5 rows)

-- select date_sub with group by index (result)
--Testcase 2361:
SELECT id, date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl group by 2,1;
 id |      date_sub       
----+---------------------
  0 | 2021-01-03 12:10:30
  1 | 2021-01-04 23:12:13
  2 | 2021-01-05 11:12:12
  3 | 2021-01-06 16:00:00
  4 | 2021-01-07 00:59:59
(5 rows)

-- select date_sub with group by index (result)
--Testcase 2362:
SELECT id, date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl group by 1,2;
 id |      date_sub       
----+---------------------
  0 | 2021-01-03 12:10:30
  1 | 2021-01-04 23:12:13
  2 | 2021-01-05 11:12:12
  3 | 2021-01-06 16:00:00
  4 | 2021-01-07 00:59:59
(5 rows)

-- select date_sub with group by having (explain)
--Testcase 2363:
EXPLAIN VERBOSE
SELECT max(c3), date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl group by date_sub(c3 + '1 12:59:10', '1 12:59:10'), c3 HAVING date_sub(c3 + '1 12:59:10', '1 12:59:10') > '2000-01-01';
                                                                                                                                                              QUERY PLAN                                                                                                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=24)
   Output: (max(c3)), (date_sub((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), '@ 1 day 12 hours 59 mins 10 secs'::interval)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), date_sub((`c3` + INTERVAL '1 12:59:10.0' DAY_MICROSECOND), INTERVAL '1 12:59:10.0' DAY_MICROSECOND), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((date_sub((`c3` + INTERVAL '1 12:59:10.0' DAY_MICROSECOND), INTERVAL '1 12:59:10.0' DAY_MICROSECOND) > '2000-01-01 00:00:00'))
(5 rows)

-- select date_sub with group by having (result)
--Testcase 2364:
SELECT max(c3), date_sub(c3 + '1 12:59:10', '1 12:59:10') FROM time_tbl group by date_sub(c3 + '1 12:59:10', '1 12:59:10'), c3 HAVING date_sub(c3 + '1 12:59:10', '1 12:59:10') > '2000-01-01';
         max         |      date_sub       
---------------------+---------------------
 2021-01-03 12:10:30 | 2021-01-03 12:10:30
 2021-01-04 23:12:13 | 2021-01-04 23:12:13
 2021-01-05 11:12:12 | 2021-01-05 11:12:12
 2021-01-06 16:00:00 | 2021-01-06 16:00:00
 2021-01-07 00:59:59 | 2021-01-07 00:59:59
(5 rows)

-- select date_sub with group by index having (result)
--Testcase 2365:
SELECT id, date_sub(c3 + '1 12:59:10', '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING date_sub(c3 + '1 12:59:10', '1 12:59:10') > '2000-01-01';
 id |      date_sub       |         c3          
----+---------------------+---------------------
  0 | 2021-01-03 12:10:30 | 2021-01-03 12:10:30
  1 | 2021-01-04 23:12:13 | 2021-01-04 23:12:13
  2 | 2021-01-05 11:12:12 | 2021-01-05 11:12:12
  3 | 2021-01-06 16:00:00 | 2021-01-06 16:00:00
  4 | 2021-01-07 00:59:59 | 2021-01-07 00:59:59
(5 rows)

-- select date_sub with group by index having (result)
--Testcase 2366:
SELECT id, date_sub(c3 + '1 12:59:10', '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING date_sub(c3 + '1 12:59:10', '1 12:59:10') > '2000-01-01';
 id |      date_sub       |         c3          
----+---------------------+---------------------
  0 | 2021-01-03 12:10:30 | 2021-01-03 12:10:30
  1 | 2021-01-04 23:12:13 | 2021-01-04 23:12:13
  2 | 2021-01-05 11:12:12 | 2021-01-05 11:12:12
  3 | 2021-01-06 16:00:00 | 2021-01-06 16:00:00
  4 | 2021-01-07 00:59:59 | 2021-01-07 00:59:59
(5 rows)

-- select date_sub and as
--Testcase 2367:
SELECT date_sub(date_sub(c3, '1 12:59:10'), '1-1') as date_sub1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- DATEDIFF()
-- select datediff (stub function, explain)
--Testcase 2368:
EXPLAIN VERBOSE
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl;
                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..218.06 rows=2275 width=16)
   Output: datediff(c3, (c2)::timestamp without time zone), datediff((c2)::timestamp without time zone, '2004-10-19 10:23:54'::timestamp without time zone), datediff((c2)::timestamp without time zone, '2007-12-31 00:00:00'::timestamp without time zone), datediff('2007-12-31 23:59:59'::timestamp without time zone, '2007-12-30 00:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select datediff (stub function, result)
--Testcase 2369:
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl;
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff (stub function, not pushdown constraints, explain)
--Testcase 2370:
EXPLAIN VERBOSE
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.54 rows=11 width=16)
   Output: datediff(c3, (c2)::timestamp without time zone), datediff((c2)::timestamp without time zone, '2004-10-19 10:23:54'::timestamp without time zone), datediff((c2)::timestamp without time zone, '2007-12-31 00:00:00'::timestamp without time zone), datediff('2007-12-31 23:59:59'::timestamp without time zone, '2007-12-30 00:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select datediff (stub function, not pushdown constraints, result)
--Testcase 2371:
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff (stub function, pushdown constraints, explain)
--Testcase 2372:
EXPLAIN VERBOSE
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl WHERE id != 0;
                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..223.34 rows=2264 width=16)
   Output: datediff(c3, (c2)::timestamp without time zone), datediff((c2)::timestamp without time zone, '2004-10-19 10:23:54'::timestamp without time zone), datediff((c2)::timestamp without time zone, '2007-12-31 00:00:00'::timestamp without time zone), datediff('2007-12-31 23:59:59'::timestamp without time zone, '2007-12-30 00:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select datediff (stub function, pushdown constraints, result)
--Testcase 2373:
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl WHERE id != 0;
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff (stub function, datediff in constraints, explain)
--Testcase 2374:
EXPLAIN VERBOSE
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl WHERE datediff(c3, c2) != 0;
                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..234.71 rows=2264 width=16)
   Output: datediff(c3, (c2)::timestamp without time zone), datediff((c2)::timestamp without time zone, '2004-10-19 10:23:54'::timestamp without time zone), datediff((c2)::timestamp without time zone, '2007-12-31 00:00:00'::timestamp without time zone), datediff('2007-12-31 23:59:59'::timestamp without time zone, '2007-12-30 00:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((datediff(`c3`, `c2`) <> 0))
(4 rows)

-- select datediff (stub function, datediff in constraints, result)
--Testcase 2375:
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl WHERE datediff(c3, c2) != 0;
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff (stub function, datediff in constraints, explain)
--Testcase 2376:
EXPLAIN VERBOSE
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl WHERE datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') > 0;
                                                                                                                                                                                  QUERY PLAN                                                                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..172.55 rows=758 width=16)
   Output: datediff(c3, (c2)::timestamp without time zone), datediff((c2)::timestamp without time zone, '2004-10-19 10:23:54'::timestamp without time zone), datediff((c2)::timestamp without time zone, '2007-12-31 00:00:00'::timestamp without time zone), datediff('2007-12-31 23:59:59'::timestamp without time zone, '2007-12-30 00:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((datediff('2007-12-31 23:59:59', '2007-12-30 00:00:00') > 0))
(4 rows)

-- select datediff (stub function, datediff in constraints, result)
--Testcase 2377:
SELECT datediff(c3, c2), datediff(c2, '2004-10-19 10:23:54'::timestamp), datediff(c2, '2007-12-31'::date), datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') FROM time_tbl WHERE datediff('2007-12-31 23:59:59'::timestamp, '2007-12-30') > 0;
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff as nest function with agg (pushdown, explain)
--Testcase 2378:
EXPLAIN VERBOSE
SELECT max(c2), datediff('2021-01-02'::date, max(c2)) FROM time_tbl;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
   Output: (max(c2)), (datediff('2021-01-02 00:00:00'::timestamp without time zone, (max(c2))::timestamp without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c2`), datediff('2021-01-02 00:00:00', max(`c2`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select datediff as nest function with agg (pushdown, result)
--Testcase 2379:
SELECT max(c2), datediff('2021-01-02'::date, max(c2)) FROM time_tbl;
    max     | datediff 
------------+----------
 2021-01-29 |      -27
(1 row)

-- select datediff as nest with stub (pushdown, explain)
--Testcase 2380:
EXPLAIN VERBOSE
SELECT datediff(makedate(2019, id), c2) FROM time_tbl;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.40 rows=2560 width=4)
   Output: datediff((makedate(2019, id))::timestamp without time zone, (c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select datediff as nest with stub (pushdown, result)
--Testcase 2381:
SELECT datediff(makedate(2019, id), c2) FROM time_tbl;
ERROR:  stub makedate(integer, integer) is called
CONTEXT:  PL/pgSQL function makedate(integer,integer) line 3 at RAISE
-- select datediff with non pushdown func and explicit constant (explain)
--Testcase 2382:
EXPLAIN VERBOSE
SELECT datediff(c2, '2007-12-31'::date), pi(), 4.1 FROM time_tbl;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: datediff((c2)::timestamp without time zone, '2007-12-31 00:00:00'::timestamp without time zone), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select datediff with non pushdown func and explicit constant (result)
--Testcase 2383:
SELECT datediff(c2, '2007-12-31'::date), pi(), 4.1 FROM time_tbl;
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff with order by (explain)
--Testcase 2384:
EXPLAIN VERBOSE
SELECT id, datediff(c3 + '1 12:59:10', c2 ) FROM time_tbl order by datediff(c3 + '1 12:59:10', c2 );
                                                                                                                                                   QUERY PLAN                                                                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=8)
   Output: id, datediff((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), (c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY datediff((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), `c2`) IS NULL ASC, datediff((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), `c2`) ASC
(4 rows)

-- select datediff with order by (result)
--Testcase 2385:
SELECT id, datediff(c3 + '1 12:59:10', c2 ) FROM time_tbl order by datediff(c3 + '1 12:59:10', c2 );
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff with order by index (result)
--Testcase 2386:
SELECT id, datediff(c3 + '1 12:59:10', c2 ) FROM time_tbl order by 2,1;
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff with order by index (result)
--Testcase 2387:
SELECT id, datediff(c3 + '1 12:59:10', c2 ) FROM time_tbl order by 1,2;
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select datediff with group by (explain)
--Testcase 2388:
EXPLAIN VERBOSE
SELECT count(id), datediff(c3 + '1 12:59:10', c2 ) FROM time_tbl group by datediff(c3 + '1 12:59:10', c2 );
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=12)
   Output: (count(id)), (datediff((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), (c2)::timestamp without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), datediff((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), `c2`) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select datediff with group by (result)
--Testcase 2389:
SELECT count(id), datediff(c3 + '1 12:59:10', c2 ) FROM time_tbl group by datediff(c3 + '1 12:59:10', c2 );
 count | datediff 
-------+----------
     1 |        3
     1 |        5
     1 |       -3
     1 |       -7
     1 |      -21
(5 rows)

-- select datediff with group by index (result)
--Testcase 2390:
SELECT id, datediff(c3 + '1 12:59:10', c2 ) FROM time_tbl group by 2,1;
 id | datediff 
----+----------
  0 |        3
  1 |        5
  2 |       -3
  3 |       -7
  4 |      -21
(5 rows)

-- select datediff with group by index (result)
--Testcase 2391:
SELECT id, datediff(c3 + '1 12:59:10', c2 ) FROM time_tbl group by 1,2;
 id | datediff 
----+----------
  0 |        3
  1 |        5
  2 |       -3
  3 |       -7
  4 |      -21
(5 rows)

-- select datediff with group by having (explain)
--Testcase 2392:
EXPLAIN VERBOSE
SELECT count(id), datediff(c3 + '1 12:59:10', c2 ), c2, c3 FROM time_tbl group by datediff(c3 + '1 12:59:10', c2 ), id,c2,c3 HAVING datediff(c3 + '1 12:59:10', c2 ) > 0;
                                                                                                                                                               QUERY PLAN                                                                                                                                                               
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=28)
   Output: (count(id)), (datediff((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), (c2)::timestamp without time zone)), c2, c3, id
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), datediff((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), `c2`), `c2`, `c3`, `id` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 5, 3, 4 HAVING ((datediff((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), `c2`) > 0))
(5 rows)

-- select datediff with group by having (result)
--Testcase 2393:
SELECT count(id), datediff(c3 + '1 12:59:10', c2 ), c2, c3 FROM time_tbl group by datediff(c3 + '1 12:59:10', c2 ), id,c2,c3 HAVING datediff(c3 + '1 12:59:10', c2 ) > 0;
 count | datediff |     c2     |         c3          
-------+----------+------------+---------------------
     1 |        3 | 2021-01-02 | 2021-01-03 12:10:30
     1 |        5 | 2021-01-01 | 2021-01-04 23:12:13
(2 rows)

-- select datediff with group by index having (result)
--Testcase 2394:
SELECT id, datediff(c3 + '1 12:59:10', c2 ), c2, c3 FROM time_tbl group by 4,3,2,1 HAVING datediff(c3 + '1 12:59:10', c2 ) > 0;
 id | datediff |     c2     |         c3          
----+----------+------------+---------------------
  0 |        3 | 2021-01-02 | 2021-01-03 12:10:30
  1 |        5 | 2021-01-01 | 2021-01-04 23:12:13
(2 rows)

-- select datediff with group by index having (result)
--Testcase 2395:
SELECT id, datediff(c3 + '1 12:59:10', c2 ), c2, c3 FROM time_tbl group by 1,2,3,4 HAVING datediff(c3 + '1 12:59:10', c2 ) > 0;
 id | datediff |     c2     |         c3          
----+----------+------------+---------------------
  0 |        3 | 2021-01-02 | 2021-01-03 12:10:30
  1 |        5 | 2021-01-01 | 2021-01-04 23:12:13
(2 rows)

-- select datediff and as
--Testcase 2396:
SELECT datediff(c2, '2007-12-31'::date) as datediff1 FROM time_tbl;
ERROR:  stub datediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function datediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- YEARWEEK()
-- select yearweek (stub function, explain)
--Testcase 2397:
EXPLAIN VERBOSE
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=16)
   Output: yearweek(c3), yearweek((c2)::timestamp without time zone), yearweek(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), yearweek('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select yearweek (stub function, result)
--Testcase 2398:
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub yearweek(timestamp) is called
CONTEXT:  PL/pgSQL function yearweek(timestamp without time zone) line 3 at RAISE
-- select yearweek (stub function, not pushdown constraints, explain)
--Testcase 2399:
EXPLAIN VERBOSE
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: yearweek(c3), yearweek((c2)::timestamp without time zone), yearweek(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), yearweek('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select yearweek (stub function, not pushdown constraints, result)
--Testcase 2400:
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub yearweek(timestamp) is called
CONTEXT:  PL/pgSQL function yearweek(timestamp without time zone) line 3 at RAISE
-- select yearweek (stub function, pushdown constraints, explain)
--Testcase 2401:
EXPLAIN VERBOSE
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=16)
   Output: yearweek(c3), yearweek((c2)::timestamp without time zone), yearweek(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), yearweek('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select yearweek (stub function, pushdown constraints, result)
--Testcase 2402:
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub yearweek(timestamp) is called
CONTEXT:  PL/pgSQL function yearweek(timestamp without time zone) line 3 at RAISE
-- select yearweek (stub function, yearweek in constraints, explain)
--Testcase 2403:
EXPLAIN VERBOSE
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE yearweek(c3) != yearweek('2000-01-01'::timestamp);
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..229.05 rows=2264 width=16)
   Output: yearweek(c3), yearweek((c2)::timestamp without time zone), yearweek(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), yearweek('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((yearweek(`c3`) <> yearweek('2000-01-01 00:00:00')))
(4 rows)

-- select yearweek (stub function, yearweek in constraints, result)
--Testcase 2404:
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE yearweek(c3) != yearweek('2000-01-01'::timestamp);
ERROR:  stub yearweek(timestamp) is called
CONTEXT:  PL/pgSQL function yearweek(timestamp without time zone) line 3 at RAISE
-- select yearweek (stub function, yearweek in constraints, explain)
--Testcase 2405:
EXPLAIN VERBOSE
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE yearweek('2021-01-01 12:00:00'::timestamp) > '1';
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=16)
   Output: yearweek(c3), yearweek((c2)::timestamp without time zone), yearweek(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), yearweek('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((yearweek('2021-01-01 12:00:00') > 1))
(4 rows)

-- select yearweek (stub function, yearweek in constraints, result)
--Testcase 2406:
SELECT yearweek(c3), yearweek(c2), yearweek(date_sub(c3, '1 12:59:10')), yearweek('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE yearweek('2021-01-01 12:00:00'::timestamp) > '1';
ERROR:  stub yearweek(timestamp) is called
CONTEXT:  PL/pgSQL function yearweek(timestamp without time zone) line 3 at RAISE
-- select yearweek with agg (pushdown, explain)
--Testcase 2407:
EXPLAIN VERBOSE
SELECT max(c3), yearweek(max(c3)) FROM time_tbl;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (yearweek(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), yearweek(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select yearweek as nest function with agg (pushdown, result)
--Testcase 2408:
SELECT max(c3), yearweek(max(c3)) FROM time_tbl;
         max         | yearweek 
---------------------+----------
 2021-01-07 00:59:59 |   202101
(1 row)

-- select yearweek with non pushdown func and explicit constant (explain)
--Testcase 2409:
EXPLAIN VERBOSE
SELECT yearweek(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: yearweek(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select yearweek with non pushdown func and explicit constant (result)
--Testcase 2410:
SELECT yearweek(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select yearweek with order by (explain)
--Testcase 2411:
EXPLAIN VERBOSE
SELECT id, yearweek(c3 + '1 12:59:10') FROM time_tbl order by yearweek(c3 + '1 12:59:10');
                                                                                                                                          QUERY PLAN                                                                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, yearweek((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY yearweek((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, yearweek((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select yearweek with order by (result)
--Testcase 2412:
SELECT id, yearweek(c3 + '1 12:59:10') FROM time_tbl order by yearweek(c3 + '1 12:59:10');
ERROR:  stub yearweek(timestamp) is called
CONTEXT:  PL/pgSQL function yearweek(timestamp without time zone) line 3 at RAISE
-- select yearweek with order by index (result)
--Testcase 2413:
SELECT id, yearweek(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub yearweek(timestamp) is called
CONTEXT:  PL/pgSQL function yearweek(timestamp without time zone) line 3 at RAISE
-- select yearweek with order by index (result)
--Testcase 2414:
SELECT id, yearweek(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub yearweek(timestamp) is called
CONTEXT:  PL/pgSQL function yearweek(timestamp without time zone) line 3 at RAISE
-- select yearweek with group by (explain)
--Testcase 2415:
EXPLAIN VERBOSE
SELECT max(c3), yearweek(c3 + '1 12:59:10') FROM time_tbl group by yearweek(c3 + '1 12:59:10');
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (yearweek((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), yearweek((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select yearweek with group by (result)
--Testcase 2416:
SELECT max(c3), yearweek(c3 + '1 12:59:10') FROM time_tbl group by yearweek(c3 + '1 12:59:10');
         max         | yearweek 
---------------------+----------
 2021-01-07 00:59:59 |   202101
(1 row)

-- select yearweek with group by index (result)
--Testcase 2417:
SELECT id, yearweek(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | yearweek 
----+----------
  0 |   202101
  1 |   202101
  2 |   202101
  3 |   202101
  4 |   202101
(5 rows)

-- select yearweek with group by index (result)
--Testcase 2418:
SELECT id, yearweek(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | yearweek 
----+----------
  0 |   202101
  1 |   202101
  2 |   202101
  3 |   202101
  4 |   202101
(5 rows)

-- select yearweek with group by having (explain)
--Testcase 2419:
EXPLAIN VERBOSE
SELECT max(c3), yearweek(c3 + '1 12:59:10') FROM time_tbl group by yearweek(c3 + '1 12:59:10'), c3 HAVING yearweek(c3 + '1 12:59:10') > 201010;
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (yearweek((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), yearweek((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((yearweek((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) > 201010))
(5 rows)

-- select yearweek with group by having (result)
--Testcase 2420:
SELECT max(c3), yearweek(c3 + '1 12:59:10') FROM time_tbl group by yearweek(c3 + '1 12:59:10'), c3 HAVING yearweek(c3 + '1 12:59:10') > 201010;
         max         | yearweek 
---------------------+----------
 2021-01-03 12:10:30 |   202101
 2021-01-04 23:12:13 |   202101
 2021-01-05 11:12:12 |   202101
 2021-01-06 16:00:00 |   202101
 2021-01-07 00:59:59 |   202101
(5 rows)

-- select yearweek with group by index having (result)
--Testcase 2421:
SELECT id, yearweek(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING yearweek(c3 + '1 12:59:10') > 201010;
 id | yearweek |         c3          
----+----------+---------------------
  0 |   202101 | 2021-01-03 12:10:30
  1 |   202101 | 2021-01-04 23:12:13
  2 |   202101 | 2021-01-05 11:12:12
  3 |   202101 | 2021-01-06 16:00:00
  4 |   202101 | 2021-01-07 00:59:59
(5 rows)

-- select yearweek with group by index having (result)
--Testcase 2422:
SELECT id, yearweek(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING yearweek(c3 + '1 12:59:10') > 201010;
 id | yearweek |         c3          
----+----------+---------------------
  0 |   202101 | 2021-01-03 12:10:30
  1 |   202101 | 2021-01-04 23:12:13
  2 |   202101 | 2021-01-05 11:12:12
  3 |   202101 | 2021-01-06 16:00:00
  4 |   202101 | 2021-01-07 00:59:59
(5 rows)

-- select yearweek and as
--Testcase 2423:
SELECT yearweek(date_sub(c3, '1 12:59:10')) as yearweek1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- YEAR()
-- select year (stub function, explain)
--Testcase 2424:
EXPLAIN VERBOSE
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=16)
   Output: year(c3), year((c2)::timestamp without time zone), year(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), year('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select year (stub function, result)
--Testcase 2425:
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub year(timestamp) is called
CONTEXT:  PL/pgSQL function year(timestamp without time zone) line 3 at RAISE
-- select year (stub function, not pushdown constraints, explain)
--Testcase 2426:
EXPLAIN VERBOSE
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: year(c3), year((c2)::timestamp without time zone), year(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), year('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select year (stub function, not pushdown constraints, result)
--Testcase 2427:
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub year(timestamp) is called
CONTEXT:  PL/pgSQL function year(timestamp without time zone) line 3 at RAISE
-- select year (stub function, pushdown constraints, explain)
--Testcase 2428:
EXPLAIN VERBOSE
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=16)
   Output: year(c3), year((c2)::timestamp without time zone), year(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), year('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select year (stub function, pushdown constraints, result)
--Testcase 2429:
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub year(timestamp) is called
CONTEXT:  PL/pgSQL function year(timestamp without time zone) line 3 at RAISE
-- select year (stub function, year in constraints, explain)
--Testcase 2430:
EXPLAIN VERBOSE
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE year(c3) != year('2000-01-01'::timestamp);
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..229.05 rows=2264 width=16)
   Output: year(c3), year((c2)::timestamp without time zone), year(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), year('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((year(`c3`) <> year('2000-01-01 00:00:00')))
(4 rows)

-- select year (stub function, year in constraints, result)
--Testcase 2431:
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE year(c3) != year('2000-01-01'::timestamp);
ERROR:  stub year(timestamp) is called
CONTEXT:  PL/pgSQL function year(timestamp without time zone) line 3 at RAISE
-- select year (stub function, year in constraints, explain)
--Testcase 2432:
EXPLAIN VERBOSE
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE year('2021-01-01 12:00:00'::timestamp) > '1';
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=16)
   Output: year(c3), year((c2)::timestamp without time zone), year(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), year('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((year('2021-01-01 12:00:00') > 1))
(4 rows)

-- select year (stub function, year in constraints, result)
--Testcase 2433:
SELECT year(c3), year(c2), year(date_sub(c3, '1 12:59:10')), year('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE year('2021-01-01 12:00:00'::timestamp) > '1';
ERROR:  stub year(timestamp) is called
CONTEXT:  PL/pgSQL function year(timestamp without time zone) line 3 at RAISE
-- select year with agg (pushdown, explain)
--Testcase 2434:
EXPLAIN VERBOSE
SELECT max(c3), year(max(c3)) FROM time_tbl;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (year(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), year(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select year as nest function with agg (pushdown, result)
--Testcase 2435:
SELECT max(c3), year(max(c3)) FROM time_tbl;
         max         | year 
---------------------+------
 2021-01-07 00:59:59 | 2021
(1 row)

-- select year with non pushdown func and explicit constant (explain)
--Testcase 2436:
EXPLAIN VERBOSE
SELECT year(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: year(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select year with non pushdown func and explicit constant (result)
--Testcase 2437:
SELECT year(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select year with order by (explain)
--Testcase 2438:
EXPLAIN VERBOSE
SELECT id, year(c3 + '1 12:59:10') FROM time_tbl order by year(c3 + '1 12:59:10');
                                                                                                                                      QUERY PLAN                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, year((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY year((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, year((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select year with order by (result)
--Testcase 2439:
SELECT id, year(c3 + '1 12:59:10') FROM time_tbl order by year(c3 + '1 12:59:10');
ERROR:  stub year(timestamp) is called
CONTEXT:  PL/pgSQL function year(timestamp without time zone) line 3 at RAISE
-- select year with order by index (result)
--Testcase 2440:
SELECT id, year(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub year(timestamp) is called
CONTEXT:  PL/pgSQL function year(timestamp without time zone) line 3 at RAISE
-- select year with order by index (result)
--Testcase 2441:
SELECT id, year(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub year(timestamp) is called
CONTEXT:  PL/pgSQL function year(timestamp without time zone) line 3 at RAISE
-- select year with group by (explain)
--Testcase 2442:
EXPLAIN VERBOSE
SELECT max(c3), year(c3 + '1 12:59:10') FROM time_tbl group by year(c3 + '1 12:59:10');
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (year((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), year((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select year with group by (result)
--Testcase 2443:
SELECT max(c3), year(c3 + '1 12:59:10') FROM time_tbl group by year(c3 + '1 12:59:10');
         max         | year 
---------------------+------
 2021-01-07 00:59:59 | 2021
(1 row)

-- select year with group by index (result)
--Testcase 2444:
SELECT id, year(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | year 
----+------
  0 | 2021
  1 | 2021
  2 | 2021
  3 | 2021
  4 | 2021
(5 rows)

-- select year with group by index (result)
--Testcase 2445:
SELECT id, year(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | year 
----+------
  0 | 2021
  1 | 2021
  2 | 2021
  3 | 2021
  4 | 2021
(5 rows)

-- select year with group by having (explain)
--Testcase 2446:
EXPLAIN VERBOSE
SELECT max(c3), year(c3 + '1 12:59:10') FROM time_tbl group by year(c3 + '1 12:59:10'), c3 HAVING year(c3 + '1 12:59:10') > 2000;
                                                                                                                                            QUERY PLAN                                                                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (year((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), year((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((year((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) > 2000))
(5 rows)

-- select year with group by having (result)
--Testcase 2447:
SELECT max(c3), year(c3 + '1 12:59:10') FROM time_tbl group by year(c3 + '1 12:59:10'), c3 HAVING year(c3 + '1 12:59:10') > 2000;
         max         | year 
---------------------+------
 2021-01-03 12:10:30 | 2021
 2021-01-04 23:12:13 | 2021
 2021-01-05 11:12:12 | 2021
 2021-01-06 16:00:00 | 2021
 2021-01-07 00:59:59 | 2021
(5 rows)

-- select year with group by index having (result)
--Testcase 2448:
SELECT id, year(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING year(c3 + '1 12:59:10') > 2000;
 id | year |         c3          
----+------+---------------------
  0 | 2021 | 2021-01-03 12:10:30
  1 | 2021 | 2021-01-04 23:12:13
  2 | 2021 | 2021-01-05 11:12:12
  3 | 2021 | 2021-01-06 16:00:00
  4 | 2021 | 2021-01-07 00:59:59
(5 rows)

-- select year with group by index having (result)
--Testcase 2449:
SELECT id, year(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING year(c3 + '1 12:59:10') > 2000;
 id | year |         c3          
----+------+---------------------
  0 | 2021 | 2021-01-03 12:10:30
  1 | 2021 | 2021-01-04 23:12:13
  2 | 2021 | 2021-01-05 11:12:12
  3 | 2021 | 2021-01-06 16:00:00
  4 | 2021 | 2021-01-07 00:59:59
(5 rows)

-- select year and as
--Testcase 2450:
SELECT year(date_sub(c3, '1 12:59:10')) as year1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- WEEKFORYEAR()
-- select weekofyear (stub function, explain)
--Testcase 2451:
EXPLAIN VERBOSE
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=16)
   Output: weekofyear(c3), weekofyear((c2)::timestamp without time zone), weekofyear(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekofyear('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select weekofyear (stub function, result)
--Testcase 2452:
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub weekofyear(timestamp) is called
CONTEXT:  PL/pgSQL function weekofyear(timestamp without time zone) line 3 at RAISE
-- select weekofyear (stub function, not pushdown constraints, explain)
--Testcase 2453:
EXPLAIN VERBOSE
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: weekofyear(c3), weekofyear((c2)::timestamp without time zone), weekofyear(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekofyear('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select weekofyear (stub function, not pushdown constraints, result)
--Testcase 2454:
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub weekofyear(timestamp) is called
CONTEXT:  PL/pgSQL function weekofyear(timestamp without time zone) line 3 at RAISE
-- select weekofyear (stub function, pushdown constraints, explain)
--Testcase 2455:
EXPLAIN VERBOSE
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=16)
   Output: weekofyear(c3), weekofyear((c2)::timestamp without time zone), weekofyear(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekofyear('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select weekofyear (stub function, pushdown constraints, result)
--Testcase 2456:
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub weekofyear(timestamp) is called
CONTEXT:  PL/pgSQL function weekofyear(timestamp without time zone) line 3 at RAISE
-- select weekofyear (stub function, weekofyear in constraints, explain)
--Testcase 2457:
EXPLAIN VERBOSE
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE weekofyear(c3) != weekofyear('2000-01-01'::timestamp);
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..229.05 rows=2264 width=16)
   Output: weekofyear(c3), weekofyear((c2)::timestamp without time zone), weekofyear(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekofyear('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((weekofyear(`c3`) <> weekofyear('2000-01-01 00:00:00')))
(4 rows)

-- select weekofyear (stub function, weekofyear in constraints, result)
--Testcase 2458:
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE weekofyear(c3) != weekofyear('2000-01-01'::timestamp);
ERROR:  stub weekofyear(timestamp) is called
CONTEXT:  PL/pgSQL function weekofyear(timestamp without time zone) line 3 at RAISE
-- select weekofyear (stub function, weekofyear in constraints, explain)
--Testcase 2459:
EXPLAIN VERBOSE
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE weekofyear('2021-01-01 12:00:00'::timestamp) > '1';
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=16)
   Output: weekofyear(c3), weekofyear((c2)::timestamp without time zone), weekofyear(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekofyear('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((weekofyear('2021-01-01 12:00:00') > 1))
(4 rows)

-- select weekofyear (stub function, weekofyear in constraints, result)
--Testcase 2460:
SELECT weekofyear(c3), weekofyear(c2), weekofyear(date_sub(c3, '1 12:59:10')), weekofyear('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE weekofyear('2021-01-01 12:00:00'::timestamp) > '1';
ERROR:  stub weekofyear(timestamp) is called
CONTEXT:  PL/pgSQL function weekofyear(timestamp without time zone) line 3 at RAISE
-- select weekofyear with agg (pushdown, explain)
--Testcase 2461:
EXPLAIN VERBOSE
SELECT max(c3), weekofyear(max(c3)) FROM time_tbl;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (weekofyear(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), weekofyear(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select weekofyear as nest function with agg (pushdown, result)
--Testcase 2462:
SELECT max(c3), weekofyear(max(c3)) FROM time_tbl;
         max         | weekofyear 
---------------------+------------
 2021-01-07 00:59:59 |          1
(1 row)

-- select weekofyear with non pushdown func and explicit constant (explain)
--Testcase 2463:
EXPLAIN VERBOSE
SELECT weekofyear(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: weekofyear(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select weekofyear with non pushdown func and explicit constant (result)
--Testcase 2464:
SELECT weekofyear(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select weekofyear with order by (explain)
--Testcase 2465:
EXPLAIN VERBOSE
SELECT id, weekofyear(c3 + '1 12:59:10') FROM time_tbl order by weekofyear(c3 + '1 12:59:10');
                                                                                                                                            QUERY PLAN                                                                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, weekofyear((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY weekofyear((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, weekofyear((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select weekofyear with order by (result)
--Testcase 2466:
SELECT id, weekofyear(c3 + '1 12:59:10') FROM time_tbl order by weekofyear(c3 + '1 12:59:10');
ERROR:  stub weekofyear(timestamp) is called
CONTEXT:  PL/pgSQL function weekofyear(timestamp without time zone) line 3 at RAISE
-- select weekofyear with order by index (result)
--Testcase 2467:
SELECT id, weekofyear(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub weekofyear(timestamp) is called
CONTEXT:  PL/pgSQL function weekofyear(timestamp without time zone) line 3 at RAISE
-- select weekofyear with order by index (result)
--Testcase 2468:
SELECT id, weekofyear(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub weekofyear(timestamp) is called
CONTEXT:  PL/pgSQL function weekofyear(timestamp without time zone) line 3 at RAISE
-- select weekofyear with group by (explain)
--Testcase 2469:
EXPLAIN VERBOSE
SELECT max(c3), weekofyear(c3 + '1 12:59:10') FROM time_tbl group by weekofyear(c3 + '1 12:59:10');
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (weekofyear((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), weekofyear((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select weekofyear with group by (result)
--Testcase 2470:
SELECT max(c3), weekofyear(c3 + '1 12:59:10') FROM time_tbl group by weekofyear(c3 + '1 12:59:10');
         max         | weekofyear 
---------------------+------------
 2021-01-07 00:59:59 |          1
(1 row)

-- select weekofyear with group by index (result)
--Testcase 2471:
SELECT id, weekofyear(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | weekofyear 
----+------------
  0 |          1
  1 |          1
  2 |          1
  3 |          1
  4 |          1
(5 rows)

-- select weekofyear with group by index (result)
--Testcase 2472:
SELECT id, weekofyear(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | weekofyear 
----+------------
  0 |          1
  1 |          1
  2 |          1
  3 |          1
  4 |          1
(5 rows)

-- select weekofyear with group by having (explain)
--Testcase 2473:
EXPLAIN VERBOSE
SELECT max(c3), weekofyear(c3 + '1 12:59:10') FROM time_tbl group by weekofyear(c3 + '1 12:59:10'), c3 HAVING weekofyear(c3 + '1 12:59:10') > 0;
                                                                                                                                                 QUERY PLAN                                                                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (weekofyear((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), weekofyear((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((weekofyear((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) > 0))
(5 rows)

-- select weekofyear with group by having (result)
--Testcase 2474:
SELECT max(c3), weekofyear(c3 + '1 12:59:10') FROM time_tbl group by weekofyear(c3 + '1 12:59:10'), c3 HAVING weekofyear(c3 + '1 12:59:10') > 0;
         max         | weekofyear 
---------------------+------------
 2021-01-03 12:10:30 |          1
 2021-01-04 23:12:13 |          1
 2021-01-05 11:12:12 |          1
 2021-01-06 16:00:00 |          1
 2021-01-07 00:59:59 |          1
(5 rows)

-- select weekofyear with group by index having (result)
--Testcase 2475:
SELECT id, weekofyear(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING weekofyear(c3 + '1 12:59:10') > 0;
 id | weekofyear |         c3          
----+------------+---------------------
  0 |          1 | 2021-01-03 12:10:30
  1 |          1 | 2021-01-04 23:12:13
  2 |          1 | 2021-01-05 11:12:12
  3 |          1 | 2021-01-06 16:00:00
  4 |          1 | 2021-01-07 00:59:59
(5 rows)

-- select weekofyear with group by index having (result)
--Testcase 2476:
SELECT id, weekofyear(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING weekofyear(c3 + '1 12:59:10') > 0;
 id | weekofyear |         c3          
----+------------+---------------------
  0 |          1 | 2021-01-03 12:10:30
  1 |          1 | 2021-01-04 23:12:13
  2 |          1 | 2021-01-05 11:12:12
  3 |          1 | 2021-01-06 16:00:00
  4 |          1 | 2021-01-07 00:59:59
(5 rows)

-- select weekofyear and as
--Testcase 2477:
SELECT weekofyear(date_sub(c3, '1 12:59:10')) as weekofyear1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- WEEKDAY()
-- select weekday (stub function, explain)
--Testcase 2478:
EXPLAIN VERBOSE
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=16)
   Output: weekday(c3), weekday((c2)::timestamp without time zone), weekday(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekday('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select weekday (stub function, result)
--Testcase 2479:
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub weekday(timestamp) is called
CONTEXT:  PL/pgSQL function weekday(timestamp without time zone) line 3 at RAISE
-- select weekday (stub function, not pushdown constraints, explain)
--Testcase 2480:
EXPLAIN VERBOSE
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: weekday(c3), weekday((c2)::timestamp without time zone), weekday(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekday('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select weekday (stub function, not pushdown constraints, result)
--Testcase 2481:
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub weekday(timestamp) is called
CONTEXT:  PL/pgSQL function weekday(timestamp without time zone) line 3 at RAISE
-- select weekday (stub function, pushdown constraints, explain)
--Testcase 2482:
EXPLAIN VERBOSE
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=16)
   Output: weekday(c3), weekday((c2)::timestamp without time zone), weekday(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekday('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select weekday (stub function, pushdown constraints, result)
--Testcase 2483:
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub weekday(timestamp) is called
CONTEXT:  PL/pgSQL function weekday(timestamp without time zone) line 3 at RAISE
-- select weekday (stub function, weekday in constraints, explain)
--Testcase 2484:
EXPLAIN VERBOSE
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE weekday(c3) != weekday('2000-01-01'::timestamp);
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..229.05 rows=2264 width=16)
   Output: weekday(c3), weekday((c2)::timestamp without time zone), weekday(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekday('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((weekday(`c3`) <> weekday('2000-01-01 00:00:00')))
(4 rows)

-- select weekday (stub function, weekday in constraints, result)
--Testcase 2485:
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE weekday(c3) != weekday('2000-01-01'::timestamp);
ERROR:  stub weekday(timestamp) is called
CONTEXT:  PL/pgSQL function weekday(timestamp without time zone) line 3 at RAISE
-- select weekday (stub function, weekday in constraints, explain)
--Testcase 2486:
EXPLAIN VERBOSE
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE weekday('2021-01-01 12:00:00'::timestamp) > '1';
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=16)
   Output: weekday(c3), weekday((c2)::timestamp without time zone), weekday(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), weekday('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((weekday('2021-01-01 12:00:00') > 1))
(4 rows)

-- select weekday (stub function, weekday in constraints, result)
--Testcase 2487:
SELECT weekday(c3), weekday(c2), weekday(date_sub(c3, '1 12:59:10')), weekday('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE weekday('2021-01-01 12:00:00'::timestamp) > '1';
ERROR:  stub weekday(timestamp) is called
CONTEXT:  PL/pgSQL function weekday(timestamp without time zone) line 3 at RAISE
-- select weekday with agg (pushdown, explain)
--Testcase 2488:
EXPLAIN VERBOSE
SELECT max(c3), weekday(max(c3)) FROM time_tbl;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (weekday(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), weekday(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select weekday as nest function with agg (pushdown, result)
--Testcase 2489:
SELECT max(c3), weekday(max(c3)) FROM time_tbl;
         max         | weekday 
---------------------+---------
 2021-01-07 00:59:59 |       3
(1 row)

-- select weekday with non pushdown func and explicit constant (explain)
--Testcase 2490:
EXPLAIN VERBOSE
SELECT weekday(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: weekday(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select weekday with non pushdown func and explicit constant (result)
--Testcase 2491:
SELECT weekday(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select weekday with order by (explain)
--Testcase 2492:
EXPLAIN VERBOSE
SELECT id, weekday(c3 + '1 12:59:10') FROM time_tbl order by weekday(c3 + '1 12:59:10');
                                                                                                                                         QUERY PLAN                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, weekday((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY weekday((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, weekday((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select weekday with order by (result)
--Testcase 2493:
SELECT id, weekday(c3 + '1 12:59:10') FROM time_tbl order by weekday(c3 + '1 12:59:10');
ERROR:  stub weekday(timestamp) is called
CONTEXT:  PL/pgSQL function weekday(timestamp without time zone) line 3 at RAISE
-- select weekday with order by index (result)
--Testcase 2494:
SELECT id, weekday(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub weekday(timestamp) is called
CONTEXT:  PL/pgSQL function weekday(timestamp without time zone) line 3 at RAISE
-- select weekday with order by index (result)
--Testcase 2495:
SELECT id, weekday(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub weekday(timestamp) is called
CONTEXT:  PL/pgSQL function weekday(timestamp without time zone) line 3 at RAISE
-- select weekday with group by (explain)
--Testcase 2496:
EXPLAIN VERBOSE
SELECT max(c3), weekday(c3 + '1 12:59:10') FROM time_tbl group by weekday(c3 + '1 12:59:10');
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (weekday((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), weekday((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select weekday with group by (result)
--Testcase 2497:
SELECT max(c3), weekday(c3 + '1 12:59:10') FROM time_tbl group by weekday(c3 + '1 12:59:10');
         max         | weekday 
---------------------+---------
 2021-01-03 12:10:30 |       1
 2021-01-04 23:12:13 |       2
 2021-01-05 11:12:12 |       3
 2021-01-07 00:59:59 |       4
(4 rows)

-- select weekday with group by index (result)
--Testcase 2498:
SELECT id, weekday(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | weekday 
----+---------
  0 |       1
  1 |       2
  2 |       3
  3 |       4
  4 |       4
(5 rows)

-- select weekday with group by index (result)
--Testcase 2499:
SELECT id, weekday(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | weekday 
----+---------
  0 |       1
  1 |       2
  2 |       3
  3 |       4
  4 |       4
(5 rows)

-- select weekday with group by having (explain)
--Testcase 2500:
EXPLAIN VERBOSE
SELECT max(c3), weekday(c3 + '1 12:59:10') FROM time_tbl group by weekday(c3 + '1 12:59:10'), c3 HAVING weekday(c3 + '1 12:59:10') > 0;
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (weekday((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), weekday((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((weekday((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) > 0))
(5 rows)

-- select weekday with group by having (result)
--Testcase 2501:
SELECT max(c3), weekday(c3 + '1 12:59:10') FROM time_tbl group by weekday(c3 + '1 12:59:10'), c3 HAVING weekday(c3 + '1 12:59:10') > 0;
         max         | weekday 
---------------------+---------
 2021-01-03 12:10:30 |       1
 2021-01-04 23:12:13 |       2
 2021-01-05 11:12:12 |       3
 2021-01-06 16:00:00 |       4
 2021-01-07 00:59:59 |       4
(5 rows)

-- select weekday with group by index having (result)
--Testcase 2502:
SELECT id, weekday(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING weekday(c3 + '1 12:59:10') > 0;
 id | weekday |         c3          
----+---------+---------------------
  0 |       1 | 2021-01-03 12:10:30
  1 |       2 | 2021-01-04 23:12:13
  2 |       3 | 2021-01-05 11:12:12
  3 |       4 | 2021-01-06 16:00:00
  4 |       4 | 2021-01-07 00:59:59
(5 rows)

-- select weekday with group by index having (result)
--Testcase 2503:
SELECT id, weekday(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING weekday(c3 + '1 12:59:10') > 0;
 id | weekday |         c3          
----+---------+---------------------
  0 |       1 | 2021-01-03 12:10:30
  1 |       2 | 2021-01-04 23:12:13
  2 |       3 | 2021-01-05 11:12:12
  3 |       4 | 2021-01-06 16:00:00
  4 |       4 | 2021-01-07 00:59:59
(5 rows)

-- select weekday and as
--Testcase 2504:
SELECT weekday(date_sub(c3, '1 12:59:10')) as weekday1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- WEEK()
-- select week (stub function, explain)
--Testcase 2505:
EXPLAIN VERBOSE
SELECT id, week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl;
                                                                                                           QUERY PLAN                                                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..225.20 rows=2560 width=20)
   Output: id, week((c2)::timestamp without time zone, 7), week((c2)::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 7)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select week (stub function, result)
--Testcase 2506:
SELECT id, week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl;
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week (stub function, not pushdown constraints, explain)
--Testcase 2507:
EXPLAIN VERBOSE
SELECT week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                         QUERY PLAN                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..154.40 rows=15 width=16)
   Output: week((c2)::timestamp without time zone, 7), week((c2)::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 7)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select week (stub function, not pushdown constraints, result)
--Testcase 2508:
SELECT week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week (stub function, pushdown constraints, explain)
--Testcase 2509:
EXPLAIN VERBOSE
SELECT id, week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl WHERE id != 0;
                                                                                                           QUERY PLAN                                                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..231.15 rows=2547 width=20)
   Output: id, week((c2)::timestamp without time zone, 7), week((c2)::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 7)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select week (stub function, pushdown constraints, result)
--Testcase 2510:
SELECT id, week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl WHERE id != 0;
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week (stub function, week in constraints, explain)
--Testcase 2511:
EXPLAIN VERBOSE
SELECT id, week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl WHERE week(c2, 7) != week('2021-01-02'::timestamp, 1);
                                                                                                           QUERY PLAN                                                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..250.34 rows=2547 width=20)
   Output: id, week((c2)::timestamp without time zone, 7), week((c2)::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 7)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((week(`c2`, 7) <> week('2021-01-02 00:00:00', 1)))
(4 rows)

-- select week (stub function, week in constraints, result)
--Testcase 2512:
SELECT id, week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl WHERE week(c2, 7) != week('2021-01-02'::timestamp, 1);
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week (stub function, week in constraints, explain)
--Testcase 2513:
EXPLAIN VERBOSE
SELECT id, week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl WHERE week('2021-01-02'::date, 7) > week('2021-01-02'::timestamp, 1);
                                                                                                           QUERY PLAN                                                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..184.66 rows=853 width=20)
   Output: id, week((c2)::timestamp without time zone, 7), week((c2)::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 1), week('2021-01-02 00:00:00'::timestamp without time zone, 7)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((week('2021-01-02 00:00:00', 7) > week('2021-01-02 00:00:00', 1)))
(4 rows)

-- select week (stub function, week in constraints, result)
--Testcase 2514:
SELECT id, week(c2, 7), week(c2, 1), week('2021-01-02'::date, 1), week('2021-01-02'::date, 7) FROM time_tbl WHERE week('2021-01-02'::date, 7) > week('2021-01-02'::timestamp, 1);
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week as nest function with agg (pushdown, explain)
--Testcase 2515:
EXPLAIN VERBOSE
SELECT max(id), week('2021-01-02'::date, max(id)) FROM time_tbl;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
   Output: (max(id)), (week('2021-01-02 00:00:00'::timestamp without time zone, max(id)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`id`), week('2021-01-02 00:00:00', max(`id`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select week as nest function with agg (pushdown, result)
--Testcase 2516:
SELECT max(id), week('2021-01-02'::date, max(id)) FROM time_tbl;
 max | week 
-----+------
   4 |    0
(1 row)

-- select week as nest with stub (pushdown, explain)
--Testcase 2517:
EXPLAIN VERBOSE
SELECT id, week(makedate(2019, id), 7) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=8)
   Output: id, week((makedate(2019, id))::timestamp without time zone, 7)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select week as nest with stub (pushdown, result)
--Testcase 2518:
SELECT id, week(makedate(2019, id), 7) FROM time_tbl;
ERROR:  stub makedate(integer, integer) is called
CONTEXT:  PL/pgSQL function makedate(integer,integer) line 3 at RAISE
-- select week with non pushdown func and explicit constant (explain)
--Testcase 2519:
EXPLAIN VERBOSE
SELECT week('2021-01-02'::date, 1), pi(), 4.1 FROM time_tbl;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=44)
   Output: week('2021-01-02 00:00:00'::timestamp without time zone, 1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select week with non pushdown func and explicit constant (result)
--Testcase 2520:
SELECT week('2021-01-02'::date, 1), pi(), 4.1 FROM time_tbl;
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week with order by (explain)
--Testcase 2521:
EXPLAIN VERBOSE
SELECT id, week(c2, id + 5) FROM time_tbl order by id,week(c2, id + 5);
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=8)
   Output: id, week((c2)::timestamp without time zone, (id + 5))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `id` IS NULL ASC, `id` ASC, week(`c2`, (`id` + 5)) IS NULL ASC, week(`c2`, (`id` + 5)) ASC
(4 rows)

-- select week with order by (result)
--Testcase 2522:
SELECT id, week(c2, id + 5) FROM time_tbl order by id,week(c2, id + 5);
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week with order by index (result)
--Testcase 2523:
SELECT id, week(c2, id + 5) FROM time_tbl order by 2,1;
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week with order by index (result)
--Testcase 2524:
SELECT id, week(c2, id + 5) FROM time_tbl order by 1,2;
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- select week with group by (explain)
--Testcase 2525:
EXPLAIN VERBOSE
SELECT id, week(c2, id + 5) FROM time_tbl group by id, week(c2, id + 5);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=256 width=8)
   Output: id, (week((c2)::timestamp without time zone, (id + 5)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `id`, week(`c2`, (`id` + 5)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2
(5 rows)

-- select week with group by (result)
--Testcase 2526:
SELECT id, week(c2, id + 5) FROM time_tbl group by id, week(c2, id + 5);
 id | week 
----+------
  0 |    0
  1 |   53
  2 |    1
  3 |    2
  4 |    4
(5 rows)

-- select week with group by index (result)
--Testcase 2527:
SELECT id, week(c2, id + 5) FROM time_tbl group by 2,1;
 id | week 
----+------
  0 |    0
  1 |   53
  2 |    1
  3 |    2
  4 |    4
(5 rows)

-- select week with group by index (result)
--Testcase 2528:
SELECT id, week(c2, id + 5) FROM time_tbl group by 1,2;
 id | week 
----+------
  0 |    0
  1 |   53
  2 |    1
  3 |    2
  4 |    4
(5 rows)

-- select week with group by having (explain)
--Testcase 2529:
EXPLAIN VERBOSE
SELECT count(id), week(c2, id + 5) FROM time_tbl group by week(c2, id + 5), id,c2 HAVING week(c2, id + 5) = 0;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=20)
   Output: (count(id)), (week((c2)::timestamp without time zone, (id + 5))), id, c2
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), week(`c2`, (`id` + 5)), `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 4 HAVING ((week(`c2`, (`id` + 5)) = 0))
(5 rows)

-- select week with group by having (result)
--Testcase 2530:
SELECT count(id), week(c2, id + 5) FROM time_tbl group by week(c2, id + 5), id,c2 HAVING week(c2, id + 5) = 0;
 count | week 
-------+------
     1 |    0
(1 row)

-- select week with group by index having (result)
--Testcase 2531:
SELECT id, week(c2, id + 5), c2 FROM time_tbl group by 3,2,1 HAVING week(c2, id + 5) > 0;
 id | week |     c2     
----+------+------------
  1 |   53 | 2021-01-01
  2 |    1 | 2021-01-10
  3 |    2 | 2021-01-15
  4 |    4 | 2021-01-29
(4 rows)

-- select week with group by index having (result)
--Testcase 2532:
SELECT id, week(c2, id + 5), c2 FROM time_tbl group by 1,2,3 HAVING id > 1;
 id | week |     c2     
----+------+------------
  2 |    1 | 2021-01-10
  3 |    2 | 2021-01-15
  4 |    4 | 2021-01-29
(3 rows)

-- select week and as
--Testcase 2533:
SELECT week('2021-01-02'::date, 53) as week1 FROM time_tbl;
ERROR:  stub week(timestamp, integer) is called
CONTEXT:  PL/pgSQL function week(timestamp without time zone,integer) line 3 at RAISE
-- UTC_TIMESTAMP()
-- select utc_timestamp (stub function, explain)
--Testcase 2534:
EXPLAIN VERBOSE
SELECT utc_timestamp() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: utc_timestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_timestamp (stub function, not pushdown constraints, explain)
--Testcase 2535:
EXPLAIN VERBOSE
SELECT utc_timestamp() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: utc_timestamp()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select utc_timestamp (stub function, pushdown constraints, explain)
--Testcase 2536:
EXPLAIN VERBOSE
SELECT utc_timestamp() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=8)
   Output: utc_timestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select utc_timestamp (stub function, utc_timestamp in constraints, explain)
--Testcase 2537:
EXPLAIN VERBOSE
SELECT utc_timestamp() FROM time_tbl WHERE utc_timestamp() > '1997-10-14 00:00:00'::timestamp;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: utc_timestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((utc_timestamp() > '1997-10-14 00:00:00'))
(4 rows)

-- utc_timestamp in constrains (stub function, explain)
--Testcase 2538:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE utc_timestamp() > '1997-10-14 00:00:00'::timestamp;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((utc_timestamp() > '1997-10-14 00:00:00'))
(4 rows)

-- utc_timestamp in constrains (stub function, result)
--Testcase 2539:
SELECT c1 FROM time_tbl WHERE utc_timestamp() > '1997-10-14 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- utc_timestamp as parameter of addtime(stub function, explain)
--Testcase 2540:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(utc_timestamp(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..171.86 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(utc_timestamp(), '1 12:59:10.0') > '1997-10-14 00:00:00'))
(4 rows)

-- utc_timestamp as parameter of addtime(stub function, result)
--Testcase 2541:
SELECT c1 FROM time_tbl WHERE addtime(utc_timestamp(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select utc_timestamp and agg (pushdown, explain)
--Testcase 2542:
EXPLAIN VERBOSE
SELECT utc_timestamp(), sum(id) FROM time_tbl;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (utc_timestamp()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_timestamp(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select utc_timestamp and log2 (pushdown, explain)
--Testcase 2543:
EXPLAIN VERBOSE
SELECT utc_timestamp(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: utc_timestamp(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_timestamp with non pushdown func and explicit constant (explain)
--Testcase 2544:
EXPLAIN VERBOSE
SELECT utc_timestamp(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: utc_timestamp(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_timestamp with order by (explain)
--Testcase 2545:
EXPLAIN VERBOSE
SELECT utc_timestamp(), c1 FROM time_tbl ORDER BY c1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: (utc_timestamp()), c1
   Local server startup cost: 10
   Remote query: SELECT utc_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select utc_timestamp with order by index (explain)
--Testcase 2546:
EXPLAIN VERBOSE
SELECT utc_timestamp(), c1 FROM time_tbl ORDER BY 2;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: (utc_timestamp()), c1
   Local server startup cost: 10
   Remote query: SELECT utc_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- utc_timestamp constraints with order by (explain)
--Testcase 2547:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(utc_timestamp(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp ORDER BY c1;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(utc_timestamp(), '1 12:59:10.0') > '1997-10-14 00:00:00')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- utc_timestamp constraints with order by (result)
--Testcase 2548:
SELECT c1 FROM time_tbl WHERE addtime(utc_timestamp(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select utc_timestamp with group by (explain)
--Testcase 2549:
EXPLAIN VERBOSE
SELECT utc_timestamp(), c1 FROM time_tbl GROUP BY c1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (utc_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select utc_timestamp with group by index (explain)
--Testcase 2550:
EXPLAIN VERBOSE
SELECT utc_timestamp(), c1 FROM time_tbl GROUP BY 2;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (utc_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select utc_timestamp with group by having (explain)
--Testcase 2551:
EXPLAIN VERBOSE
SELECT utc_timestamp(), c1 FROM time_tbl GROUP BY utc_timestamp(),c1 HAVING utc_timestamp() > '1997-10-14 00:00:00'::timestamp;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (utc_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((utc_timestamp() > '1997-10-14 00:00:00'))
(5 rows)

-- select utc_timestamp with group by index having (explain)
--Testcase 2552:
EXPLAIN VERBOSE
SELECT utc_timestamp(), c1 FROM time_tbl GROUP BY 2,1 HAVING utc_timestamp() > '1997-10-14 00:00:00'::timestamp;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (utc_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((utc_timestamp() > '1997-10-14 00:00:00'))
(5 rows)

-- utc_timestamp constraints with group by (explain)
--Testcase 2553:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(utc_timestamp(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp GROUP BY c1;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(utc_timestamp(), '1 12:59:10.0') > '1997-10-14 00:00:00')) GROUP BY 1
(5 rows)

-- utc_timestamp constraints with group by (result)
--Testcase 2554:
SELECT c1 FROM time_tbl WHERE addtime(utc_timestamp(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select utc_timestamp and as
--Testcase 2555:
EXPLAIN VERBOSE
SELECT utc_timestamp() as utc_timestamp1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: utc_timestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- UTC_TIME()
-- select utc_time (stub function, explain)
--Testcase 2556:
EXPLAIN VERBOSE
SELECT utc_time() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: utc_time()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_time (stub function, not pushdown constraints, explain)
--Testcase 2557:
EXPLAIN VERBOSE
SELECT utc_time() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: utc_time()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select utc_time (stub function, pushdown constraints, explain)
--Testcase 2558:
EXPLAIN VERBOSE
SELECT utc_time() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=8)
   Output: utc_time()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select utc_time (stub function, utc_time in constraints, explain)
--Testcase 2559:
EXPLAIN VERBOSE
SELECT utc_time() FROM time_tbl WHERE utc_time() > '1997-10-14 00:00:00'::time;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: utc_time()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((utc_time() > '00:00:00'))
(4 rows)

-- utc_time in constrains (stub function, explain)
--Testcase 2560:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE utc_time() > '1997-10-14 00:00:00'::time;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((utc_time() > '00:00:00'))
(4 rows)

-- utc_time in constrains (stub function, result)
--Testcase 2561:
SELECT c1 FROM time_tbl WHERE utc_time() > '1997-10-14 00:00:00'::time;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- utc_time as parameter of second(stub function, explain)
--Testcase 2562:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE (60-second(utc_time())) >= 0;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.26 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE (((60 - second(utc_time())) >= 0))
(4 rows)

-- utc_time as parameter of second(stub function, result)
--Testcase 2563:
SELECT c1 FROM time_tbl WHERE (60-second(utc_time())) >= 0;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select utc_time and agg (pushdown, explain)
--Testcase 2564:
EXPLAIN VERBOSE
SELECT utc_time(), sum(id) FROM time_tbl;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (utc_time()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_time(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select utc_time and log2 (pushdown, explain)
--Testcase 2565:
EXPLAIN VERBOSE
SELECT utc_time(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: utc_time(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_time with non pushdown func and explicit constant (explain)
--Testcase 2566:
EXPLAIN VERBOSE
SELECT utc_time(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: utc_time(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_time with order by (explain)
--Testcase 2567:
EXPLAIN VERBOSE
SELECT utc_time(), c1 FROM time_tbl ORDER BY c1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: (utc_time()), c1
   Local server startup cost: 10
   Remote query: SELECT utc_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select utc_time with order by index (explain)
--Testcase 2568:
EXPLAIN VERBOSE
SELECT utc_time(), c1 FROM time_tbl ORDER BY 2;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: (utc_time()), c1
   Local server startup cost: 10
   Remote query: SELECT utc_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- utc_time constraints with order by (explain)
--Testcase 2569:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE (60-second(utc_time())) >= 0 ORDER BY c1;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE (((60 - second(utc_time())) >= 0)) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- utc_time constraints with order by (result)
--Testcase 2570:
SELECT c1 FROM time_tbl WHERE (60-second(utc_time())) >= 0 ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select utc_time with group by (explain)
--Testcase 2571:
EXPLAIN VERBOSE
SELECT utc_time(), c1 FROM time_tbl GROUP BY c1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (utc_time()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select utc_time with group by index (explain)
--Testcase 2572:
EXPLAIN VERBOSE
SELECT utc_time(), c1 FROM time_tbl GROUP BY 2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (utc_time()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select utc_time with group by having (explain)
--Testcase 2573:
EXPLAIN VERBOSE
SELECT utc_time(), c1 FROM time_tbl GROUP BY utc_time(),c1 HAVING utc_time() > '1997-10-14 00:00:00'::time;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (utc_time()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((utc_time() > '00:00:00'))
(5 rows)

-- select utc_time with group by index having (explain)
--Testcase 2574:
EXPLAIN VERBOSE
SELECT utc_time(), c1 FROM time_tbl GROUP BY 2,1 HAVING utc_time() > '1997-10-14 00:00:00'::time;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (utc_time()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_time(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((utc_time() > '00:00:00'))
(5 rows)

-- utc_time constraints with group by (explain)
--Testcase 2575:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE (60-second(utc_time())) >= 0 GROUP BY c1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE (((60 - second(utc_time())) >= 0)) GROUP BY 1
(5 rows)

-- utc_time constraints with group by (result)
--Testcase 2576:
SELECT c1 FROM time_tbl WHERE (60-second(utc_time())) >= 0 GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select utc_time and as
--Testcase 2577:
EXPLAIN VERBOSE
SELECT utc_time() as utc_time1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: utc_time()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- UTC_DATE()
-- select utc_date (stub function, explain)
--Testcase 2578:
EXPLAIN VERBOSE
SELECT utc_date() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=4)
   Output: utc_date()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_date (stub function, not pushdown constraints, explain)
--Testcase 2579:
EXPLAIN VERBOSE
SELECT utc_date() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=4)
   Output: utc_date()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select utc_date (stub function, pushdown constraints, explain)
--Testcase 2580:
EXPLAIN VERBOSE
SELECT utc_date() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=4)
   Output: utc_date()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select utc_date (stub function, utc_date in constraints, explain)
--Testcase 2581:
EXPLAIN VERBOSE
SELECT utc_date() FROM time_tbl WHERE utc_date() > '1997-10-14 00:00:00'::date;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=4)
   Output: utc_date()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((utc_date() > '1997-10-14'))
(4 rows)

-- utc_date in constrains (stub function, explain)
--Testcase 2582:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE utc_date() > '1997-10-14 00:00:00'::date;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((utc_date() > '1997-10-14'))
(4 rows)

-- utc_date in constrains (stub function, result)
--Testcase 2583:
SELECT c1 FROM time_tbl WHERE utc_date() > '1997-10-14 00:00:00'::date;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- utc_date as parameter of addtime(stub function, explain)
--Testcase 2584:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(utc_date(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::date;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.26 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(utc_date(), '1 12:59:10.0') > '1997-10-14'))
(4 rows)

-- utc_date as parameter of addtime(stub function, result)
--Testcase 2585:
SELECT c1 FROM time_tbl WHERE addtime(utc_date(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::date;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select utc_date and agg (pushdown, explain)
--Testcase 2586:
EXPLAIN VERBOSE
SELECT utc_date(), sum(id) FROM time_tbl;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (utc_date()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_date(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select utc_date and log2 (pushdown, explain)
--Testcase 2587:
EXPLAIN VERBOSE
SELECT utc_date(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=12)
   Output: utc_date(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_date with non pushdown func and explicit constant (explain)
--Testcase 2588:
EXPLAIN VERBOSE
SELECT utc_date(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=40)
   Output: utc_date(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select utc_date with order by (explain)
--Testcase 2589:
EXPLAIN VERBOSE
SELECT utc_date(), c1 FROM time_tbl ORDER BY c1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=12)
   Output: (utc_date()), c1
   Local server startup cost: 10
   Remote query: SELECT utc_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select utc_date with order by index (explain)
--Testcase 2590:
EXPLAIN VERBOSE
SELECT utc_date(), c1 FROM time_tbl ORDER BY 2;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=12)
   Output: (utc_date()), c1
   Local server startup cost: 10
   Remote query: SELECT utc_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- utc_date constraints with order by (explain)
--Testcase 2591:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(utc_date(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp ORDER BY c1;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(utc_date(), '1 12:59:10.0') > '1997-10-14 00:00:00')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- utc_date constraints with order by (result)
--Testcase 2592:
SELECT c1 FROM time_tbl WHERE addtime(utc_date(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select utc_date with group by (explain)
--Testcase 2593:
EXPLAIN VERBOSE
SELECT utc_date(), c1 FROM time_tbl GROUP BY c1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (utc_date()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select utc_date with group by index (explain)
--Testcase 2594:
EXPLAIN VERBOSE
SELECT utc_date(), c1 FROM time_tbl GROUP BY 2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (utc_date()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select utc_date with group by having (explain)
--Testcase 2595:
EXPLAIN VERBOSE
SELECT utc_date(), c1 FROM time_tbl GROUP BY utc_date(),c1 HAVING utc_date() > '1997-10-14 00:00:00'::timestamp;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=12)
   Output: (utc_date()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((utc_date() > '1997-10-14 00:00:00'))
(5 rows)

-- select utc_date with group by index having (explain)
--Testcase 2596:
EXPLAIN VERBOSE
SELECT utc_date(), c1 FROM time_tbl GROUP BY 2,1 HAVING utc_date() > '1997-10-14 00:00:00'::timestamp;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=12)
   Output: (utc_date()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT utc_date(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((utc_date() > '1997-10-14 00:00:00'))
(5 rows)

-- utc_date constraints with group by (explain)
--Testcase 2597:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(utc_date(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp GROUP BY c1;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(utc_date(), '1 12:59:10.0') > '1997-10-14 00:00:00')) GROUP BY 1
(5 rows)

-- utc_date constraints with group by (result)
--Testcase 2598:
SELECT c1 FROM time_tbl WHERE addtime(utc_date(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select utc_date and as
--Testcase 2599:
EXPLAIN VERBOSE
SELECT utc_date() as utc_date1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=4)
   Output: utc_date()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- UNIX_TIMESTAMP()
-- select unix_timestamp (stub function, explain)
--Testcase 2600:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2) FROM time_tbl;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..201.00 rows=2275 width=96)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select unix_timestamp (stub function, not pushdown constraints, explain)
--Testcase 2601:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2) FROM time_tbl WHERE to_hex(id) > '0';
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..166.87 rows=758 width=96)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select unix_timestamp (stub function, pushdown constraints, explain)
--Testcase 2602:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2) FROM time_tbl WHERE id = 1;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..138.77 rows=11 width=96)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select unix_timestamp (stub function, unix_timestamp in constraints, explain)
--Testcase 2603:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2) FROM time_tbl WHERE unix_timestamp() > unix_timestamp('1997-10-14 00:00:00'::timestamp);
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..172.55 rows=758 width=96)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((unix_timestamp() > unix_timestamp('1997-10-14 00:00:00')))
(4 rows)

-- unix_timestamp in constrains (stub function, explain)
--Testcase 2604:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE unix_timestamp() > unix_timestamp('1997-10-14 00:00:00'::timestamp);
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..171.86 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((unix_timestamp() > unix_timestamp('1997-10-14 00:00:00')))
(4 rows)

-- unix_timestamp in constrains (stub function, result)
--Testcase 2605:
SELECT c1 FROM time_tbl WHERE unix_timestamp() > unix_timestamp('1997-10-14 00:00:00'::timestamp);
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select unix_timestamp and agg (pushdown, explain)
--Testcase 2606:
EXPLAIN VERBOSE
SELECT unix_timestamp(), sum(id) FROM time_tbl;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (unix_timestamp()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT unix_timestamp(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select unix_timestamp and log2 (pushdown, explain)
--Testcase 2607:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2), log2(id) FROM time_tbl;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..202.16 rows=2048 width=104)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select unix_timestamp with non pushdown func and explicit constant (explain)
--Testcase 2608:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2), to_hex(id), 4 FROM time_tbl;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..197.04 rows=2048 width=132)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select unix_timestamp with order by (explain)
--Testcase 2609:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2), c1 FROM time_tbl ORDER BY c1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=104)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone), c1
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select unix_timestamp with order by index (explain)
--Testcase 2610:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2), c1 FROM time_tbl ORDER BY 2;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=104)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone), c1
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY unix_timestamp(`c3`) IS NULL ASC, unix_timestamp(`c3`) ASC
(4 rows)

-- select unix_timestamp with group by (explain)
--Testcase 2611:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2), c1 FROM time_tbl GROUP BY c1,c2,c3;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=116)
   Output: (unix_timestamp()), (unix_timestamp(c3)), (unix_timestamp((c2)::timestamp without time zone)), c1, c2, c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT unix_timestamp(), unix_timestamp(`c3`), unix_timestamp(`c2`), `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 4, 5, 6
(5 rows)

-- select unix_timestamp with group by index (explain)
--Testcase 2612:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2), c1 FROM time_tbl GROUP BY 1,2,3,4;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1861 width=104)
   Output: (unix_timestamp()), (unix_timestamp(c3)), (unix_timestamp((c2)::timestamp without time zone)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT unix_timestamp(), unix_timestamp(`c3`), unix_timestamp(`c2`), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3, 4
(5 rows)

-- select unix_timestamp with group by having (explain)
--Testcase 2613:
EXPLAIN VERBOSE
SELECT unix_timestamp(), c1 FROM time_tbl GROUP BY unix_timestamp(),c1 HAVING unix_timestamp() > 100000;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=40)
   Output: (unix_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT unix_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((unix_timestamp() > 100000))
(5 rows)

-- select unix_timestamp with group by index having (explain)
--Testcase 2614:
EXPLAIN VERBOSE
SELECT unix_timestamp(), c1 FROM time_tbl GROUP BY 2,1 HAVING unix_timestamp() > 100000;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=40)
   Output: (unix_timestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT unix_timestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((unix_timestamp() > 100000))
(5 rows)

-- select unix_timestamp and as
--Testcase 2615:
EXPLAIN VERBOSE
SELECT unix_timestamp(), unix_timestamp(c3), unix_timestamp(c2) as unix_timestamp1 FROM time_tbl;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..201.00 rows=2275 width=96)
   Output: unix_timestamp(), unix_timestamp(c3), unix_timestamp((c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- TO_SECONDS()
-- select to_seconds (stub function, explain)
--Testcase 2616:
EXPLAIN VERBOSE
SELECT to_seconds(id + 200719), to_seconds(c3), to_seconds(c2) FROM time_tbl;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..197.04 rows=2048 width=24)
   Output: to_seconds((id + 200719)), to_seconds(c3), to_seconds((c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select to_seconds (stub function, not pushdown constraints, explain)
--Testcase 2617:
EXPLAIN VERBOSE
SELECT to_seconds(id + 200719), to_seconds(c3), to_seconds(c2) FROM time_tbl WHERE to_hex(id) > '0';
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..162.92 rows=683 width=24)
   Output: to_seconds((id + 200719)), to_seconds(c3), to_seconds((c2)::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select to_seconds (stub function, pushdown constraints, explain)
--Testcase 2618:
EXPLAIN VERBOSE
SELECT to_seconds(id + 200719), to_seconds(c3), to_seconds(c2) FROM time_tbl WHERE id = 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..135.92 rows=10 width=24)
   Output: to_seconds((id + 200719)), to_seconds(c3), to_seconds((c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select to_seconds (stub function, to_seconds in constraints, explain)
--Testcase 2619:
EXPLAIN VERBOSE
SELECT to_seconds(id + 200719), to_seconds(c3), to_seconds(c2) FROM time_tbl WHERE to_seconds(id + 200719) > to_seconds('1997-10-14 00:00:00'::timestamp);
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..173.16 rows=683 width=24)
   Output: to_seconds((id + 200719)), to_seconds(c3), to_seconds((c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((to_seconds((`id` + 200719)) > to_seconds('1997-10-14 00:00:00')))
(4 rows)

-- to_seconds in constrains (stub function, explain)
--Testcase 2620:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE to_seconds(id + 200719) > to_seconds('1997-10-14 00:00:00'::timestamp);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.26 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((to_seconds((`id` + 200719)) > to_seconds('1997-10-14 00:00:00')))
(4 rows)

-- to_seconds in constrains (stub function, result)
--Testcase 2621:
SELECT c1 FROM time_tbl WHERE to_seconds(id + 200719) > to_seconds('1997-10-14 00:00:00'::timestamp);
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select to_seconds and agg (pushdown, explain)
--Testcase 2622:
EXPLAIN VERBOSE
SELECT to_seconds('1997-10-14 00:00:00'::timestamp), to_seconds('1997-10-14 00:00:00'::date), sum(id) FROM time_tbl;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=24)
   Output: (to_seconds('1997-10-14 00:00:00'::timestamp without time zone)), (to_seconds('1997-10-14 00:00:00'::timestamp without time zone)), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_seconds('1997-10-14 00:00:00'), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select to_seconds and log2 (pushdown, explain)
--Testcase 2623:
EXPLAIN VERBOSE
SELECT to_seconds('1997-10-14 00:00:00'::timestamp), to_seconds(c3), to_seconds(c2), log2(id) FROM time_tbl;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..202.16 rows=2048 width=32)
   Output: to_seconds('1997-10-14 00:00:00'::timestamp without time zone), to_seconds(c3), to_seconds((c2)::timestamp without time zone), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select to_seconds with non pushdown func and explicit constant (explain)
--Testcase 2624:
EXPLAIN VERBOSE
SELECT to_seconds('1997-10-14 00:00:00'::timestamp), to_seconds(c3), to_seconds(c2), to_hex(id), 4 FROM time_tbl;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..197.04 rows=2048 width=60)
   Output: to_seconds('1997-10-14 00:00:00'::timestamp without time zone), to_seconds(c3), to_seconds((c2)::timestamp without time zone), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select to_seconds with order by (explain)
--Testcase 2625:
EXPLAIN VERBOSE
SELECT to_seconds(id + 200719), to_seconds(c3), to_seconds(c2), c1 FROM time_tbl ORDER BY c1;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.38 rows=30 width=32)
   Output: to_seconds((id + 200719)), to_seconds(c3), to_seconds((c2)::timestamp without time zone), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select to_seconds with order by index (explain)
--Testcase 2626:
EXPLAIN VERBOSE
SELECT to_seconds(id + 200719), to_seconds(c3), to_seconds(c2), c1 FROM time_tbl ORDER BY 2;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.38 rows=30 width=32)
   Output: to_seconds((id + 200719)), to_seconds(c3), to_seconds((c2)::timestamp without time zone), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY to_seconds(`c3`) IS NULL ASC, to_seconds(`c3`) ASC
(4 rows)

-- to_seconds constraints with order by (explain)
--Testcase 2627:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE to_seconds('2020-10-14 00:00:00'::timestamp) > to_seconds('1997-10-14 00:00:00'::timestamp) ORDER BY c1;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((to_seconds('2020-10-14 00:00:00') > to_seconds('1997-10-14 00:00:00'))) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- to_seconds constraints with order by (result)
--Testcase 2628:
SELECT c1 FROM time_tbl WHERE to_seconds('2020-10-14 00:00:00'::timestamp) > to_seconds('1997-10-14 00:00:00'::timestamp) ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select to_seconds with group by (explain)
--Testcase 2629:
EXPLAIN VERBOSE
SELECT to_seconds(971014), to_seconds(c3), to_seconds(c2), c1 FROM time_tbl GROUP BY c1,c2,c3;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=44)
   Output: (to_seconds(971014)), (to_seconds(c3)), (to_seconds((c2)::timestamp without time zone)), c1, c2, c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_seconds(971014), to_seconds(`c3`), to_seconds(`c2`), `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 4, 5, 6
(5 rows)

-- select to_seconds with group by index (explain)
--Testcase 2630:
EXPLAIN VERBOSE
SELECT to_seconds(971014), to_seconds(c3), to_seconds(c2), c1 FROM time_tbl GROUP BY 1,2,3,4;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1861 width=32)
   Output: (to_seconds(971014)), (to_seconds(c3)), (to_seconds((c2)::timestamp without time zone)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_seconds(971014), to_seconds(`c3`), to_seconds(`c2`), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3, 4
(5 rows)

-- select to_seconds with group by having (explain)
--Testcase 2631:
EXPLAIN VERBOSE
SELECT to_seconds(971014), c1 FROM time_tbl GROUP BY to_seconds(971014),c1 HAVING to_seconds(971014) > 100000;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (to_seconds(971014)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_seconds(971014), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((to_seconds(971014) > 100000))
(5 rows)

-- select to_seconds with group by index having (explain)
--Testcase 2632:
EXPLAIN VERBOSE
SELECT to_seconds(971014), c1 FROM time_tbl GROUP BY 2,1 HAVING to_seconds(971014) > 100000;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (to_seconds(971014)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_seconds(971014), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((to_seconds(971014) > 100000))
(5 rows)

-- select to_seconds and as
--Testcase 2633:
EXPLAIN VERBOSE
SELECT to_seconds(971014), to_seconds(c3), to_seconds(c2) as to_seconds1 FROM time_tbl;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..201.00 rows=2275 width=24)
   Output: to_seconds(971014), to_seconds(c3), to_seconds((c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- TO_DAYS()
-- select to_days (stub function, explain)
--Testcase 2634:
EXPLAIN VERBOSE
SELECT to_days(id + 200719), to_days(c2) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.00 rows=2560 width=8)
   Output: to_days((id + 200719)), to_days(c2)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select to_days (stub function, not pushdown constraints, explain)
--Testcase 2635:
EXPLAIN VERBOSE
SELECT to_days(id + 200719), to_days(c2) FROM time_tbl WHERE to_hex(id) > '0';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..171.86 rows=853 width=8)
   Output: to_days((id + 200719)), to_days(c2)
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select to_days (stub function, pushdown constraints, explain)
--Testcase 2636:
EXPLAIN VERBOSE
SELECT to_days(id + 200719), to_days(c2) FROM time_tbl WHERE id = 1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..142.36 rows=13 width=8)
   Output: to_days((id + 200719)), to_days(c2)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select to_days (stub function, to_days in constraints, explain)
--Testcase 2637:
EXPLAIN VERBOSE
SELECT to_days(id + 200719), to_days(c2) FROM time_tbl WHERE to_days(id + 200719) > to_days('1997-10-14 00:00:00'::date);
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..184.66 rows=853 width=8)
   Output: to_days((id + 200719)), to_days(c2)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((to_days((`id` + 200719)) > to_days('1997-10-14')))
(4 rows)

-- to_days in constrains (stub function, explain)
--Testcase 2638:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE to_days(id + 200719) > to_days('1997-10-14 00:00:00'::date);
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.26 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((to_days((`id` + 200719)) > to_days('1997-10-14')))
(4 rows)

-- to_days in constrains (stub function, result)
--Testcase 2639:
SELECT c1 FROM time_tbl WHERE to_days(id + 200719) > to_days('1997-10-14 00:00:00'::date);
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select to_days and agg (pushdown, explain)
--Testcase 2640:
EXPLAIN VERBOSE
SELECT to_days('1997-10-14 00:00:00'::date), to_days('1997-10-14 00:00:00'::date), sum(id) FROM time_tbl;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (to_days('1997-10-14'::date)), (to_days('1997-10-14'::date)), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_days('1997-10-14'), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select to_days and log2 (pushdown, explain)
--Testcase 2641:
EXPLAIN VERBOSE
SELECT to_days('1997-10-14 00:00:00'::date), to_days(c2), log2(id) FROM time_tbl;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.40 rows=2560 width=16)
   Output: to_days('1997-10-14'::date), to_days(c2), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select to_days with non pushdown func and explicit constant (explain)
--Testcase 2642:
EXPLAIN VERBOSE
SELECT to_days('1997-10-14 00:00:00'::date), to_days(c2), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.00 rows=2560 width=44)
   Output: to_days('1997-10-14'::date), to_days(c2), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select to_days with order by (explain)
--Testcase 2643:
EXPLAIN VERBOSE
SELECT to_days(id + 200719), to_days(c2), c1 FROM time_tbl ORDER BY c1;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=16)
   Output: to_days((id + 200719)), to_days(c2), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select to_days with order by index (explain)
--Testcase 2644:
EXPLAIN VERBOSE
SELECT to_days(id + 200719), to_days(c2), c1 FROM time_tbl ORDER BY 2;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.22 rows=30 width=16)
   Output: to_days((id + 200719)), to_days(c2), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY to_days(`c2`) IS NULL ASC, to_days(`c2`) ASC
(4 rows)

-- to_days constraints with order by (explain)
--Testcase 2645:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE to_days('2020-10-14 00:00:00'::date) > to_days('1997-10-14 00:00:00'::date) ORDER BY c1;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((to_days('2020-10-14') > to_days('1997-10-14'))) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- to_days constraints with order by (result)
--Testcase 2646:
SELECT c1 FROM time_tbl WHERE to_days('2020-10-14 00:00:00'::date) > to_days('1997-10-14 00:00:00'::date) ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select to_days with group by (explain)
--Testcase 2647:
EXPLAIN VERBOSE
SELECT to_days(971014), to_days(c2), c1 FROM time_tbl GROUP BY c1,c2;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=20)
   Output: (to_days(971014)), (to_days(c2)), c1, c2
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_days(971014), to_days(`c2`), `c1`, `c2` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 3, 4
(5 rows)

-- select to_days with group by index (explain)
--Testcase 2648:
EXPLAIN VERBOSE
SELECT to_days(971014), to_days(c2), c1 FROM time_tbl GROUP BY 1,2,3;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2275 width=16)
   Output: (to_days(971014)), (to_days(c2)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_days(971014), to_days(`c2`), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3
(5 rows)

-- select to_days with group by having (explain)
--Testcase 2649:
EXPLAIN VERBOSE
SELECT to_days(971014), c1 FROM time_tbl GROUP BY c1,to_days(971014) HAVING to_days(971014) > 1000;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=12)
   Output: (to_days(971014)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_days(971014), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((to_days(971014) > 1000))
(5 rows)

-- select to_days with group by index having (explain)
--Testcase 2650:
EXPLAIN VERBOSE
SELECT to_days(971014), c1 FROM time_tbl GROUP BY 2,1 HAVING to_days(971014) > 1000;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=12)
   Output: (to_days(971014)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT to_days(971014), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((to_days(971014) > 1000))
(5 rows)

-- select to_days and as
--Testcase 2651:
EXPLAIN VERBOSE
SELECT to_days(971014), to_days(c2) as to_days1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=8)
   Output: to_days(971014), to_days(c2)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- TIMESTAMPDIFF()
-- select timestampdiff (stub function, explain)
--Testcase 2652:
EXPLAIN VERBOSE
SELECT timestampdiff('MINUTE', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('MONTH', c2, '2080-01-01'::date), timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..218.06 rows=2275 width=32)
   Output: timestampdiff('MINUTE'::time_unit, (c2)::timestamp without time zone, c3), timestampdiff('DAY'::time_unit, c3, (c2)::timestamp without time zone), timestampdiff('MONTH'::time_unit, (c2)::timestamp without time zone, '2080-01-01 00:00:00'::timestamp without time zone), timestampdiff('YEAR'::time_unit, c3, '2080-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select timestampdiff (stub function, result)
--Testcase 2653:
SELECT timestampdiff('MINUTE', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('MONTH', c2, '2080-01-01'::date), timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select timestampdiff (stub function, not pushdown constraints, explain)
--Testcase 2654:
EXPLAIN VERBOSE
SELECT timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.54 rows=11 width=32)
   Output: timestampdiff('DAY'::time_unit, (c2)::timestamp without time zone, c3), timestampdiff('DAY'::time_unit, c3, (c2)::timestamp without time zone), timestampdiff('DAY'::time_unit, (c2)::timestamp without time zone, '2080-01-01 00:00:00'::timestamp without time zone), timestampdiff('YEAR'::time_unit, c3, '2080-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select timestampdiff (stub function, not pushdown constraints, result)
--Testcase 2655:
SELECT timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select timestampdiff (stub function, pushdown constraints, explain)
--Testcase 2656:
EXPLAIN VERBOSE
SELECT timestampdiff('YEAR', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..223.34 rows=2264 width=32)
   Output: timestampdiff('YEAR'::time_unit, (c2)::timestamp without time zone, c3), timestampdiff('DAY'::time_unit, c3, (c2)::timestamp without time zone), timestampdiff('DAY'::time_unit, (c2)::timestamp without time zone, '2080-01-01 00:00:00'::timestamp without time zone), timestampdiff('YEAR'::time_unit, c3, '2080-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select timestampdiff (stub function, pushdown constraints, result)
--Testcase 2657:
SELECT timestampdiff('YEAR', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select timestampdiff (stub function, timestampdiff in constraints, explain)
--Testcase 2658:
EXPLAIN VERBOSE
SELECT timestampdiff('YEAR', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl WHERE timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) < 100;
                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..172.55 rows=758 width=32)
   Output: timestampdiff('YEAR'::time_unit, (c2)::timestamp without time zone, c3), timestampdiff('DAY'::time_unit, c3, (c2)::timestamp without time zone), timestampdiff('DAY'::time_unit, (c2)::timestamp without time zone, '2080-01-01 00:00:00'::timestamp without time zone), timestampdiff('YEAR'::time_unit, c3, '2080-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((timestampdiff(YEAR, `c3`, '2080-01-01 12:00:00') < 100))
(4 rows)

-- select timestampdiff (stub function, timestampdiff in constraints, result)
--Testcase 2659:
SELECT timestampdiff('YEAR', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl WHERE timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) < 100;
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select timestampdiff with agg (pushdown, explain)
--Testcase 2660:
EXPLAIN VERBOSE
SELECT max(c3), timestampdiff('DAY', max(c2), max(c3)), timestampdiff('MONTH', min(c2), min(c3)) FROM time_tbl;
                                                                                          QUERY PLAN                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=24)
   Output: (max(c3)), (timestampdiff('DAY'::time_unit, (max(c2))::timestamp without time zone, max(c3))), (timestampdiff('MONTH'::time_unit, (min(c2))::timestamp without time zone, min(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), timestampdiff(DAY, max(`c2`), max(`c3`)), timestampdiff(MONTH, min(`c2`), min(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select timestampdiff as nest function with agg (pushdown, result)
--Testcase 2661:
SELECT max(c3), timestampdiff('DAY', max(c2), max(c3)), timestampdiff('MONTH', min(c2), min(c3)) FROM time_tbl;
         max         | timestampdiff | timestampdiff 
---------------------+---------------+---------------
 2021-01-07 00:59:59 |           -21 |             0
(1 row)

-- select timestampdiff with non pushdown func and explicit constant (explain)
--Testcase 2662:
EXPLAIN VERBOSE
SELECT timestampdiff('MONTH', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp), pi(), 4.1 FROM time_tbl;
                                                                                                                               QUERY PLAN                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..195.31 rows=2275 width=56)
   Output: timestampdiff('MONTH'::time_unit, (c2)::timestamp without time zone, '2080-01-01 00:00:00'::timestamp without time zone), timestampdiff('DAY'::time_unit, c3, '2080-01-01 12:00:00'::timestamp without time zone), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select timestampdiff with non pushdown func and explicit constant (result)
--Testcase 2663:
SELECT timestampdiff('MONTH', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp), pi(), 4.1 FROM time_tbl;
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select timestampdiff with order by (explain)
--Testcase 2664:
EXPLAIN VERBOSE
SELECT id, timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl order by timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp);
                                                                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.52 rows=30 width=36)
   Output: id, timestampdiff('DAY'::time_unit, (c2)::timestamp without time zone, c3), timestampdiff('DAY'::time_unit, c3, (c2)::timestamp without time zone), timestampdiff('DAY'::time_unit, (c2)::timestamp without time zone, '2080-01-01 00:00:00'::timestamp without time zone), timestampdiff('DAY'::time_unit, c3, '2080-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY timestampdiff(DAY, `c2`, `c3`) IS NULL ASC, timestampdiff(DAY, `c2`, `c3`) ASC, timestampdiff(DAY, `c3`, `c2`) IS NULL ASC, timestampdiff(DAY, `c3`, `c2`) ASC, timestampdiff(DAY, `c2`, '2080-01-01 00:00:00') IS NULL ASC, timestampdiff(DAY, `c2`, '2080-01-01 00:00:00') ASC, timestampdiff(DAY, `c3`, '2080-01-01 12:00:00') IS NULL ASC, timestampdiff(DAY, `c3`, '2080-01-01 12:00:00') ASC
(4 rows)

-- select timestampdiff with order by (result)
--Testcase 2665:
SELECT id, timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl order by timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp);
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select timestampdiff with order by index (result)
--Testcase 2666:
SELECT id, timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl order by 5,4,3,2,1;
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select timestampdiff with order by index (result)
--Testcase 2667:
SELECT id, timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl order by 1,2,3,4,5;
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select timestampdiff with group by (explain)
--Testcase 2668:
EXPLAIN VERBOSE
SELECT max(c3), timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl group by timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp);
                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=40)
   Output: (max(c3)), (timestampdiff('DAY'::time_unit, (c2)::timestamp without time zone, c3)), (timestampdiff('DAY'::time_unit, c3, (c2)::timestamp without time zone)), (timestampdiff('DAY'::time_unit, (c2)::timestamp without time zone, '2080-01-01 00:00:00'::timestamp without time zone)), (timestampdiff('DAY'::time_unit, c3, '2080-01-01 12:00:00'::timestamp without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), timestampdiff(DAY, `c2`, `c3`), timestampdiff(DAY, `c3`, `c2`), timestampdiff(DAY, `c2`, '2080-01-01 00:00:00'), timestampdiff(DAY, `c3`, '2080-01-01 12:00:00') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 4, 5
(5 rows)

-- select timestampdiff with group by (result)
--Testcase 2669:
SELECT max(c3), timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp) FROM time_tbl group by timestampdiff('DAY', c2, c3), timestampdiff('DAY', c3, c2), timestampdiff('DAY', c2, '2080-01-01'::date), timestampdiff('DAY', c3, '2080-01-01 12:00:00'::timestamp);
         max         | timestampdiff | timestampdiff | timestampdiff | timestampdiff 
---------------------+---------------+---------------+---------------+---------------
 2021-01-03 12:10:30 |             1 |            -1 |         21548 |         21546
 2021-01-04 23:12:13 |             3 |            -3 |         21549 |         21545
 2021-01-05 11:12:12 |            -4 |             4 |         21540 |         21545
 2021-01-06 16:00:00 |            -8 |             8 |         21535 |         21543
 2021-01-07 00:59:59 |           -21 |            21 |         21521 |         21543
(5 rows)

-- select timestampdiff with group by index (result)
--Testcase 2670:
SELECT id, timestampdiff('DAY', '2021-01-01 12:00:00'::timestamp, '2080-01-01'::date), timestampdiff('DAY', '2019-01-01'::date, '2080-01-01 12:00:00'::timestamp) FROM time_tbl group by 3,2,1;
 id | timestampdiff | timestampdiff 
----+---------------+---------------
  0 |         21548 |         22280
  1 |         21548 |         22280
  2 |         21548 |         22280
  3 |         21548 |         22280
  4 |         21548 |         22280
(5 rows)

-- select timestampdiff with group by index (result)
--Testcase 2671:
SELECT id, timestampdiff('DAY', '2021-01-01 12:00:00'::timestamp, '2080-01-01'::date), timestampdiff('DAY', '2019-01-01'::date, '2080-01-01 12:00:00'::timestamp) FROM time_tbl group by 1,2,3;
 id | timestampdiff | timestampdiff 
----+---------------+---------------
  0 |         21548 |         22280
  1 |         21548 |         22280
  2 |         21548 |         22280
  3 |         21548 |         22280
  4 |         21548 |         22280
(5 rows)

-- select timestampdiff and as
--Testcase 2672:
SELECT timestampdiff('MINUTE', c2, c3) as timestampdiff1, timestampdiff('DAY', c3, c2) as timestampdiff2, timestampdiff('MONTH', c2, '2080-01-01'::date) as timestampdiff3, timestampdiff('YEAR', c3, '2080-01-01 12:00:00'::timestamp) as timestampdiff4 FROM time_tbl;
ERROR:  stub timestampdiff(time_unit, timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timestampdiff(time_unit,timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- TIMESTAMPADD()
-- select timestampadd (stub function, explain)
--Testcase 2673:
EXPLAIN VERBOSE
SELECT timestampadd('MINUTE', 5, c3), timestampadd('DAY', 5, c2) FROM time_tbl;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..195.31 rows=2275 width=16)
   Output: timestampadd('MINUTE'::time_unit, 5, c3), timestampadd('DAY'::time_unit, 5, (c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select timestampadd (stub function, result)
--Testcase 2674:
SELECT timestampadd('MINUTE', 5, c3), timestampadd('DAY', 5, c2) FROM time_tbl;
ERROR:  stub timestampadd(time_unit, integer, timestamp) is called
CONTEXT:  PL/pgSQL function timestampadd(time_unit,integer,timestamp without time zone) line 3 at RAISE
-- select timestampadd (stub function, not pushdown constraints, explain)
--Testcase 2675:
EXPLAIN VERBOSE
SELECT timestampadd('MINUTE', 10, c3), timestampadd('YEAR', 5, c2) FROM time_tbl WHERE to_hex(id) = '1';
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.43 rows=11 width=16)
   Output: timestampadd('MINUTE'::time_unit, 10, c3), timestampadd('YEAR'::time_unit, 5, (c2)::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select timestampadd (stub function, not pushdown constraints, result)
--Testcase 2676:
SELECT timestampadd('MINUTE', 10, c3), timestampadd('YEAR', 5, c2) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub timestampadd(time_unit, integer, timestamp) is called
CONTEXT:  PL/pgSQL function timestampadd(time_unit,integer,timestamp without time zone) line 3 at RAISE
-- select timestampadd (stub function, pushdown constraints, explain)
--Testcase 2677:
EXPLAIN VERBOSE
SELECT timestampadd('MINUTE', 6, c3), timestampadd('YEAR', 5, c2) FROM time_tbl WHERE id != 200;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..200.70 rows=2264 width=16)
   Output: timestampadd('MINUTE'::time_unit, 6, c3), timestampadd('YEAR'::time_unit, 5, (c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select timestampadd (stub function, pushdown constraints, result)
--Testcase 2678:
SELECT timestampadd('MINUTE', 6, c3), timestampadd('YEAR', 5, c2) FROM time_tbl WHERE id != 200;
ERROR:  stub timestampadd(time_unit, integer, timestamp) is called
CONTEXT:  PL/pgSQL function timestampadd(time_unit,integer,timestamp without time zone) line 3 at RAISE
-- select timestampadd (stub function, timestampadd in constraints, explain)
--Testcase 2679:
EXPLAIN VERBOSE
SELECT timestampadd('MINUTE', 6, c3), timestampadd('YEAR', 10, c2) FROM time_tbl WHERE timestampadd('YEAR', 1, c2) > '1997-01-01 12:00:00'::timestamp;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=16)
   Output: timestampadd('MINUTE'::time_unit, 6, c3), timestampadd('YEAR'::time_unit, 10, (c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((timestampadd(YEAR, 1, `c2`) > '1997-01-01 12:00:00'))
(4 rows)

-- select timestampadd (stub function, timestampadd in constraints, result)
--Testcase 2680:
SELECT timestampadd('MINUTE', 6, c3), timestampadd('YEAR', 10, c2) FROM time_tbl WHERE timestampadd('YEAR', 1, c2) > '1997-01-01 12:00:00'::timestamp;
ERROR:  stub timestampadd(time_unit, integer, timestamp) is called
CONTEXT:  PL/pgSQL function timestampadd(time_unit,integer,timestamp without time zone) line 3 at RAISE
-- select timestampadd with agg (pushdown, explain)
--Testcase 2681:
EXPLAIN VERBOSE
SELECT max(c3), timestampadd('DAY', 2, max(c3)), timestampadd('MONTH', 2, min(c2)) FROM time_tbl;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=24)
   Output: (max(c3)), (timestampadd('DAY'::time_unit, 2, max(c3))), (timestampadd('MONTH'::time_unit, 2, (min(c2))::timestamp without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), timestampadd(DAY, 2, max(`c3`)), timestampadd(MONTH, 2, min(`c2`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select timestampadd as nest function with agg (pushdown, result)
--Testcase 2682:
SELECT max(c3), timestampadd('DAY', 2, max(c3)), timestampadd('MONTH', 2, min(c2)) FROM time_tbl;
         max         |    timestampadd     |    timestampadd     
---------------------+---------------------+---------------------
 2021-01-07 00:59:59 | 2021-01-09 00:59:59 | 2021-03-01 00:00:00
(1 row)

-- select timestampadd with non pushdown func and explicit constant (explain)
--Testcase 2683:
EXPLAIN VERBOSE
SELECT timestampadd('MINUTE', 2, max(c3)), timestampadd('MONTH', 60, min(c2)), pi(), 4.1 FROM time_tbl;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=56)
   Output: (timestampadd('MINUTE'::time_unit, 2, max(c3))), (timestampadd('MONTH'::time_unit, 60, (min(c2))::timestamp without time zone)), '3.141592653589793'::double precision, 4.1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT timestampadd(MINUTE, 2, max(`c3`)), timestampadd(MONTH, 60, min(`c2`)), 3.141592653589793, 4.1 FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select timestampadd with non pushdown func and explicit constant (result)
--Testcase 2684:
SELECT timestampadd('MINUTE', 2, max(c3)), timestampadd('MONTH', 60, min(c2)), pi(), 4.1 FROM time_tbl;
    timestampadd     |    timestampadd     |        pi         | ?column? 
---------------------+---------------------+-------------------+----------
 2021-01-07 01:01:59 | 2026-01-01 00:00:00 | 3.141592653589793 |      4.1
(1 row)

-- select timestampadd with order by (explain)
--Testcase 2685:
EXPLAIN VERBOSE
SELECT id, timestampadd('MINUTE', 60, c3), timestampadd('YEAR', 10, c2) FROM time_tbl order by timestampadd('MINUTE', 60, c3), timestampadd('YEAR', 10, c2);
                                                                                                                   QUERY PLAN                                                                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=20)
   Output: id, timestampadd('MINUTE'::time_unit, 60, c3), timestampadd('YEAR'::time_unit, 10, (c2)::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY timestampadd(MINUTE, 60, `c3`) IS NULL ASC, timestampadd(MINUTE, 60, `c3`) ASC, timestampadd(YEAR, 10, `c2`) IS NULL ASC, timestampadd(YEAR, 10, `c2`) ASC
(4 rows)

-- select timestampadd with order by (result)
--Testcase 2686:
SELECT id, timestampadd('MINUTE', 60, c3), timestampadd('YEAR', 10, c2) FROM time_tbl order by timestampadd('MINUTE', 60, c3), timestampadd('YEAR', 10, c2);
ERROR:  stub timestampadd(time_unit, integer, timestamp) is called
CONTEXT:  PL/pgSQL function timestampadd(time_unit,integer,timestamp without time zone) line 3 at RAISE
-- select timestampadd with order by index (result)
--Testcase 2687:
SELECT id,timestampadd('MINUTE', 60, c3), timestampadd('YEAR', 10, c2) FROM time_tbl order by 3,2,1;
ERROR:  stub timestampadd(time_unit, integer, timestamp) is called
CONTEXT:  PL/pgSQL function timestampadd(time_unit,integer,timestamp without time zone) line 3 at RAISE
-- select timestampadd with order by index (result)
--Testcase 2688:
SELECT id, timestampadd('MINUTE', 60, c3), timestampadd('YEAR', 10, c2) FROM time_tbl order by 1,2,3;
ERROR:  stub timestampadd(time_unit, integer, timestamp) is called
CONTEXT:  PL/pgSQL function timestampadd(time_unit,integer,timestamp without time zone) line 3 at RAISE
-- select timestampadd with group by (explain)
--Testcase 2689:
EXPLAIN VERBOSE
SELECT max(c3), timestampadd('YEAR', 2, '1997-01-01 12:00:00'::timestamp), timestampadd('MONTH', 12, '1997-01-01'::date) FROM time_tbl group by timestampadd('YEAR', 2, '1997-01-01 12:00:00'::timestamp), timestampadd('MONTH', 12, '1997-01-01'::date);
                                                                                                QUERY PLAN                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2560 width=24)
   Output: (max(c3)), (timestampadd('YEAR'::time_unit, 2, '1997-01-01 12:00:00'::timestamp without time zone)), (timestampadd('MONTH'::time_unit, 12, '1997-01-01 00:00:00'::timestamp without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), timestampadd(YEAR, 2, '1997-01-01 12:00:00'), timestampadd(MONTH, 12, '1997-01-01 00:00:00') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3
(5 rows)

-- select timestampadd with group by (result)
--Testcase 2690:
SELECT max(c3), timestampadd('YEAR', 2, '1997-01-01 12:00:00'::timestamp), timestampadd('MONTH', 12, '1997-01-01'::date) FROM time_tbl group by timestampadd('YEAR', 2, '1997-01-01 12:00:00'::timestamp), timestampadd('MONTH', 12, '1997-01-01'::date);
         max         |    timestampadd     |    timestampadd     
---------------------+---------------------+---------------------
 2021-01-07 00:59:59 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
(1 row)

-- select timestampadd with group by index (result)
--Testcase 2691:
SELECT id, timestampadd('YEAR', 2, '1997-01-01 12:00:00'::timestamp), timestampadd('MONTH', 12, '1997-01-01'::date) FROM time_tbl group by 3,2,1;
 id |    timestampadd     |    timestampadd     
----+---------------------+---------------------
  0 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
  1 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
  2 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
  3 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
  4 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
(5 rows)

-- select timestampadd with group by index (result)
--Testcase 2692:
SELECT id, timestampadd('YEAR', 2, '1997-01-01 12:00:00'::timestamp), timestampadd('MONTH', 12, '1997-01-01'::date) FROM time_tbl group by 1,2,3;
 id |    timestampadd     |    timestampadd     
----+---------------------+---------------------
  0 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
  1 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
  2 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
  3 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
  4 | 1999-01-01 12:00:00 | 1998-01-01 00:00:00
(5 rows)

-- select timestampadd and as
--Testcase 2693:
SELECT timestampadd('MINUTE', 60, c2) as timestampadd1, timestampadd('MONTH', 12, '2080-01-01 12:01:00'::timestamp) as timestampadd2 FROM time_tbl;
ERROR:  stub timestampadd(time_unit, integer, timestamp) is called
CONTEXT:  PL/pgSQL function timestampadd(time_unit,integer,timestamp without time zone) line 3 at RAISE
-- TIMESTAMP()
-- select mysql_timestamp (stub function, explain)
--Testcase 2694:
EXPLAIN VERBOSE
SELECT mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..184.44 rows=1861 width=24)
   Output: mysql_timestamp((c2)::timestamp without time zone), mysql_timestamp(c3), mysql_timestamp(c3, c1)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_timestamp (stub function, result)
--Testcase 2695:
SELECT mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl;
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- select mysql_timestamp (stub function, not pushdown constraints, explain)
--Testcase 2696:
EXPLAIN VERBOSE
SELECT mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl WHERE to_hex(id) = '1';
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..138.19 rows=9 width=24)
   Output: mysql_timestamp((c2)::timestamp without time zone), mysql_timestamp(c3), mysql_timestamp(c3, c1)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_timestamp (stub function, not pushdown constraints, result)
--Testcase 2697:
SELECT mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- select mysql_timestamp (stub function, pushdown constraints, explain)
--Testcase 2698:
EXPLAIN VERBOSE
SELECT mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl WHERE id != 200;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..188.82 rows=1852 width=24)
   Output: mysql_timestamp((c2)::timestamp without time zone), mysql_timestamp(c3), mysql_timestamp(c3, c1)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select mysql_timestamp (stub function, pushdown constraints, result)
--Testcase 2699:
SELECT mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl WHERE id != 200;
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- select mysql_timestamp (stub function, mysql_timestamp in constraints, explain)
--Testcase 2700:
EXPLAIN VERBOSE
SELECT mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl WHERE mysql_timestamp(c3, '23:11:59.123456'::time) < '2080-01-01 12:00:00'::timestamp;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..156.51 rows=620 width=24)
   Output: mysql_timestamp((c2)::timestamp without time zone), mysql_timestamp(c3), mysql_timestamp(c3, c1)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((timestamp(`c3`, '23:11:59.123456') < '2080-01-01 12:00:00'))
(4 rows)

-- select mysql_timestamp (stub function, mysql_timestamp in constraints, result)
--Testcase 2701:
SELECT mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl WHERE mysql_timestamp(c3, '23:11:59.123456'::time) < '2080-01-01 12:00:00'::timestamp;
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- select mysql_timestamp with agg (pushdown, explain)
--Testcase 2702:
EXPLAIN VERBOSE
SELECT max(c3), mysql_timestamp(max(c2)), mysql_timestamp(max(c3)), mysql_timestamp(max(c3), '11:12:12.112233'::time) FROM time_tbl;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=32)
   Output: (max(c3)), (mysql_timestamp((max(c2))::timestamp without time zone)), (mysql_timestamp(max(c3))), (mysql_timestamp(max(c3), '11:12:12.112233'::time without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), timestamp(max(`c2`)), timestamp(max(`c3`)), timestamp(max(`c3`), '11:12:12.112233') FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_timestamp as nest function with agg (pushdown, result)
--Testcase 2703:
SELECT max(c3), mysql_timestamp(max(c2)), mysql_timestamp(max(c3)), mysql_timestamp(max(c3), '11:12:12.112233'::time) FROM time_tbl;
         max         |   mysql_timestamp   |   mysql_timestamp   |      mysql_timestamp       
---------------------+---------------------+---------------------+----------------------------
 2021-01-07 00:59:59 | 2021-01-29 00:00:00 | 2021-01-07 00:59:59 | 2021-01-07 12:12:11.112233
(1 row)

-- select mysql_timestamp with non pushdown func and explicit constant (explain)
--Testcase 2704:
EXPLAIN VERBOSE
SELECT mysql_timestamp(max(c2)), mysql_timestamp(max(c3)), mysql_timestamp(max(c3), '11:12:12.112233'::time), pi(), 4.1 FROM time_tbl;
                                                                                                     QUERY PLAN                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=64)
   Output: (mysql_timestamp((max(c2))::timestamp without time zone)), (mysql_timestamp(max(c3))), (mysql_timestamp(max(c3), '11:12:12.112233'::time without time zone)), '3.141592653589793'::double precision, 4.1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT timestamp(max(`c2`)), timestamp(max(`c3`)), timestamp(max(`c3`), '11:12:12.112233'), 3.141592653589793, 4.1 FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_timestamp with non pushdown func and explicit constant (result)
--Testcase 2705:
SELECT mysql_timestamp(max(c2)), mysql_timestamp(max(c3)), mysql_timestamp(max(c3), '11:12:12.112233'::time), pi(), 4.1 FROM time_tbl;
   mysql_timestamp   |   mysql_timestamp   |      mysql_timestamp       |        pi         | ?column? 
---------------------+---------------------+----------------------------+-------------------+----------
 2021-01-29 00:00:00 | 2021-01-07 00:59:59 | 2021-01-07 12:12:11.112233 | 3.141592653589793 |      4.1
(1 row)

-- select mysql_timestamp with order by (explain)
--Testcase 2706:
EXPLAIN VERBOSE
SELECT id, mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl order by mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1);
                                                                                                                         QUERY PLAN                                                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=28)
   Output: id, mysql_timestamp((c2)::timestamp without time zone), mysql_timestamp(c3), mysql_timestamp(c3, c1)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY timestamp(`c2`) IS NULL ASC, timestamp(`c2`) ASC, timestamp(`c3`) IS NULL ASC, timestamp(`c3`) ASC, timestamp(`c3`, `c1`) IS NULL ASC, timestamp(`c3`, `c1`) ASC
(4 rows)

-- select mysql_timestamp with order by (result)
--Testcase 2707:
SELECT id, mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl order by mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1);
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- select mysql_timestamp with order by index (result)
--Testcase 2708:
SELECT id, mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl order by 4,3,2,1;
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- select mysql_timestamp with order by index (result)
--Testcase 2709:
SELECT id, mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl order by 1,2,3,4;
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- select mysql_timestamp with group by (explain)
--Testcase 2710:
EXPLAIN VERBOSE
SELECT max(c3), mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl group by mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1);
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=32)
   Output: (max(c3)), (mysql_timestamp((c2)::timestamp without time zone)), (mysql_timestamp(c3)), (mysql_timestamp(c3, c1))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), timestamp(`c2`), timestamp(`c3`), timestamp(`c3`, `c1`) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 4
(5 rows)

-- select mysql_timestamp with group by (result)
--Testcase 2711:
SELECT max(c3), mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl group by mysql_timestamp('2080-01-01 12:00:00'::date), c1, c2, c3;
         max         |   mysql_timestamp   |   mysql_timestamp   |   mysql_timestamp   
---------------------+---------------------+---------------------+---------------------
 2021-01-03 12:10:30 | 2021-01-02 00:00:00 | 2021-01-03 12:10:30 | 2021-01-04 00:21:00
 2021-01-04 23:12:13 | 2021-01-01 00:00:00 | 2021-01-04 23:12:13 | 2021-01-05 22:24:26
 2021-01-05 11:12:12 | 2021-01-10 00:00:00 | 2021-01-05 11:12:12 | 2021-01-05 22:24:24
 2021-01-06 16:00:00 | 2021-01-15 00:00:00 | 2021-01-06 16:00:00 | 2021-01-07 08:00:00
 2021-01-07 00:59:59 | 2021-01-29 00:00:00 | 2021-01-07 00:59:59 | 2021-01-07 01:59:58
(5 rows)

-- select mysql_timestamp with group by index (result)
--Testcase 2712:
SELECT id, mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl group by 4,3,2,1;
 id |   mysql_timestamp   |   mysql_timestamp   |   mysql_timestamp   
----+---------------------+---------------------+---------------------
  0 | 2021-01-02 00:00:00 | 2021-01-03 12:10:30 | 2021-01-04 00:21:00
  1 | 2021-01-01 00:00:00 | 2021-01-04 23:12:13 | 2021-01-05 22:24:26
  2 | 2021-01-10 00:00:00 | 2021-01-05 11:12:12 | 2021-01-05 22:24:24
  3 | 2021-01-15 00:00:00 | 2021-01-06 16:00:00 | 2021-01-07 08:00:00
  4 | 2021-01-29 00:00:00 | 2021-01-07 00:59:59 | 2021-01-07 01:59:58
(5 rows)

-- select mysql_timestamp with group by index (result)
--Testcase 2713:
SELECT id, mysql_timestamp(c2), mysql_timestamp(c3), mysql_timestamp(c3, c1) FROM time_tbl group by 1,2,3,4;
 id |   mysql_timestamp   |   mysql_timestamp   |   mysql_timestamp   
----+---------------------+---------------------+---------------------
  0 | 2021-01-02 00:00:00 | 2021-01-03 12:10:30 | 2021-01-04 00:21:00
  1 | 2021-01-01 00:00:00 | 2021-01-04 23:12:13 | 2021-01-05 22:24:26
  2 | 2021-01-10 00:00:00 | 2021-01-05 11:12:12 | 2021-01-05 22:24:24
  3 | 2021-01-15 00:00:00 | 2021-01-06 16:00:00 | 2021-01-07 08:00:00
  4 | 2021-01-29 00:00:00 | 2021-01-07 00:59:59 | 2021-01-07 01:59:58
(5 rows)

-- select mysql_timestamp with group by index having (result)
--Testcase 2714:
SELECT id, mysql_timestamp(c2), c2 FROM time_tbl group by 3, 2, 1 HAVING mysql_timestamp(c2) > '2019-01-01'::date;
 id |   mysql_timestamp   |     c2     
----+---------------------+------------
  0 | 2021-01-02 00:00:00 | 2021-01-02
  1 | 2021-01-01 00:00:00 | 2021-01-01
  2 | 2021-01-10 00:00:00 | 2021-01-10
  3 | 2021-01-15 00:00:00 | 2021-01-15
  4 | 2021-01-29 00:00:00 | 2021-01-29
(5 rows)

-- select mysql_timestamp with group by index having (result)
--Testcase 2715:
SELECT id, mysql_timestamp(c2), c2 FROM time_tbl group by 1, 2, 3 HAVING mysql_timestamp(c2) > '2019-01-01'::date;
 id |   mysql_timestamp   |     c2     
----+---------------------+------------
  0 | 2021-01-02 00:00:00 | 2021-01-02
  1 | 2021-01-01 00:00:00 | 2021-01-01
  2 | 2021-01-10 00:00:00 | 2021-01-10
  3 | 2021-01-15 00:00:00 | 2021-01-15
  4 | 2021-01-29 00:00:00 | 2021-01-29
(5 rows)

-- select mysql_timestamp and as
--Testcase 2716:
SELECT mysql_timestamp(c2) as mysql_timestamp1, mysql_timestamp(c3) as mysql_timestamp2,  mysql_timestamp(c3, c1) as mysql_timestamp3 FROM time_tbl;
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- TIMEDIFF()
-- select timediff (stub function, explain)
--Testcase 2717:
EXPLAIN VERBOSE
SELECT timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..181.68 rows=2048 width=32)
   Output: timediff(c1, '12:12:12.051555'::time without time zone), timediff(c3, '1997-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select timediff (stub function, result)
--Testcase 2718:
SELECT timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub timediff(time, time) is called
CONTEXT:  PL/pgSQL function timediff(time without time zone,time without time zone) line 3 at RAISE
-- select timediff (stub function, not pushdown constraints, explain)
--Testcase 2719:
EXPLAIN VERBOSE
SELECT timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..140.97 rows=10 width=32)
   Output: timediff(c1, '12:12:12.051555'::time without time zone), timediff(c3, '1997-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select timediff (stub function, not pushdown constraints, result)
--Testcase 2720:
SELECT timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub timediff(time, time) is called
CONTEXT:  PL/pgSQL function timediff(time without time zone,time without time zone) line 3 at RAISE
-- select timediff (stub function, pushdown constraints, explain)
--Testcase 2721:
EXPLAIN VERBOSE
SELECT timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.55 rows=2038 width=32)
   Output: timediff(c1, '12:12:12.051555'::time without time zone), timediff(c3, '1997-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select timediff (stub function, pushdown constraints, result)
--Testcase 2722:
SELECT timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub timediff(time, time) is called
CONTEXT:  PL/pgSQL function timediff(time without time zone,time without time zone) line 3 at RAISE
-- select timediff (stub function, timediff in constraints, explain)
--Testcase 2723:
EXPLAIN VERBOSE
SELECT timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl WHERE timediff(c1, '23:11:59.123456'::time) > '1 day 01:00:00'::interval;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..157.80 rows=683 width=32)
   Output: timediff(c1, '12:12:12.051555'::time without time zone), timediff(c3, '1997-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((timediff(`c1`, '23:11:59.123456') > '1 1:0:0.0'))
(4 rows)

-- select timediff (stub function, timediff in constraints, result)
--Testcase 2724:
SELECT timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl WHERE timediff(c1, '23:11:59.123456'::time) > '1 day 01:00:00'::interval;
 timediff | timediff 
----------+----------
(0 rows)

-- select timediff with agg (pushdown, explain)
--Testcase 2725:
EXPLAIN VERBOSE
SELECT max(c3), timediff('12:12:12.051555'::time, max(c1)), timediff('1997-01-01 12:00:00'::timestamp, max(c3)) FROM time_tbl;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (max(c3)), (timediff('12:12:12.051555'::time without time zone, max(c1))), (timediff('1997-01-01 12:00:00'::timestamp without time zone, max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), timediff('12:12:12.051555', max(`c1`)), timediff('1997-01-01 12:00:00', max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select timediff as nest function with agg (pushdown, result)
--Testcase 2726:
SELECT max(c3), timediff('12:12:12.051555'::time, max(c1)), timediff('1997-01-01 12:00:00'::timestamp, max(c3)) FROM time_tbl;
         max         |           timediff           |            timediff             
---------------------+------------------------------+---------------------------------
 2021-01-07 00:59:59 | @ 11 hours 0.948445 secs ago | @ 838 hours 59 mins 59 secs ago
(1 row)

-- select timediff with non pushdown func and explicit constant (explain)
--Testcase 2727:
EXPLAIN VERBOSE
SELECT timediff('12:12:12.051555'::time, max(c1)), timediff('1997-01-01 12:00:00'::timestamp, max(c3)), pi(), 4.1 FROM time_tbl;
                                                                                          QUERY PLAN                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=72)
   Output: (timediff('12:12:12.051555'::time without time zone, max(c1))), (timediff('1997-01-01 12:00:00'::timestamp without time zone, max(c3))), '3.141592653589793'::double precision, 4.1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT timediff('12:12:12.051555', max(`c1`)), timediff('1997-01-01 12:00:00', max(`c3`)), 3.141592653589793, 4.1 FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select timediff with non pushdown func and explicit constant (result)
--Testcase 2728:
SELECT timediff('12:12:12.051555'::time, max(c1)), timediff('1997-01-01 12:00:00'::timestamp, max(c3)), pi(), 4.1 FROM time_tbl;
           timediff           |            timediff             |        pi         | ?column? 
------------------------------+---------------------------------+-------------------+----------
 @ 11 hours 0.948445 secs ago | @ 838 hours 59 mins 59 secs ago | 3.141592653589793 |      4.1
(1 row)

-- select timediff with order by (explain)
--Testcase 2729:
EXPLAIN VERBOSE
SELECT id, timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl order by timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp);
                                                                                                                               QUERY PLAN                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=36)
   Output: id, timediff(c1, '12:12:12.051555'::time without time zone), timediff(c3, '1997-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY timediff(`c1`, '12:12:12.051555') IS NULL ASC, timediff(`c1`, '12:12:12.051555') ASC, timediff(`c3`, '1997-01-01 12:00:00') IS NULL ASC, timediff(`c3`, '1997-01-01 12:00:00') ASC
(4 rows)

-- select timediff with order by (result)
--Testcase 2730:
SELECT id, timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl order by timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp);
ERROR:  stub timediff(time, time) is called
CONTEXT:  PL/pgSQL function timediff(time without time zone,time without time zone) line 3 at RAISE
-- select timediff with order by index (result)
--Testcase 2731:
SELECT id, timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl order by 3,2,1;
ERROR:  stub timediff(time, time) is called
CONTEXT:  PL/pgSQL function timediff(time without time zone,time without time zone) line 3 at RAISE
-- select timediff with order by index (result)
--Testcase 2732:
SELECT id, timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl order by 1,2,3;
ERROR:  stub timediff(time, time) is called
CONTEXT:  PL/pgSQL function timediff(time without time zone,time without time zone) line 3 at RAISE
-- select timediff with group by (explain)
--Testcase 2733:
EXPLAIN VERBOSE
SELECT max(c3), timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl group by timediff('2080-01-01 12:00:00'::timestamp, c3), c1, c3;
                                                                                                           QUERY PLAN                                                                                                           
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=72)
   Output: (max(c3)), (timediff(c1, '12:12:12.051555'::time without time zone)), (timediff(c3, '1997-01-01 12:00:00'::timestamp without time zone)), (timediff('2080-01-01 12:00:00'::timestamp without time zone, c3)), c1, c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), timediff(`c1`, '12:12:12.051555'), timediff(`c3`, '1997-01-01 12:00:00'), timediff('2080-01-01 12:00:00', `c3`), `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 4, 5, 6
(5 rows)

-- select timediff with group by (result)
--Testcase 2734:
SELECT max(c3), timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl group by timediff('2080-01-01 12:00:00'::timestamp, c3), c1, c3;
         max         |               timediff                |          timediff           
---------------------+---------------------------------------+-----------------------------
 2021-01-03 12:10:30 | @ 1 min 42.051555 secs ago            | @ 838 hours 59 mins 59 secs
 2021-01-04 23:12:13 | @ 11 hours 0.948445 secs              | @ 838 hours 59 mins 59 secs
 2021-01-05 11:12:12 | @ 1 hour 0.051555 secs ago            | @ 838 hours 59 mins 59 secs
 2021-01-06 16:00:00 | @ 3 hours 47 mins 47.948445 secs      | @ 838 hours 59 mins 59 secs
 2021-01-07 00:59:59 | @ 11 hours 12 mins 13.051555 secs ago | @ 838 hours 59 mins 59 secs
(5 rows)

-- select timediff with group by index (result)
--Testcase 2735:
SELECT id, timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl group by 3,2,1;
 id |               timediff                |          timediff           
----+---------------------------------------+-----------------------------
  0 | @ 1 min 42.051555 secs ago            | @ 838 hours 59 mins 59 secs
  1 | @ 11 hours 0.948445 secs              | @ 838 hours 59 mins 59 secs
  2 | @ 1 hour 0.051555 secs ago            | @ 838 hours 59 mins 59 secs
  3 | @ 3 hours 47 mins 47.948445 secs      | @ 838 hours 59 mins 59 secs
  4 | @ 11 hours 12 mins 13.051555 secs ago | @ 838 hours 59 mins 59 secs
(5 rows)

-- select timediff with group by index (result)
--Testcase 2736:
SELECT id, timediff(c1, '12:12:12.051555'::time), timediff(c3, '1997-01-01 12:00:00'::timestamp) FROM time_tbl group by 1,2,3;
 id |               timediff                |          timediff           
----+---------------------------------------+-----------------------------
  0 | @ 1 min 42.051555 secs ago            | @ 838 hours 59 mins 59 secs
  1 | @ 11 hours 0.948445 secs              | @ 838 hours 59 mins 59 secs
  2 | @ 1 hour 0.051555 secs ago            | @ 838 hours 59 mins 59 secs
  3 | @ 3 hours 47 mins 47.948445 secs      | @ 838 hours 59 mins 59 secs
  4 | @ 11 hours 12 mins 13.051555 secs ago | @ 838 hours 59 mins 59 secs
(5 rows)

-- select timediff with group by index having (result)
--Testcase 2737:
SELECT id, timediff(c1, '12:12:12.051555'::time), c1 FROM time_tbl group by 3, 2, 1 HAVING timediff(c1, '12:12:12.051555'::time) < '1 days'::interval;
 id |               timediff                |    c1    
----+---------------------------------------+----------
  0 | @ 1 min 42.051555 secs ago            | 12:10:30
  2 | @ 1 hour 0.051555 secs ago            | 11:12:12
  3 | @ 3 hours 47 mins 47.948445 secs      | 16:00:00
  4 | @ 11 hours 12 mins 13.051555 secs ago | 00:59:59
(4 rows)

-- select timediff with group by index having (result)
--Testcase 2738:
SELECT id, timediff(c1, '12:12:12.051555'::time), c1 FROM time_tbl group by 1, 2, 3 HAVING timediff(c1, '12:12:12.051555'::time) < '1 days'::interval;
 id |               timediff                |    c1    
----+---------------------------------------+----------
  0 | @ 1 min 42.051555 secs ago            | 12:10:30
  2 | @ 1 hour 0.051555 secs ago            | 11:12:12
  3 | @ 3 hours 47 mins 47.948445 secs      | 16:00:00
  4 | @ 11 hours 12 mins 13.051555 secs ago | 00:59:59
(4 rows)

-- select timediff and as
--Testcase 2739:
SELECT timediff(c1, '12:12:12.051555'::time) as timediff1, timediff(c3, '1997-01-01 12:00:00'::timestamp) as timediff2 FROM time_tbl;
ERROR:  stub timediff(time, time) is called
CONTEXT:  PL/pgSQL function timediff(time without time zone,time without time zone) line 3 at RAISE
-- TIME_TO_SEC()
-- select time_to_sec (stub function, explain)
--Testcase 2740:
EXPLAIN VERBOSE
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..191.92 rows=2048 width=12)
   Output: time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select time_to_sec (stub function, result)
--Testcase 2741:
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl;
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- select time_to_sec (stub function, not pushdown constraints, explain)
--Testcase 2742:
EXPLAIN VERBOSE
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl WHERE to_hex(id) = '2';
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..141.02 rows=10 width=12)
   Output: time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time without time zone)
   Filter: (to_hex(time_tbl.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select time_to_sec (stub function, not pushdown constraints, result)
--Testcase 2743:
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl WHERE to_hex(id) = '2';
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- select time_to_sec (stub function, pushdown constraints, explain)
--Testcase 2744:
EXPLAIN VERBOSE
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl WHERE id != 200;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..196.74 rows=2038 width=12)
   Output: time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select time_to_sec (stub function, pushdown constraints, result)
--Testcase 2745:
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl WHERE id != 200;
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- select time_to_sec (stub function, time_to_sec in constraints, explain)
--Testcase 2746:
EXPLAIN VERBOSE
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl WHERE time_to_sec(c1) != 12345;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..201.86 rows=2038 width=12)
   Output: time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((time_to_sec(`c1`) <> 12345))
(4 rows)

-- select time_to_sec (stub function, time_to_sec in constraints, result)
--Testcase 2747:
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl WHERE time_to_sec(c1) != 12345;
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- select time_to_sec (stub function, time_to_sec in constraints, explain)
--Testcase 2748:
EXPLAIN VERBOSE
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl WHERE time_to_sec('06:05:04.030201'::time) > 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..161.21 rows=683 width=12)
   Output: time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((time_to_sec('06:05:04.030201') > 1))
(4 rows)

-- select time_to_sec (stub function, time_to_sec in constraints, result)
--Testcase 2749:
SELECT time_to_sec(c1), time_to_sec(mysql_time(c3)), time_to_sec('01:02:03.040505'::time) FROM time_tbl WHERE time_to_sec('06:05:04.030201'::time) > 1;
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- select time_to_sec with agg (pushdown, explain)
--Testcase 2750:
EXPLAIN VERBOSE
SELECT max(c3), time_to_sec(max(c1)) FROM time_tbl;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (time_to_sec(max(c1)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time_to_sec(max(`c1`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select time_to_sec as nest function with agg (pushdown, result)
--Testcase 2751:
SELECT max(c3), time_to_sec(max(c1)) FROM time_tbl;
         max         | time_to_sec 
---------------------+-------------
 2021-01-07 00:59:59 |       83533
(1 row)

-- select time_to_sec with non pushdown func and explicit constant (explain)
--Testcase 2752:
EXPLAIN VERBOSE
SELECT time_to_sec(mysql_time(c3)), pi(), 4.1 FROM time_tbl;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: time_to_sec(mysql_time(c3)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select time_to_sec with non pushdown func and explicit constant (result)
--Testcase 2753:
SELECT time_to_sec(mysql_time(c3)), pi(), 4.1 FROM time_tbl;
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select time_to_sec with order by (explain)
--Testcase 2754:
EXPLAIN VERBOSE
SELECT id, time_to_sec(c1) FROM time_tbl order by time_to_sec(c1);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=8)
   Output: id, time_to_sec(c1)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY time_to_sec(`c1`) IS NULL ASC, time_to_sec(`c1`) ASC
(4 rows)

-- select time_to_sec with order by (result)
--Testcase 2755:
SELECT id, time_to_sec(c1) FROM time_tbl order by time_to_sec(c1);
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- select time_to_sec with order by index (result)
--Testcase 2756:
SELECT id, time_to_sec(c1) FROM time_tbl order by 2,1;
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- select time_to_sec with order by index (result)
--Testcase 2757:
SELECT id, time_to_sec(c1) FROM time_tbl order by 1,2;
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- select time_to_sec with group by (explain)
--Testcase 2758:
EXPLAIN VERBOSE
SELECT max(c3), time_to_sec(c1) FROM time_tbl group by c1, time_to_sec('06:05:04.030201'::time);
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2048 width=24)
   Output: (max(c3)), (time_to_sec(c1)), c1, (time_to_sec('06:05:04.030201'::time without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time_to_sec(`c1`), `c1`, time_to_sec('06:05:04.030201') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 3, 4
(5 rows)

-- select time_to_sec with group by (result)
--Testcase 2759:
SELECT max(c3), time_to_sec(c1) FROM time_tbl group by c1, time_to_sec('06:05:04.030201'::time);
         max         | time_to_sec 
---------------------+-------------
 2021-01-03 12:10:30 |       43830
 2021-01-04 23:12:13 |       83533
 2021-01-05 11:12:12 |       40332
 2021-01-06 16:00:00 |       57600
 2021-01-07 00:59:59 |        3599
(5 rows)

-- select time_to_sec with group by index (result)
--Testcase 2760:
SELECT id, time_to_sec(c1) FROM time_tbl group by 2,1;
 id | time_to_sec 
----+-------------
  0 |       43830
  1 |       83533
  2 |       40332
  3 |       57600
  4 |        3599
(5 rows)

-- select time_to_sec with group by index (result)
--Testcase 2761:
SELECT id, time_to_sec(c1) FROM time_tbl group by 1,2;
 id | time_to_sec 
----+-------------
  0 |       43830
  1 |       83533
  2 |       40332
  3 |       57600
  4 |        3599
(5 rows)

-- select time_to_sec with group by having (explain)
--Testcase 2762:
EXPLAIN VERBOSE
SELECT max(c3), time_to_sec(c1), c1 FROM time_tbl group by time_to_sec(c1), c3, c1 HAVING time_to_sec(c1) > 100;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=68 width=28)
   Output: (max(c3)), (time_to_sec(c1)), c1, c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time_to_sec(`c1`), `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 4, 3 HAVING ((time_to_sec(`c1`) > 100))
(5 rows)

-- select time_to_sec with group by having (result)
--Testcase 2763:
SELECT max(c3), time_to_sec(c1), c1 FROM time_tbl group by time_to_sec(c1), c3, c1 HAVING time_to_sec(c1) > 100;
         max         | time_to_sec |    c1    
---------------------+-------------+----------
 2021-01-03 12:10:30 |       43830 | 12:10:30
 2021-01-04 23:12:13 |       83533 | 23:12:13
 2021-01-05 11:12:12 |       40332 | 11:12:12
 2021-01-06 16:00:00 |       57600 | 16:00:00
 2021-01-07 00:59:59 |        3599 | 00:59:59
(5 rows)

-- select time_to_sec with group by index having (result)
--Testcase 2764:
SELECT id, time_to_sec(c1), c1 FROM time_tbl group by 3, 2, 1 HAVING time_to_sec(c1) > 100;
 id | time_to_sec |    c1    
----+-------------+----------
  0 |       43830 | 12:10:30
  1 |       83533 | 23:12:13
  2 |       40332 | 11:12:12
  3 |       57600 | 16:00:00
  4 |        3599 | 00:59:59
(5 rows)

-- select time_to_sec with group by index having (result)
--Testcase 2765:
SELECT id, time_to_sec(c1), c1 FROM time_tbl group by 1, 2, 3 HAVING time_to_sec(c1) > 100;
 id | time_to_sec |    c1    
----+-------------+----------
  0 |       43830 | 12:10:30
  1 |       83533 | 23:12:13
  2 |       40332 | 11:12:12
  3 |       57600 | 16:00:00
  4 |        3599 | 00:59:59
(5 rows)

-- select time_to_sec and as
--Testcase 2766:
SELECT time_to_sec(c1) as time_to_sec1 FROM time_tbl;
ERROR:  stub time_to_sec(time) is called
CONTEXT:  PL/pgSQL function time_to_sec(time without time zone) line 3 at RAISE
-- TIME_FORMAT()
-- select time_format (stub function, explain)
--Testcase 2767:
EXPLAIN VERBOSE
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..191.92 rows=2048 width=96)
   Output: time_format(c1, '%H %k %h %I %l'::text), time_format(mysql_time(c3), '%H %k %h %I %l'::text), time_format('01:02:03.040505'::time without time zone, '%H %k %h %I %l'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select time_format (stub function, result)
--Testcase 2768:
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl;
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- select time_format (stub function, not pushdown constraints, explain)
--Testcase 2769:
EXPLAIN VERBOSE
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl WHERE to_hex(id) = '2';
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..141.02 rows=10 width=96)
   Output: time_format(c1, '%H %k %h %I %l'::text), time_format(mysql_time(c3), '%H %k %h %I %l'::text), time_format('01:02:03.040505'::time without time zone, '%H %k %h %I %l'::text)
   Filter: (to_hex(time_tbl.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select time_format (stub function, not pushdown constraints, result)
--Testcase 2770:
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl WHERE to_hex(id) = '2';
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- select time_format (stub function, pushdown constraints, explain)
--Testcase 2771:
EXPLAIN VERBOSE
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl WHERE id != 200;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..196.74 rows=2038 width=96)
   Output: time_format(c1, '%H %k %h %I %l'::text), time_format(mysql_time(c3), '%H %k %h %I %l'::text), time_format('01:02:03.040505'::time without time zone, '%H %k %h %I %l'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select time_format (stub function, pushdown constraints, result)
--Testcase 2772:
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl WHERE id != 200;
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- select time_format (stub function, time_format in constraints, explain)
--Testcase 2773:
EXPLAIN VERBOSE
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl WHERE time_format(c1, '%H %k %h %I %l') != '100 100 04 04 4';
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..201.86 rows=2038 width=96)
   Output: time_format(c1, '%H %k %h %I %l'::text), time_format(mysql_time(c3), '%H %k %h %I %l'::text), time_format('01:02:03.040505'::time without time zone, '%H %k %h %I %l'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((time_format(`c1`, '%H %k %h %I %l') <> '100 100 04 04 4'))
(4 rows)

-- select time_format (stub function, time_format in constraints, result)
--Testcase 2774:
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl WHERE time_format(c1, '%H %k %h %I %l') != '100 100 04 04 4';
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- select time_format (stub function, time_format in constraints, explain)
--Testcase 2775:
EXPLAIN VERBOSE
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl WHERE time_format(c1, '%H %k %h %I %l') = '12 12 12 12 12';
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..141.02 rows=10 width=96)
   Output: time_format(c1, '%H %k %h %I %l'::text), time_format(mysql_time(c3), '%H %k %h %I %l'::text), time_format('01:02:03.040505'::time without time zone, '%H %k %h %I %l'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((time_format(`c1`, '%H %k %h %I %l') = '12 12 12 12 12'))
(4 rows)

-- select time_format (stub function, time_format in constraints, result)
--Testcase 2776:
SELECT time_format(c1, '%H %k %h %I %l'), time_format(mysql_time(c3), '%H %k %h %I %l'), time_format('01:02:03.040505'::time, '%H %k %h %I %l') FROM time_tbl WHERE time_format(c1, '%H %k %h %I %l') = '12 12 12 12 12';
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- select time_format with agg (pushdown, explain)
--Testcase 2777:
EXPLAIN VERBOSE
SELECT max(c3), time_format(max(c1), '%H %k %h %I %l') FROM time_tbl;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (max(c3)), (time_format(max(c1), '%H %k %h %I %l'::text))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time_format(max(`c1`), '%H %k %h %I %l') FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select time_format as nest function with agg (pushdown, result)
--Testcase 2778:
SELECT max(c3), time_format(max(c1), '%H %k %h %I %l') FROM time_tbl;
         max         |  time_format   
---------------------+----------------
 2021-01-07 00:59:59 | 23 23 11 11 11
(1 row)

-- select time_format with non pushdown func and explicit constant (explain)
--Testcase 2779:
EXPLAIN VERBOSE
SELECT time_format(mysql_time(c3), '%H %k %h %I %l'), pi(), 4.1 FROM time_tbl;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=72)
   Output: time_format(mysql_time(c3), '%H %k %h %I %l'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select time_format with non pushdown func and explicit constant (result)
--Testcase 2780:
SELECT time_format(mysql_time(c3), '%H %k %h %I %l'), pi(), 4.1 FROM time_tbl;
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select time_format with order by (explain)
--Testcase 2781:
EXPLAIN VERBOSE
SELECT id, time_format(c1, '%H %k %h %I %l') FROM time_tbl order by time_format(c1, '%H %k %h %I %l');
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=36)
   Output: id, time_format(c1, '%H %k %h %I %l'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY time_format(`c1`, '%H %k %h %I %l') IS NULL ASC, time_format(`c1`, '%H %k %h %I %l') ASC
(4 rows)

-- select time_format with order by (result)
--Testcase 2782:
SELECT id, time_format(c1, '%H %k %h %I %l') FROM time_tbl order by time_format(c1, '%H %k %h %I %l');
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- select time_format with order by index (result)
--Testcase 2783:
SELECT id, time_format(c1, '%H %k %h %I %l') FROM time_tbl order by 2,1;
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- select time_format with order by index (result)
--Testcase 2784:
SELECT id, time_format(c1, '%H %k %h %I %l') FROM time_tbl order by 1,2;
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- select time_format with group by (explain)
--Testcase 2785:
EXPLAIN VERBOSE
SELECT max(c3), time_format(c1, '%H %k %h %I %l') FROM time_tbl group by c1, time_format('06:05:04.030201'::time, '%H %k %h %I %l');
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2048 width=80)
   Output: (max(c3)), (time_format(c1, '%H %k %h %I %l'::text)), c1, (time_format('06:05:04.030201'::time without time zone, '%H %k %h %I %l'::text))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time_format(`c1`, '%H %k %h %I %l'), `c1`, time_format('06:05:04.030201', '%H %k %h %I %l') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 3, 4
(5 rows)

-- select time_format with group by (result)
--Testcase 2786:
SELECT max(c3), time_format(c1, '%H %k %h %I %l') FROM time_tbl group by c1, time_format('06:05:04.030201'::time, '%H %k %h %I %l');
         max         |  time_format   
---------------------+----------------
 2021-01-03 12:10:30 | 12 12 12 12 12
 2021-01-04 23:12:13 | 23 23 11 11 11
 2021-01-05 11:12:12 | 11 11 11 11 11
 2021-01-06 16:00:00 | 16 16 04 04 4
 2021-01-07 00:59:59 | 00 0 12 12 12
(5 rows)

-- select time_format with group by index (result)
--Testcase 2787:
SELECT id, time_format(c1, '%H %k %h %I %l') FROM time_tbl group by 2,1;
 id |  time_format   
----+----------------
  0 | 12 12 12 12 12
  1 | 23 23 11 11 11
  2 | 11 11 11 11 11
  3 | 16 16 04 04 4
  4 | 00 0 12 12 12
(5 rows)

-- select time_format with group by index (result)
--Testcase 2788:
SELECT id, time_format(c1, '%H %k %h %I %l') FROM time_tbl group by 1,2;
 id |  time_format   
----+----------------
  0 | 12 12 12 12 12
  1 | 23 23 11 11 11
  2 | 11 11 11 11 11
  3 | 16 16 04 04 4
  4 | 00 0 12 12 12
(5 rows)

-- select time_format with group by having (explain)
--Testcase 2789:
EXPLAIN VERBOSE
SELECT max(c3), time_format(c1, '%H %k %h %I %l') FROM time_tbl group by time_format(c1, '%H %k %h %I %l'), c3, c1 HAVING time_format(c1, '%H %k %h %I %l') != '100 100 04 04 4';
                                                                                                 QUERY PLAN                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=204 width=56)
   Output: (max(c3)), (time_format(c1, '%H %k %h %I %l'::text)), c3, c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time_format(`c1`, '%H %k %h %I %l'), `c3`, `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 4 HAVING ((time_format(`c1`, '%H %k %h %I %l') <> '100 100 04 04 4'))
(5 rows)

-- select time_format with group by having (result)
--Testcase 2790:
SELECT max(c3), time_format(c1, '%H %k %h %I %l') FROM time_tbl group by time_format(c1, '%H %k %h %I %l'), c3, c1 HAVING time_format(c1, '%H %k %h %I %l') != '100 100 04 04 4';
         max         |  time_format   
---------------------+----------------
 2021-01-03 12:10:30 | 12 12 12 12 12
 2021-01-04 23:12:13 | 23 23 11 11 11
 2021-01-05 11:12:12 | 11 11 11 11 11
 2021-01-06 16:00:00 | 16 16 04 04 4
 2021-01-07 00:59:59 | 00 0 12 12 12
(5 rows)

-- select time_format with group by index having (result)
--Testcase 2791:
SELECT id, c1, time_format(c1, '%H %k %h %I %l'), c3 FROM time_tbl group by 4, 3, 2, 1 HAVING time_format(c1, '%H %k %h %I %l') != '100 100 04 04 4';
 id |    c1    |  time_format   |         c3          
----+----------+----------------+---------------------
  0 | 12:10:30 | 12 12 12 12 12 | 2021-01-03 12:10:30
  1 | 23:12:13 | 23 23 11 11 11 | 2021-01-04 23:12:13
  2 | 11:12:12 | 11 11 11 11 11 | 2021-01-05 11:12:12
  3 | 16:00:00 | 16 16 04 04 4  | 2021-01-06 16:00:00
  4 | 00:59:59 | 00 0 12 12 12  | 2021-01-07 00:59:59
(5 rows)

-- select time_format with group by index having (result)
--Testcase 2792:
SELECT id, c1, time_format(c1, '%H %k %h %I %l'), c3 FROM time_tbl group by 1, 2, 3, 4 HAVING time_format(c1, '%H %k %h %I %l') != '100 100 04 04 4';
 id |    c1    |  time_format   |         c3          
----+----------+----------------+---------------------
  0 | 12:10:30 | 12 12 12 12 12 | 2021-01-03 12:10:30
  1 | 23:12:13 | 23 23 11 11 11 | 2021-01-04 23:12:13
  2 | 11:12:12 | 11 11 11 11 11 | 2021-01-05 11:12:12
  3 | 16:00:00 | 16 16 04 04 4  | 2021-01-06 16:00:00
  4 | 00:59:59 | 00 0 12 12 12  | 2021-01-07 00:59:59
(5 rows)

-- select time_format and as
--Testcase 2793:
SELECT time_format(c1, '%H %k %h %I %l') as time_format1 FROM time_tbl;
ERROR:  stub time_format(time, text) is called
CONTEXT:  PL/pgSQL function time_format(time without time zone,text) line 3 at RAISE
-- TIME()
-- select mysql_time (stub function, explain)
--Testcase 2794:
EXPLAIN VERBOSE
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00') FROM time_tbl;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=32)
   Output: mysql_time(c3), mysql_time((c2)::timestamp without time zone), mysql_time(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), mysql_time('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_time (stub function, result)
--Testcase 2795:
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00') FROM time_tbl;
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select mysql_time (stub function, not pushdown constraints, explain)
--Testcase 2796:
EXPLAIN VERBOSE
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00') FROM time_tbl WHERE to_hex(id) = '0';
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=32)
   Output: mysql_time(c3), mysql_time((c2)::timestamp without time zone), mysql_time(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), mysql_time('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_time (stub function, not pushdown constraints, result)
--Testcase 2797:
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00') FROM time_tbl WHERE to_hex(id) = '0';
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select mysql_time (stub function, pushdown constraints, explain)
--Testcase 2798:
EXPLAIN VERBOSE
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00') FROM time_tbl WHERE id != 200;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=32)
   Output: mysql_time(c3), mysql_time((c2)::timestamp without time zone), mysql_time(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), mysql_time('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select mysql_time (stub function, pushdown constraints, result)
--Testcase 2799:
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00') FROM time_tbl WHERE id != 200;
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select mysql_time (stub function, mysql_time in constraints, explain)
--Testcase 2800:
EXPLAIN VERBOSE
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE mysql_time(c3) != '06:05:04.030201'::time;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..223.36 rows=2264 width=32)
   Output: mysql_time(c3), mysql_time((c2)::timestamp without time zone), mysql_time(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), mysql_time('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((time(`c3`) <> '06:05:04.030201'))
(4 rows)

-- select mysql_time (stub function, mysql_time in constraints, result)
--Testcase 2801:
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE mysql_time(c3) != '06:05:04.030201'::time;
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select mysql_time (stub function, mysql_time in constraints, explain)
--Testcase 2802:
EXPLAIN VERBOSE
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE mysql_time('2021-01-01 12:00:00'::timestamp) > '06:05:04.030201'::time;
                                                                                                   QUERY PLAN                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=32)
   Output: mysql_time(c3), mysql_time((c2)::timestamp without time zone), mysql_time(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), mysql_time('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((time('2021-01-01 12:00:00') > '06:05:04.030201'))
(4 rows)

-- select mysql_time (stub function, mysql_time in constraints, result)
--Testcase 2803:
SELECT mysql_time(c3), mysql_time(c2), mysql_time(date_sub(c3, '1 12:59:10')), mysql_time('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE mysql_time('2021-01-01 12:00:00'::timestamp) > '06:05:04.030201'::time;
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select mysql_time with agg (pushdown, explain)
--Testcase 2804:
EXPLAIN VERBOSE
SELECT max(c3), mysql_time(max(c3)) FROM time_tbl;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c3)), (mysql_time(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_time as nest function with agg (pushdown, result)
--Testcase 2805:
SELECT max(c3), mysql_time(max(c3)) FROM time_tbl;
         max         | mysql_time 
---------------------+------------
 2021-01-07 00:59:59 | 00:59:59
(1 row)

-- select mysql_time with non pushdown func and explicit constant (explain)
--Testcase 2806:
EXPLAIN VERBOSE
SELECT mysql_time(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=48)
   Output: mysql_time(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_time with non pushdown func and explicit constant (result)
--Testcase 2807:
SELECT mysql_time(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select mysql_time with order by (explain)
--Testcase 2808:
EXPLAIN VERBOSE
SELECT id, mysql_time(c3 + '1 12:59:10') FROM time_tbl order by mysql_time(c3 + '1 12:59:10');
                                                                                                                                      QUERY PLAN                                                                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: id, mysql_time((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY time((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, time((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select mysql_time with order by (result)
--Testcase 2809:
SELECT id, mysql_time(c3 + '1 12:59:10') FROM time_tbl order by mysql_time(c3 + '1 12:59:10');
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select mysql_time with order by index (result)
--Testcase 2810:
SELECT id, mysql_time(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select mysql_time with order by index (result)
--Testcase 2811:
SELECT id, mysql_time(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub mysql_time(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_time(timestamp without time zone) line 3 at RAISE
-- select mysql_time with group by (explain)
--Testcase 2812:
EXPLAIN VERBOSE
SELECT max(c3), mysql_time(c3 + '1 12:59:10') FROM time_tbl group by mysql_time(c3 + '1 12:59:10');
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (max(c3)), (mysql_time((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_time with group by (result)
--Testcase 2813:
SELECT max(c3), mysql_time(c3 + '1 12:59:10') FROM time_tbl group by mysql_time(c3 + '1 12:59:10');
         max         | mysql_time 
---------------------+------------
 2021-01-03 12:10:30 | 01:09:40
 2021-01-04 23:12:13 | 12:11:23
 2021-01-05 11:12:12 | 00:11:22
 2021-01-06 16:00:00 | 04:59:10
 2021-01-07 00:59:59 | 13:59:09
(5 rows)

-- select mysql_time with group by index (result)
--Testcase 2814:
SELECT id, mysql_time(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | mysql_time 
----+------------
  0 | 01:09:40
  1 | 12:11:23
  2 | 00:11:22
  3 | 04:59:10
  4 | 13:59:09
(5 rows)

-- select mysql_time with group by index (result)
--Testcase 2815:
SELECT id, mysql_time(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | mysql_time 
----+------------
  0 | 01:09:40
  1 | 12:11:23
  2 | 00:11:22
  3 | 04:59:10
  4 | 13:59:09
(5 rows)

-- select mysql_time with group by having (explain)
--Testcase 2816:
EXPLAIN VERBOSE
SELECT max(c3), mysql_time(c3 + '1 12:59:10') FROM time_tbl group by mysql_time(c3 + '1 12:59:10'), c3 HAVING mysql_time(c3 + '1 12:59:10') > '06:05:04.030201'::time;
                                                                                                                                                   QUERY PLAN                                                                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=24)
   Output: (max(c3)), (mysql_time((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), time((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((time((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) > '06:05:04.030201'))
(5 rows)

-- select mysql_time with group by having (result)
--Testcase 2817:
SELECT max(c3), mysql_time(c3 + '1 12:59:10') FROM time_tbl group by mysql_time(c3 + '1 12:59:10'), c3 HAVING mysql_time(c3 + '1 12:59:10') > '06:05:04.030201'::time;
         max         | mysql_time 
---------------------+------------
 2021-01-04 23:12:13 | 12:11:23
 2021-01-07 00:59:59 | 13:59:09
(2 rows)

-- select mysql_time with group by index having (result)
--Testcase 2818:
SELECT id, mysql_time(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING mysql_time(c3 + '1 12:59:10') > '06:05:04.030201'::time;
 id | mysql_time |         c3          
----+------------+---------------------
  1 | 12:11:23   | 2021-01-04 23:12:13
  4 | 13:59:09   | 2021-01-07 00:59:59
(2 rows)

-- select mysql_time with group by index having (result)
--Testcase 2819:
SELECT id, mysql_time(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING mysql_time(c3 + '1 12:59:10') > '06:05:04.030201'::time;
 id | mysql_time |         c3          
----+------------+---------------------
  1 | 12:11:23   | 2021-01-04 23:12:13
  4 | 13:59:09   | 2021-01-07 00:59:59
(2 rows)

-- select mysql_time and as
--Testcase 2820:
SELECT mysql_time(date_sub(c3, '1 12:59:10')) as mysql_time1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- SYSDATE()
-- select sysdate (stub function, explain)
--Testcase 2821:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..237.99 rows=3413 width=4)
   Output: datediff(sysdate(), sysdate())
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select sysdate (stub function, result)
--Testcase 2822:
SELECT datediff(sysdate(), sysdate()) FROM time_tbl;
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- select sysdate (stub function, not pushdown constraints, explain)
--Testcase 2823:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()) FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..192.49 rows=1138 width=4)
   Output: datediff(sysdate(), sysdate())
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select sysdate (stub function, not pushdown constraints, result)
--Testcase 2824:
SELECT datediff(sysdate(), sysdate()) FROM time_tbl WHERE to_hex(id) > '0';
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- select sysdate (stub function, pushdown constraints, explain)
--Testcase 2825:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()) FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.13 rows=17 width=4)
   Output: datediff(sysdate(), sysdate())
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select sysdate (stub function, pushdown constraints, result)
--Testcase 2826:
SELECT datediff(sysdate(), sysdate()) FROM time_tbl WHERE id = 1;
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- select sysdate (stub function, sysdate in constraints, explain)
--Testcase 2827:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()) FROM time_tbl WHERE sysdate() > '1997-10-14 00:00:00'::timestamp;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..192.49 rows=1138 width=4)
   Output: datediff(sysdate(), sysdate())
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((sysdate() > '1997-10-14 00:00:00'))
(4 rows)

-- select sysdate (stub function, sysdate in constraints, result)
--Testcase 2828:
SELECT datediff(sysdate(), sysdate()) FROM time_tbl WHERE sysdate() > '1997-10-14 00:00:00'::timestamp;
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- sysdate in constrains (stub function, explain)
--Testcase 2829:
EXPLAIN VERBOSE
SELECT id, c1 FROM time_tbl WHERE sysdate() > '1997-10-14 00:00:00'::timestamp;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..159.29 rows=758 width=12)
   Output: id, c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((sysdate() > '1997-10-14 00:00:00'))
(4 rows)

-- sysdate in constrains (stub function, result)
--Testcase 2830:
SELECT id, c1 FROM time_tbl WHERE sysdate() > '1997-10-14 00:00:00'::timestamp;
 id |    c1    
----+----------
  0 | 12:10:30
  1 | 23:12:13
  2 | 11:12:12
  3 | 16:00:00
  4 | 00:59:59
(5 rows)

-- sysdate as parameter of addtime(stub function, explain)
--Testcase 2831:
EXPLAIN VERBOSE
SELECT id, c1 FROM time_tbl WHERE addtime(sysdate(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..164.97 rows=758 width=12)
   Output: id, c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(sysdate(), '1 12:59:10.0') > '1997-10-14 00:00:00'))
(4 rows)

-- sysdate as parameter of addtime(stub function, result)
--Testcase 2832:
SELECT id, c1 FROM time_tbl WHERE addtime(sysdate(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp;
 id |    c1    
----+----------
  0 | 12:10:30
  1 | 23:12:13
  2 | 11:12:12
  3 | 16:00:00
  4 | 00:59:59
(5 rows)

-- select sysdate and agg (pushdown, explain)
--Testcase 2833:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()), sum(id) FROM time_tbl;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (datediff(sysdate(), sysdate())), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT datediff(sysdate(), sysdate()), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select sysdate and agg (pushdown, result)
--Testcase 2834:
SELECT datediff(sysdate(), sysdate()), sum(id) FROM time_tbl;
 datediff | sum 
----------+-----
        0 |  10
(1 row)

-- select sysdate and log2 (pushdown, explain)
--Testcase 2835:
EXPLAIN VERBOSE
SELECT id, datediff(sysdate(), sysdate()), log2(id) FROM time_tbl;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..234.31 rows=2925 width=16)
   Output: id, datediff(sysdate(), sysdate()), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select sysdate and log2 (pushdown, result)
--Testcase 2836:
SELECT id, datediff(sysdate(), sysdate()), log2(id) FROM time_tbl;
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- select sysdate with non pushdown func and explicit constant (explain)
--Testcase 2837:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..227.00 rows=2925 width=40)
   Output: datediff(sysdate(), sysdate()), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select sysdate with non pushdown func and explicit constant (result)
--Testcase 2838:
SELECT datediff(sysdate(), sysdate()), to_hex(id), 4 FROM time_tbl;
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- select sysdate with order by (explain)
--Testcase 2839:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()), c1 FROM time_tbl ORDER BY datediff(sysdate(), sysdate()),c1;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=12)
   Output: datediff(sysdate(), sysdate()), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY datediff(sysdate(), sysdate()) IS NULL ASC, datediff(sysdate(), sysdate()) ASC, `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select sysdate with order by (result)
--Testcase 2840:
SELECT datediff(sysdate(), sysdate()), c1 FROM time_tbl ORDER BY datediff(sysdate(), sysdate()),c1;
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- select sysdate with order by index (explain)
--Testcase 2841:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()), c1 FROM time_tbl ORDER BY 1,2;
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=12)
   Output: datediff(sysdate(), sysdate()), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY datediff(sysdate(), sysdate()) IS NULL ASC, datediff(sysdate(), sysdate()) ASC, `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select sysdate with order by index (result)
--Testcase 2842:
SELECT datediff(sysdate(), sysdate()), c1 FROM time_tbl ORDER BY 1,2;
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- sysdate constraints with order by (explain)
--Testcase 2843:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(sysdate(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp ORDER BY c1;
                                                                                QUERY PLAN                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(sysdate(), '1 12:59:10.0') > '1997-10-14 00:00:00')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- sysdate constraints with order by (result)
--Testcase 2844:
SELECT c1 FROM time_tbl WHERE addtime(sysdate(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select sysdate with group by (explain)
--Testcase 2845:
EXPLAIN VERBOSE
SELECT id, datediff(sysdate(), sysdate()), c1 FROM time_tbl GROUP BY id,datediff(sysdate(), sysdate()),c1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2275 width=16)
   Output: id, (datediff(sysdate(), sysdate())), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `id`, datediff(sysdate(), sysdate()), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3
(5 rows)

-- select sysdate with group by (result)
--Testcase 2846:
SELECT id, datediff(sysdate(), sysdate()), c1 FROM time_tbl GROUP BY id,datediff(sysdate(), sysdate()),c1;
 id | datediff |    c1    
----+----------+----------
  0 |        0 | 12:10:30
  1 |        0 | 23:12:13
  2 |        0 | 11:12:12
  3 |        0 | 16:00:00
  4 |        0 | 00:59:59
(5 rows)

-- select sysdate with group by index (explain)
--Testcase 2847:
EXPLAIN VERBOSE
SELECT id, datediff(sysdate(), sysdate()), c1 FROM time_tbl GROUP BY 1,2,3;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2275 width=16)
   Output: id, (datediff(sysdate(), sysdate())), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `id`, datediff(sysdate(), sysdate()), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3
(5 rows)

-- select sysdate with group by index (result)
--Testcase 2848:
SELECT id, datediff(sysdate(), sysdate()), c1 FROM time_tbl GROUP BY 1,2,3;
 id | datediff |    c1    
----+----------+----------
  0 |        0 | 12:10:30
  1 |        0 | 23:12:13
  2 |        0 | 11:12:12
  3 |        0 | 16:00:00
  4 |        0 | 00:59:59
(5 rows)

-- select sysdate with group by having (explain)
--Testcase 2849:
EXPLAIN VERBOSE
SELECT id, datediff(sysdate(), sysdate()), c1 FROM time_tbl GROUP BY datediff(sysdate(), sysdate()),c1,id HAVING datediff(sysdate(), sysdate()) >= 0;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=758 width=16)
   Output: id, (datediff(sysdate(), sysdate())), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `id`, datediff(sysdate(), sysdate()), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 1 HAVING ((datediff(sysdate(), sysdate()) >= 0))
(5 rows)

-- select sysdate with group by having (result)
--Testcase 2850:
SELECT id, datediff(sysdate(), sysdate()), c1 FROM time_tbl GROUP BY datediff(sysdate(), sysdate()),c1,id HAVING datediff(sysdate(), sysdate()) >= 0;
 id | datediff |    c1    
----+----------+----------
  0 |        0 | 12:10:30
  1 |        0 | 23:12:13
  2 |        0 | 11:12:12
  3 |        0 | 16:00:00
  4 |        0 | 00:59:59
(5 rows)

-- select sysdate with group by index having (explain)
--Testcase 2851:
EXPLAIN VERBOSE
SELECT id, datediff(sysdate(), sysdate()), c1 FROM time_tbl GROUP BY 3,2,1 HAVING datediff(sysdate(), sysdate()) >= 0;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=758 width=16)
   Output: id, (datediff(sysdate(), sysdate())), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `id`, datediff(sysdate(), sysdate()), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 3, 2, 1 HAVING ((datediff(sysdate(), sysdate()) >= 0))
(5 rows)

-- select sysdate with group by index having (result)
--Testcase 2852:
SELECT id, datediff(sysdate(), sysdate()), c1 FROM time_tbl GROUP BY 3,2,1 HAVING datediff(sysdate(), sysdate()) >= 0;
 id | datediff |    c1    
----+----------+----------
  0 |        0 | 12:10:30
  1 |        0 | 23:12:13
  2 |        0 | 11:12:12
  3 |        0 | 16:00:00
  4 |        0 | 00:59:59
(5 rows)

-- sysdate constraints with group by (explain)
--Testcase 2853:
EXPLAIN VERBOSE
SELECT id, c1 FROM time_tbl WHERE addtime(sysdate(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp GROUP BY id,c1;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=224 width=12)
   Output: id, c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(sysdate(), '1 12:59:10.0') > '1997-10-14 00:00:00')) GROUP BY 1, 2
(5 rows)

-- sysdate constraints with group by (result)
--Testcase 2854:
SELECT id, c1 FROM time_tbl WHERE addtime(sysdate(), '1 12:59:10'::interval) > '1997-10-14 00:00:00'::timestamp GROUP BY id,c1;
 id |    c1    
----+----------
  0 | 12:10:30
  1 | 23:12:13
  2 | 11:12:12
  3 | 16:00:00
  4 | 00:59:59
(5 rows)

-- select sysdate and as (explain)
--Testcase 2855:
EXPLAIN VERBOSE
SELECT datediff(sysdate(), sysdate()) as sysdate1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..237.99 rows=3413 width=4)
   Output: datediff(sysdate(), sysdate())
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select sysdate and as (result)
--Testcase 2856:
SELECT datediff(sysdate(), sysdate()) as sysdate1 FROM time_tbl;
ERROR:  stub sysdate() is called
CONTEXT:  PL/pgSQL function sysdate() line 3 at RAISE
-- SUBTIME()
-- select subtime (stub function, explain)
--Testcase 2857:
EXPLAIN VERBOSE
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl;
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..218.80 rows=2560 width=48)
   Output: subtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), subtime(c3, '@ 6 mons 2 hours 30 mins'::interval), subtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), subtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select subtime (stub function, result)
--Testcase 2858:
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl;
ERROR:  stub subtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subtime(timestamp without time zone,interval) line 3 at RAISE
-- select subtime (stub function, not pushdown constraints, explain)
--Testcase 2859:
EXPLAIN VERBOSE
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.82 rows=13 width=48)
   Output: subtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), subtime(c3, '@ 6 mons 2 hours 30 mins'::interval), subtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), subtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select subtime (stub function, not pushdown constraints, result)
--Testcase 2860:
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub subtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subtime(timestamp without time zone,interval) line 3 at RAISE
-- select subtime (stub function, pushdown constraints, explain)
--Testcase 2861:
EXPLAIN VERBOSE
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE id != 0;
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..224.78 rows=2547 width=48)
   Output: subtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), subtime(c3, '@ 6 mons 2 hours 30 mins'::interval), subtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), subtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select subtime (stub function, pushdown constraints, result)
--Testcase 2862:
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE id != 0;
ERROR:  stub subtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subtime(timestamp without time zone,interval) line 3 at RAISE
-- select subtime (stub function, subtime in constraints, explain)
--Testcase 2863:
EXPLAIN VERBOSE
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE subtime(c3, '1 12:59:10') != '2000-01-01';
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..231.18 rows=2547 width=48)
   Output: subtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), subtime(c3, '@ 6 mons 2 hours 30 mins'::interval), subtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), subtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((subtime(`c3`, '1 12:59:10.0') <> '2000-01-01 00:00:00'))
(4 rows)

-- select subtime (stub function, subtime in constraints, result)
--Testcase 2864:
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE subtime(c3, '1 12:59:10') != '2000-01-01';
ERROR:  stub subtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subtime(timestamp without time zone,interval) line 3 at RAISE
-- select subtime (stub function, subtime in constraints, explain)
--Testcase 2865:
EXPLAIN VERBOSE
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') > '-902:00:49'::interval;
                                                                                                                                                                 QUERY PLAN                                                                                                                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..176.12 rows=853 width=48)
   Output: subtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval), subtime(c3, '@ 6 mons 2 hours 30 mins'::interval), subtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), subtime('@ 1 day 12 hours 59 mins 10 secs'::interval, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((subtime('1 12:59:10.0', '180 2:30:0.0') > '0 -902:0:-49.0'))
(4 rows)

-- select subtime (stub function, subtime in constraints, result)
--Testcase 2866:
SELECT subtime(c3, '1 12:59:10'), subtime(c3, INTERVAL '6 months 2 hours 30 minutes'), subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') > '-902:00:49'::interval;
 subtime | subtime | subtime | subtime 
---------+---------+---------+---------
(0 rows)

-- select subtime with agg (pushdown, explain)
--Testcase 2867:
EXPLAIN VERBOSE
SELECT max(c1), subtime(max(c1), '1 12:59:10'::interval) FROM time_tbl;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=24)
   Output: (max(c1)), (subtime((max(c1))::interval, '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c1`), subtime(max(`c1`), '1 12:59:10.0') FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select subtime as nest function with agg (pushdown, result)
--Testcase 2868:
SELECT max(c1), subtime(max(c1), '1 12:59:10'::interval) FROM time_tbl;
   max    |            subtime             
----------+--------------------------------
 23:12:13 | @ 13 hours 46 mins 57 secs ago
(1 row)

-- select subtime as nest with stub (pushdown, explain)
--Testcase 2869:
EXPLAIN VERBOSE
SELECT subtime(mysql_timestamp(c2), '1 12:59:10'::interval) FROM time_tbl;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=8)
   Output: subtime(mysql_timestamp((c2)::timestamp without time zone), '@ 1 day 12 hours 59 mins 10 secs'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select subtime as nest with stub (pushdown, result)
--Testcase 2870:
SELECT subtime(mysql_timestamp(c2), '1 12:59:10'::interval) FROM time_tbl;
ERROR:  stub mysql_timestamp(timestamp) is called
CONTEXT:  PL/pgSQL function mysql_timestamp(timestamp without time zone) line 3 at RAISE
-- select subtime with non pushdown func and explicit constant (explain)
--Testcase 2871:
EXPLAIN VERBOSE
SELECT subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), pi(), 4.1 FROM time_tbl;
                                                                                  QUERY PLAN                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=56)
   Output: subtime(timediff(c3, '2008-01-01 00:00:00.000001'::timestamp without time zone), '@ 6 mons 2 hours 30 mins'::interval), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select subtime with non pushdown func and explicit constant (result)
--Testcase 2872:
SELECT subtime(timediff(c3, '2008-01-01 00:00:00.000001'), INTERVAL '6 months 2 hours 30 minutes'), pi(), 4.1 FROM time_tbl;
ERROR:  stub timediff(timestamp, timestamp) is called
CONTEXT:  PL/pgSQL function timediff(timestamp without time zone,timestamp without time zone) line 3 at RAISE
-- select subtime with order by (explain)
--Testcase 2873:
EXPLAIN VERBOSE
SELECT id, subtime(c1, c1 + '1 12:59:10') FROM time_tbl order by subtime(c1, c1 + '1 12:59:10');
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=20)
   Output: id, subtime(c1, (c1 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY subtime(`c1`, (`c1` + '1 12:59:10.0')) IS NULL ASC, subtime(`c1`, (`c1` + '1 12:59:10.0')) ASC
(4 rows)

-- select subtime with order by (result)
--Testcase 2874:
SELECT id, subtime(c1, c1 + '1 12:59:10') FROM time_tbl order by subtime(c1, c1 + '1 12:59:10');
ERROR:  stub subtime(time, time) is called
CONTEXT:  PL/pgSQL function subtime(time without time zone,time without time zone) line 3 at RAISE
-- select subtime with order by index (result)
--Testcase 2875:
SELECT id, subtime(c1, c1 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub subtime(time, time) is called
CONTEXT:  PL/pgSQL function subtime(time without time zone,time without time zone) line 3 at RAISE
-- select subtime with order by index (result)
--Testcase 2876:
SELECT id, subtime(c1, c1 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub subtime(time, time) is called
CONTEXT:  PL/pgSQL function subtime(time without time zone,time without time zone) line 3 at RAISE
-- select subtime with group by (explain)
--Testcase 2877:
EXPLAIN VERBOSE
SELECT count(id), subtime(c1, c1 + '1 12:59:10') FROM time_tbl group by subtime(c1, c1 + '1 12:59:10');
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=24)
   Output: (count(id)), (subtime(c1, (c1 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), subtime(`c1`, (`c1` + '1 12:59:10.0')) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select subtime with group by (result)
--Testcase 2878:
SELECT count(id), subtime(c1, c1 + '1 12:59:10') FROM time_tbl group by subtime(c1, c1 + '1 12:59:10');
 count |   subtime   
-------+-------------
     4 | @ 1 sec ago
     1 | 
(2 rows)

-- select subtime with group by index (result)
--Testcase 2879:
SELECT id, subtime(c1, c1 + '1 12:59:10') FROM time_tbl group by 2,1;
 id |   subtime   
----+-------------
  0 | @ 1 sec ago
  1 | @ 1 sec ago
  2 | @ 1 sec ago
  3 | @ 1 sec ago
  4 | 
(5 rows)

-- select subtime with group by index (result)
--Testcase 2880:
SELECT id, subtime(c1, c1 + '1 12:59:10') FROM time_tbl group by 1,2;
 id |   subtime   
----+-------------
  0 | @ 1 sec ago
  1 | @ 1 sec ago
  2 | @ 1 sec ago
  3 | @ 1 sec ago
  4 | 
(5 rows)

-- select subtime with group by having (explain)
--Testcase 2881:
EXPLAIN VERBOSE
SELECT count(id), subtime(c3, '1 12:59:10') FROM time_tbl group by subtime(c3, '1 12:59:10'), c3 HAVING subtime(c3, '1 12:59:10') < '2080-01-01'::timestamp;
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=24)
   Output: (count(id)), (subtime(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), subtime(`c3`, '1 12:59:10.0'), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((subtime(`c3`, '1 12:59:10.0') < '2080-01-01 00:00:00'))
(5 rows)

-- select subtime with group by having (result)
--Testcase 2882:
SELECT count(id), subtime(c3, '1 12:59:10') FROM time_tbl group by subtime(c3, '1 12:59:10'), c3 HAVING subtime(c3, '1 12:59:10') < '2080-01-01'::timestamp;
 count |       subtime       
-------+---------------------
     1 | 2021-01-01 23:11:20
     1 | 2021-01-03 10:13:03
     1 | 2021-01-03 22:13:02
     1 | 2021-01-05 03:00:50
     1 | 2021-01-05 12:00:49
(5 rows)

-- select subtime and as
--Testcase 2883:
SELECT subtime(c3, '1 12:59:10') as subtime1, subtime(c3, INTERVAL '6 months 2 hours 30 minutes') as subtime2, subtime(timediff(c3, '2008-01-01 00:00:00.000001') , INTERVAL '6 months 2 hours 30 minutes') as subtime3, subtime('1 12:59:10', INTERVAL '6 months 2 hours 30 minutes') as subtime4 FROM time_tbl;
ERROR:  stub subtime(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subtime(timestamp without time zone,interval) line 3 at RAISE
-- SUBDATE()
-- select subdate (stub function, explain)
--Testcase 2884:
EXPLAIN VERBOSE
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..195.31 rows=2275 width=16)
   Output: subdate((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), subdate(c3, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select subdate (stub function, result)
--Testcase 2885:
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl;
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate (stub function, not pushdown constraints, explain)
--Testcase 2886:
EXPLAIN VERBOSE
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE to_hex(id) = '1';
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.43 rows=11 width=16)
   Output: subdate((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), subdate(c3, '@ 6 mons 2 hours 30 mins'::interval)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select subdate (stub function, not pushdown constraints, result)
--Testcase 2887:
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate (stub function, pushdown constraints, explain)
--Testcase 2888:
EXPLAIN VERBOSE
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE id != 0;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..200.70 rows=2264 width=16)
   Output: subdate((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), subdate(c3, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select subdate (stub function, pushdown constraints, result)
--Testcase 2889:
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE id != 0;
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate (stub function, subdate in constraints, explain)
--Testcase 2890:
EXPLAIN VERBOSE
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE subdate(c3, '1 12:59:10') != '2000-01-01';
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.38 rows=2264 width=16)
   Output: subdate((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), subdate(c3, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((subdate(`c3`, INTERVAL '1 12:59:10.0' DAY_MICROSECOND) <> '2000-01-01 00:00:00'))
(4 rows)

-- select subdate (stub function, subdate in constraints, result)
--Testcase 2891:
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE subdate(c3, '1 12:59:10') != '2000-01-01';
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate (stub function, subdate in constraints, explain)
--Testcase 2892:
EXPLAIN VERBOSE
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE subdate(c2, INTERVAL '6 months 2 hours 30 minutes') > '2008-01-01 00:00:00.000001'::timestamp;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=16)
   Output: subdate((c2)::timestamp without time zone, '@ 1 day 12 hours 59 mins 10 secs'::interval), subdate(c3, '@ 6 mons 2 hours 30 mins'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((subdate(`c2`, INTERVAL '180 2:30:0.0' DAY_MICROSECOND) > '2008-01-01 00:00:00.000001'))
(4 rows)

-- select subdate (stub function, subdate in constraints, result)
--Testcase 2893:
SELECT subdate(c2, '1 12:59:10'), subdate(c3, INTERVAL '6 months 2 hours 30 minutes') FROM time_tbl WHERE subdate(c2, INTERVAL '6 months 2 hours 30 minutes') > '2008-01-01 00:00:00.000001'::timestamp;
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate with agg (pushdown, explain)
--Testcase 2894:
EXPLAIN VERBOSE
SELECT max(c1), subdate(max(c3), '1 12:59:10'::interval) FROM time_tbl;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c1)), (subdate(max(c3), '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c1`), subdate(max(`c3`), INTERVAL '1 12:59:10.0' DAY_MICROSECOND) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select subdate as nest function with agg (pushdown, result)
--Testcase 2895:
SELECT max(c1), subdate(max(c3), '1 12:59:10'::interval) FROM time_tbl;
   max    |       subdate       
----------+---------------------
 23:12:13 | 2021-01-05 12:00:49
(1 row)

-- select subdate as nest with stub (pushdown, explain)
--Testcase 2896:
EXPLAIN VERBOSE
SELECT subdate(adddate(c3, INTERVAL '6 months 2 hours 30 minutes'), '1 12:59:10'::interval) FROM time_tbl;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=8)
   Output: subdate(adddate(c3, '@ 6 mons 2 hours 30 mins'::interval), '@ 1 day 12 hours 59 mins 10 secs'::interval)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select subdate as nest with stub (pushdown, result)
--Testcase 2897:
SELECT subdate(adddate(c3, INTERVAL '6 months 2 hours 30 minutes'), '1 12:59:10'::interval) FROM time_tbl;
ERROR:  stub adddate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate with non pushdown func and explicit constant (explain)
--Testcase 2898:
EXPLAIN VERBOSE
SELECT subdate(adddate(c3, INTERVAL '6 months 2 hours 30 minutes'), INTERVAL '6 months 2 hours 30 minutes'), pi(), 4.1 FROM time_tbl;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=48)
   Output: subdate(adddate(c3, '@ 6 mons 2 hours 30 mins'::interval), '@ 6 mons 2 hours 30 mins'::interval), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select subdate with non pushdown func and explicit constant (result)
--Testcase 2899:
SELECT subdate(adddate(c3, INTERVAL '6 months 2 hours 30 minutes'), INTERVAL '6 months 2 hours 30 minutes'), pi(), 4.1 FROM time_tbl;
ERROR:  stub adddate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function adddate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate with order by (explain)
--Testcase 2900:
EXPLAIN VERBOSE
SELECT id, subdate(c3, '1 12:59:10'::interval) FROM time_tbl order by subdate(c3, '1 12:59:10'::interval);
                                                                                                  QUERY PLAN                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=12)
   Output: id, subdate(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY subdate(`c3`, INTERVAL '1 12:59:10.0' DAY_MICROSECOND) IS NULL ASC, subdate(`c3`, INTERVAL '1 12:59:10.0' DAY_MICROSECOND) ASC
(4 rows)

-- select subdate with order by (result)
--Testcase 2901:
SELECT id, subdate(c3, '1 12:59:10'::interval) FROM time_tbl order by subdate(c3, '1 12:59:10'::interval);
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate with order by index (result)
--Testcase 2902:
SELECT id, subdate(c3, '1 12:59:10'::interval) FROM time_tbl order by 2,1;
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate with order by index (result)
--Testcase 2903:
SELECT id, subdate(c3, '1 12:59:10'::interval) FROM time_tbl order by 1,2;
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- select subdate with group by (explain)
--Testcase 2904:
EXPLAIN VERBOSE
SELECT count(id), subdate(c3, '1 12:59:10'::interval) FROM time_tbl group by subdate(c3, '1 12:59:10'::interval);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (count(id)), (subdate(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), subdate(`c3`, INTERVAL '1 12:59:10.0' DAY_MICROSECOND) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select subdate with group by (result)
--Testcase 2905:
SELECT count(id), subdate(c3, '1 12:59:10'::interval) FROM time_tbl group by subdate(c3, '1 12:59:10'::interval);
 count |       subdate       
-------+---------------------
     1 | 2021-01-01 23:11:20
     1 | 2021-01-03 10:13:03
     1 | 2021-01-03 22:13:02
     1 | 2021-01-05 03:00:50
     1 | 2021-01-05 12:00:49
(5 rows)

-- select subdate with group by index (result)
--Testcase 2906:
SELECT id, subdate(c3, '1 12:59:10'::interval) FROM time_tbl group by 2,1;
 id |       subdate       
----+---------------------
  0 | 2021-01-01 23:11:20
  1 | 2021-01-03 10:13:03
  2 | 2021-01-03 22:13:02
  3 | 2021-01-05 03:00:50
  4 | 2021-01-05 12:00:49
(5 rows)

-- select subdate with group by index (result)
--Testcase 2907:
SELECT id, subdate(c3, '1 12:59:10'::interval) FROM time_tbl group by 1,2;
 id |       subdate       
----+---------------------
  0 | 2021-01-01 23:11:20
  1 | 2021-01-03 10:13:03
  2 | 2021-01-03 22:13:02
  3 | 2021-01-05 03:00:50
  4 | 2021-01-05 12:00:49
(5 rows)

-- select subdate with group by having (explain)
--Testcase 2908:
EXPLAIN VERBOSE
SELECT count(id), subdate(c3, '1 12:59:10') FROM time_tbl group by subdate(c3, '1 12:59:10'), c3 HAVING subdate(c3, '1 12:59:10') < '2080-01-01'::timestamp;
                                                                                                                  QUERY PLAN                                                                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=24)
   Output: (count(id)), (subdate(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), subdate(`c3`, INTERVAL '1 12:59:10.0' DAY_MICROSECOND), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((subdate(`c3`, INTERVAL '1 12:59:10.0' DAY_MICROSECOND) < '2080-01-01 00:00:00'))
(5 rows)

-- select subdate with group by having (result)
--Testcase 2909:
SELECT count(id), subdate(c3, '1 12:59:10') FROM time_tbl group by subdate(c3, '1 12:59:10'), c3 HAVING subdate(c3, '1 12:59:10') < '2080-01-01'::timestamp;
 count |       subdate       
-------+---------------------
     1 | 2021-01-01 23:11:20
     1 | 2021-01-03 10:13:03
     1 | 2021-01-03 22:13:02
     1 | 2021-01-05 03:00:50
     1 | 2021-01-05 12:00:49
(5 rows)

-- select subdate and as
--Testcase 2910:
SELECT subdate(c3, '1 12:59:10') as subdate1, subdate(c3, INTERVAL '6 months 2 hours 30 minutes') as subdate2 FROM time_tbl;
ERROR:  stub subdate(timestamp, interval) is called
CONTEXT:  PL/pgSQL function subdate(timestamp without time zone,interval) line 3 at RAISE
-- STR_TO_DATE()
-- select str_to_date (stub function, explain)
--Testcase 2911:
EXPLAIN VERBOSE
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..184.44 rows=1861 width=24)
   Output: str_to_date(c1, '%H:%i:%s'::text), str_to_date((c2)::timestamp without time zone, '%Y-%m-%d'::text), str_to_date(c3, '%Y-%m-%d %H:%i:%s'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select str_to_date (stub function, explain)
--Testcase 2912:
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl;
ERROR:  stub str_to_date(time, text) is called
CONTEXT:  PL/pgSQL function str_to_date(time without time zone,text) line 3 at RAISE
-- select str_to_date (stub function, not pushdown constraints, explain)
--Testcase 2913:
EXPLAIN VERBOSE
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl WHERE to_hex(id) = '1';
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..138.19 rows=9 width=24)
   Output: str_to_date(c1, '%H:%i:%s'::text), str_to_date((c2)::timestamp without time zone, '%Y-%m-%d'::text), str_to_date(c3, '%Y-%m-%d %H:%i:%s'::text)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select str_to_date (stub function, not pushdown constraints, result)
--Testcase 2914:
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub str_to_date(time, text) is called
CONTEXT:  PL/pgSQL function str_to_date(time without time zone,text) line 3 at RAISE
-- select str_to_date (stub function, pushdown constraints, explain)
--Testcase 2915:
EXPLAIN VERBOSE
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl WHERE id != 200;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..188.82 rows=1852 width=24)
   Output: str_to_date(c1, '%H:%i:%s'::text), str_to_date((c2)::timestamp without time zone, '%Y-%m-%d'::text), str_to_date(c3, '%Y-%m-%d %H:%i:%s'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select str_to_date (stub function, pushdown constraints, result)
--Testcase 2916:
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl WHERE id != 200;
ERROR:  stub str_to_date(time, text) is called
CONTEXT:  PL/pgSQL function str_to_date(time without time zone,text) line 3 at RAISE
-- select str_to_date (stub function, year in constraints, explain)
--Testcase 2917:
EXPLAIN VERBOSE
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl WHERE str_to_date(c1, '%H:%i:%s') > '02:00:00'::time;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..156.51 rows=620 width=24)
   Output: str_to_date(c1, '%H:%i:%s'::text), str_to_date((c2)::timestamp without time zone, '%Y-%m-%d'::text), str_to_date(c3, '%Y-%m-%d %H:%i:%s'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((str_to_date(`c1`, '%H:%i:%s') > '02:00:00'))
(4 rows)

-- select str_to_date (stub function, year in constraints, result)
--Testcase 2918:
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl WHERE str_to_date(c1, '%H:%i:%s') > '02:00:00'::time;
ERROR:  stub str_to_date(time, text) is called
CONTEXT:  PL/pgSQL function str_to_date(time without time zone,text) line 3 at RAISE
-- select str_to_date with agg (pushdown, explain)
--Testcase 2919:
EXPLAIN VERBOSE
SELECT max(c3), str_to_date(max(c1), '%H:%i:%s') FROM time_tbl;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c3)), (str_to_date(max(c1), '%H:%i:%s'::text))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), str_to_date(max(`c1`), '%H:%i:%s') FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select str_to_date as nest function with agg (pushdown, result)
--Testcase 2920:
SELECT max(c3), str_to_date(max(c1), '%H:%i:%s') FROM time_tbl;
         max         | str_to_date 
---------------------+-------------
 2021-01-07 00:59:59 | 23:12:13
(1 row)

-- select str_to_date with non pushdown func and explicit constant (explain)
--Testcase 2921:
EXPLAIN VERBOSE
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s'), pi(), 4.1 FROM time_tbl;
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..184.44 rows=1861 width=64)
   Output: str_to_date(c1, '%H:%i:%s'::text), str_to_date((c2)::timestamp without time zone, '%Y-%m-%d'::text), str_to_date(c3, '%Y-%m-%d %H:%i:%s'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- -- select str_to_date with non pushdown func and explicit constant (result)
--Testcase 2922:
SELECT str_to_date(c1, '%H:%i:%s'), str_to_date(c2, '%Y-%m-%d'), str_to_date(c3, '%Y-%m-%d %H:%i:%s'), pi(), 4.1 FROM time_tbl;
ERROR:  stub str_to_date(time, text) is called
CONTEXT:  PL/pgSQL function str_to_date(time without time zone,text) line 3 at RAISE
-- select str_to_date with order by (explain)
--Testcase 2923:
EXPLAIN VERBOSE
SELECT id, str_to_date(c1, '%H:%i:%s'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl order by str_to_date(c1, '%H:%i:%s'), str_to_date(c3, '%Y-%m-%d %H:%i:%s');
                                                                                                                            QUERY PLAN                                                                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=20)
   Output: id, str_to_date(c1, '%H:%i:%s'::text), str_to_date(c3, '%Y-%m-%d %H:%i:%s'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY str_to_date(`c1`, '%H:%i:%s') IS NULL ASC, str_to_date(`c1`, '%H:%i:%s') ASC, str_to_date(`c3`, '%Y-%m-%d %H:%i:%s') IS NULL ASC, str_to_date(`c3`, '%Y-%m-%d %H:%i:%s') ASC
(4 rows)

-- select str_to_date with order by (result)
--Testcase 2924:
SELECT id, str_to_date(c1, '%H:%i:%s'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl order by str_to_date(c1, '%H:%i:%s'), str_to_date(c3, '%Y-%m-%d %H:%i:%s');
ERROR:  stub str_to_date(time, text) is called
CONTEXT:  PL/pgSQL function str_to_date(time without time zone,text) line 3 at RAISE
-- select str_to_date with order by index (result)
--Testcase 2925:
SELECT id, str_to_date(c1, '%H:%i:%s'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl order by 3,2,1;
ERROR:  stub str_to_date(time, text) is called
CONTEXT:  PL/pgSQL function str_to_date(time without time zone,text) line 3 at RAISE
-- select str_to_date with order by index (result)
--Testcase 2926:
SELECT id, str_to_date(c1, '%H:%i:%s'), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl order by 1,2,3;
ERROR:  stub str_to_date(time, text) is called
CONTEXT:  PL/pgSQL function str_to_date(time without time zone,text) line 3 at RAISE
-- select str_to_date with group by (explain)
--Testcase 2927:
EXPLAIN VERBOSE
SELECT max(c1), str_to_date(c1, '%H:%i:%s') FROM time_tbl group by str_to_date(c1, '%H:%i:%s');
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (max(c1)), (str_to_date(c1, '%H:%i:%s'::text))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c1`), str_to_date(`c1`, '%H:%i:%s') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select str_to_date with group by (result)
--Testcase 2928:
SELECT max(c3), str_to_date(c1, '%H:%i:%s') FROM time_tbl group by str_to_date(c1, '%H:%i:%s');
         max         | str_to_date 
---------------------+-------------
 2021-01-03 12:10:30 | 12:10:30
 2021-01-04 23:12:13 | 23:12:13
 2021-01-05 11:12:12 | 11:12:12
 2021-01-06 16:00:00 | 16:00:00
 2021-01-07 00:59:59 | 00:59:59
(5 rows)

-- select str_to_date with group by index (result)
--Testcase 2929:
SELECT id, str_to_date(c1, '%H:%i:%s') FROM time_tbl group by 2,1;
 id | str_to_date 
----+-------------
  0 | 12:10:30
  1 | 23:12:13
  2 | 11:12:12
  3 | 16:00:00
  4 | 00:59:59
(5 rows)

-- select str_to_date with group by index (result)
--Testcase 2930:
SELECT id, str_to_date(c1, '%H:%i:%s') FROM time_tbl group by 1,2;
 id | str_to_date 
----+-------------
  0 | 12:10:30
  1 | 23:12:13
  2 | 11:12:12
  3 | 16:00:00
  4 | 00:59:59
(5 rows)

-- select str_to_date with group by having (explain)
--Testcase 2931:
EXPLAIN VERBOSE
SELECT max(c3), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl group by str_to_date(c3, '%Y-%m-%d %H:%i:%s'),c3 HAVING str_to_date(c3, '%Y-%m-%d %H:%i:%s') < '2021-01-03 13:00:00'::timestamp;
                                                                                                 QUERY PLAN                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=24)
   Output: (max(c3)), (str_to_date(c3, '%Y-%m-%d %H:%i:%s'::text)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), str_to_date(`c3`, '%Y-%m-%d %H:%i:%s'), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((str_to_date(`c3`, '%Y-%m-%d %H:%i:%s') < '2021-01-03 13:00:00'))
(5 rows)

-- select str_to_date with group by having (result)
--Testcase 2932:
SELECT max(c3), str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl group by str_to_date(c3, '%Y-%m-%d %H:%i:%s'),c3 HAVING str_to_date(c3, '%Y-%m-%d %H:%i:%s') < '2021-01-03 13:00:00'::timestamp;
         max         |     str_to_date     
---------------------+---------------------
 2021-01-03 12:10:30 | 2021-01-03 12:10:30
(1 row)

-- select str_to_date with group by index having (result)
--Testcase 2933:
SELECT id, str_to_date(c3, '%Y-%m-%d %H:%i:%s') FROM time_tbl group by 1, 2 HAVING id > 1;
 id |     str_to_date     
----+---------------------
  2 | 2021-01-05 11:12:12
  3 | 2021-01-06 16:00:00
  4 | 2021-01-07 00:59:59
(3 rows)

-- SECOND()
-- select second (stub function, explain)
--Testcase 2934:
EXPLAIN VERBOSE
SELECT second(c1), second(c3) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..181.68 rows=2048 width=8)
   Output: second(c1), second(c3)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

--Testcase 2935:
SELECT second(c1), second(c3) FROM time_tbl;
ERROR:  stub second(time) is called
CONTEXT:  PL/pgSQL function second(time without time zone) line 3 at RAISE
-- select second (stub function, not pushdown constraints, explain)
--Testcase 2936:
EXPLAIN VERBOSE
SELECT second(c1), second(c3) FROM time_tbl WHERE to_hex(id) > '0';
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..157.80 rows=683 width=8)
   Output: second(c1), second(c3)
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

--Testcase 2937:
SELECT second(c1), second(c3) FROM time_tbl WHERE to_hex(id) > '0';
ERROR:  stub second(time) is called
CONTEXT:  PL/pgSQL function second(time without time zone) line 3 at RAISE
-- select second (stub function, pushdown constraints, explain)
--Testcase 2938:
EXPLAIN VERBOSE
SELECT second(c1), second(c3) FROM time_tbl WHERE id = 1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..135.85 rows=10 width=8)
   Output: second(c1), second(c3)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

--Testcase 2939:
SELECT second(c1), second(c3) FROM time_tbl WHERE id = 1;
ERROR:  stub second(time) is called
CONTEXT:  PL/pgSQL function second(time without time zone) line 3 at RAISE
-- select second (stub function, second in constraints, explain)
--Testcase 2940:
EXPLAIN VERBOSE
SELECT second(c1), second(c3) FROM time_tbl WHERE second(c2) < second(c3);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..168.04 rows=683 width=8)
   Output: second(c1), second(c3)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((second(`c2`) < second(`c3`)))
(4 rows)

--Testcase 2941:
SELECT second(c1), second(c3) FROM time_tbl WHERE second(c2) < second(c3);
ERROR:  stub second(time) is called
CONTEXT:  PL/pgSQL function second(time without time zone) line 3 at RAISE
-- second in constrains (stub function, explain)
--Testcase 2942:
EXPLAIN VERBOSE
SELECT second(c1), second(c3) FROM time_tbl WHERE second(c2) < id;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..162.92 rows=683 width=8)
   Output: second(c1), second(c3)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((second(`c2`) < `id`))
(4 rows)

-- second in constrains (stub function, result)
--Testcase 2943:
SELECT second(c1), second(c3) FROM time_tbl WHERE second(c2) < id;
ERROR:  stub second(time) is called
CONTEXT:  PL/pgSQL function second(time without time zone) line 3 at RAISE
-- select second as nest function with agg (pushdown, explain)
--Testcase 2944:
EXPLAIN VERBOSE
SELECT max(c1), second(max(c3)) FROM time_tbl;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c1)), (second(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c1`), second(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select second as nest function with agg (pushdown, result)
--Testcase 2945:
SELECT max(c1), second(max(c3)) FROM time_tbl;
   max    | second 
----------+--------
 23:12:13 |     59
(1 row)

-- select second and agg (pushdown, explain)
--Testcase 2946:
EXPLAIN VERBOSE
SELECT second('1997-10-14 00:01:01'::timestamp), second('00:01:59'::time), sum(id) FROM time_tbl;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (second('1997-10-14 00:01:01'::timestamp without time zone)), (second('00:01:59'::time without time zone)), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT second('1997-10-14 00:01:01'), second('00:01:59'), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select second and log2 (pushdown, explain)
--Testcase 2947:
EXPLAIN VERBOSE
SELECT second('1997-10-14 00:01:01'::timestamp), second('00:01:59'::time), log2(id) FROM time_tbl;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..227.00 rows=2925 width=16)
   Output: second('1997-10-14 00:01:01'::timestamp without time zone), second('00:01:59'::time without time zone), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select second with non pushdown func and explicit constant (explain)
--Testcase 2948:
EXPLAIN VERBOSE
SELECT second('1997-10-14 00:00:00'::timestamp), second('00:01:59'::time), to_hex(id), 4 FROM time_tbl;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=44)
   Output: second('1997-10-14 00:00:00'::timestamp without time zone), second('00:01:59'::time without time zone), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select second with order by (explain)
--Testcase 2949:
EXPLAIN VERBOSE
SELECT second(c1), second(c3), c1 FROM time_tbl ORDER BY c1;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=16)
   Output: (second(c1)), (second(c3)), c1
   Local server startup cost: 10
   Remote query: SELECT second(`c1`), second(`c3`), `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- select second with order by index (result)
--Testcase 2950:
SELECT second(c1), second(c3), c1 FROM time_tbl ORDER BY 1,2;
ERROR:  stub second(time) is called
CONTEXT:  PL/pgSQL function second(time without time zone) line 3 at RAISE
-- second constraints with order by (explain)
--Testcase 2951:
EXPLAIN VERBOSE
SELECT second(c1), second(c3) FROM time_tbl WHERE second('2020-10-14 00:39:05'::timestamp) > second('1997-10-14 00:00:00'::timestamp) ORDER BY second(c1), second(c3);
                                                                                                                  QUERY PLAN                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: second(c1), second(c3)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((second('2020-10-14 00:39:05') > second('1997-10-14 00:00:00'))) ORDER BY second(`c1`) IS NULL ASC, second(`c1`) ASC, second(`c3`) IS NULL ASC, second(`c3`) ASC
(4 rows)

-- second constraints with order by (result)
--Testcase 2952:
SELECT second(c1), second(c3) FROM time_tbl WHERE second('2020-10-14 00:39:05'::timestamp) > second('1997-10-14 00:00:00'::timestamp) ORDER BY second(c1), second(c3);
ERROR:  stub second(time) is called
CONTEXT:  PL/pgSQL function second(time without time zone) line 3 at RAISE
-- select second with group by (explain)
--Testcase 2953:
EXPLAIN VERBOSE
SELECT second(c1), second(c3), c1 FROM time_tbl GROUP BY c1,c3;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=24)
   Output: (second(c1)), (second(c3)), c1, c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT second(`c1`), second(`c3`), `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 3, 4
(5 rows)

-- select second with group by index (explain)
--Testcase 2954:
EXPLAIN VERBOSE
SELECT second(c1), second(c3), c1 FROM time_tbl GROUP BY 1,2,3;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=205 width=16)
   Output: (second(c1)), (second(c3)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT second(`c1`), second(`c3`), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3
(5 rows)

-- select second with group by having (explain)
--Testcase 2955:
EXPLAIN VERBOSE
SELECT second(c1), c1 FROM time_tbl GROUP BY second(c1),c1 HAVING second(c1) > 1;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (second(c1)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT second(`c1`), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((second(`c1`) > 1))
(5 rows)

-- select second with group by index having (result)
--Testcase 2956:
SELECT second(c1), c1 FROM time_tbl GROUP BY second(c1),c1 HAVING second(c1) > 1;
 second |    c1    
--------+----------
     30 | 12:10:30
     13 | 23:12:13
     12 | 11:12:12
     59 | 00:59:59
(4 rows)

-- select second and as
--Testcase 2957:
EXPLAIN VERBOSE
SELECT second(c1) as second1, second(c3) as second2 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..181.68 rows=2048 width=8)
   Output: second(c1), second(c3)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- SEC_TO_TIME()
-- select sec_to_time (stub function, explain)
--Testcase 2958:
EXPLAIN VERBOSE
SELECT sec_to_time(id) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..205.06 rows=2925 width=8)
   Output: sec_to_time(id)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

--Testcase 2959:
SELECT sec_to_time(id) FROM time_tbl;
ERROR:  stub sec_to_time(int) is called
CONTEXT:  PL/pgSQL function sec_to_time(integer) line 3 at RAISE
-- select sec_to_time (stub function, not pushdown constraints, explain)
--Testcase 2960:
EXPLAIN VERBOSE
SELECT sec_to_time(id) FROM time_tbl WHERE to_hex(id) > '0';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..175.81 rows=975 width=8)
   Output: sec_to_time(id)
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

--Testcase 2961:
SELECT sec_to_time(id) FROM time_tbl WHERE to_hex(id) > '0';
ERROR:  stub sec_to_time(int) is called
CONTEXT:  PL/pgSQL function sec_to_time(integer) line 3 at RAISE
-- select sec_to_time (stub function, pushdown constraints, explain)
--Testcase 2962:
EXPLAIN VERBOSE
SELECT sec_to_time(id) FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..146.90 rows=15 width=8)
   Output: sec_to_time(id)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

--Testcase 2963:
SELECT sec_to_time(id) FROM time_tbl WHERE id = 1;
ERROR:  stub sec_to_time(int) is called
CONTEXT:  PL/pgSQL function sec_to_time(integer) line 3 at RAISE
-- select sec_to_time (stub function, sec_to_time in constraints, explain)
--Testcase 2964:
EXPLAIN VERBOSE
SELECT sec_to_time(id) FROM time_tbl WHERE sec_to_time(id) < c1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..175.81 rows=975 width=8)
   Output: sec_to_time(id)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((sec_to_time(`id`) < `c1`))
(4 rows)

--Testcase 2965:
SELECT sec_to_time(id) FROM time_tbl WHERE sec_to_time(id) < c1;
ERROR:  stub sec_to_time(int) is called
CONTEXT:  PL/pgSQL function sec_to_time(integer) line 3 at RAISE
-- sec_to_time in constrains (stub function, explain)
--Testcase 2966:
EXPLAIN VERBOSE
SELECT sec_to_time(id) FROM time_tbl WHERE sec_to_time(id) < c1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..175.81 rows=975 width=8)
   Output: sec_to_time(id)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((sec_to_time(`id`) < `c1`))
(4 rows)

-- sec_to_time in constrains (stub function, result)
--Testcase 2967:
SELECT sec_to_time(id) FROM time_tbl WHERE sec_to_time(id) < c1;
ERROR:  stub sec_to_time(int) is called
CONTEXT:  PL/pgSQL function sec_to_time(integer) line 3 at RAISE
-- select sec_to_time as nest function with agg (pushdown, explain)
--Testcase 2968:
EXPLAIN VERBOSE
SELECT max(c1), sec_to_time(max(id)) FROM time_tbl;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c1)), (sec_to_time(max(id)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c1`), sec_to_time(max(`id`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select sec_to_time as nest function with agg (pushdown, result)
--Testcase 2969:
SELECT max(c1), sec_to_time(max(id)) FROM time_tbl;
   max    | sec_to_time 
----------+-------------
 23:12:13 | 00:00:04
(1 row)

-- select sec_to_time and agg (pushdown, explain)
--Testcase 2970:
EXPLAIN VERBOSE
SELECT max(id), sec_to_time(max(id)) FROM time_tbl;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(id)), (sec_to_time(max(id)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`id`), sec_to_time(max(`id`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select sec_to_time and log2 (pushdown, explain)
--Testcase 2971:
EXPLAIN VERBOSE
SELECT sec_to_time(id), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: sec_to_time(id), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select sec_to_time with non pushdown func and explicit constant (explain)
--Testcase 2972:
EXPLAIN VERBOSE
SELECT sec_to_time(id), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: sec_to_time(id), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select sec_to_time with order by (explain)
--Testcase 2973:
EXPLAIN VERBOSE
SELECT sec_to_time(id), c1 FROM time_tbl ORDER BY sec_to_time(id);
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: sec_to_time(id), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY sec_to_time(`id`) IS NULL ASC, sec_to_time(`id`) ASC
(4 rows)

-- select sec_to_time with order by index (result)
--Testcase 2974:
SELECT sec_to_time(id), c1 FROM time_tbl ORDER BY 1;
ERROR:  stub sec_to_time(int) is called
CONTEXT:  PL/pgSQL function sec_to_time(integer) line 3 at RAISE
-- sec_to_time constraints with order by (explain)
--Testcase 2975:
EXPLAIN VERBOSE
SELECT sec_to_time(id) FROM time_tbl WHERE sec_to_time(id) < c1 ORDER BY 1;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=8)
   Output: sec_to_time(id)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((sec_to_time(`id`) < `c1`)) ORDER BY sec_to_time(`id`) IS NULL ASC, sec_to_time(`id`) ASC
(4 rows)

-- sec_to_time constraints with order by (result)
--Testcase 2976:
SELECT sec_to_time(id) FROM time_tbl WHERE sec_to_time(id) < c1 ORDER BY sec_to_time(id);
ERROR:  stub sec_to_time(int) is called
CONTEXT:  PL/pgSQL function sec_to_time(integer) line 3 at RAISE
-- select sec_to_time with group by (explain)
--Testcase 2977:
EXPLAIN VERBOSE
SELECT sec_to_time(id), c1 FROM time_tbl GROUP BY id,c1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=20)
   Output: (sec_to_time(id)), c1, id
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT sec_to_time(`id`), `c1`, `id` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 3, 2
(5 rows)

-- select sec_to_time with group by index (explain)
--Testcase 2978:
EXPLAIN VERBOSE
SELECT sec_to_time(id), c1 FROM time_tbl GROUP BY 1,2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=16)
   Output: (sec_to_time(id)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT sec_to_time(`id`), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2
(5 rows)

-- select sec_to_time with group by having (explain)
--Testcase 2979:
EXPLAIN VERBOSE
SELECT sec_to_time(id), c1 FROM time_tbl GROUP BY sec_to_time(id), id, c1 HAVING sec_to_time(id) < c1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=76 width=20)
   Output: (sec_to_time(id)), c1, id
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT sec_to_time(`id`), `c1`, `id` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 3, 2 HAVING ((sec_to_time(`id`) < `c1`))
(5 rows)

-- select sec_to_time with group by index having (result)
--Testcase 2980:
SELECT sec_to_time(id), c1 FROM time_tbl GROUP BY sec_to_time(id), id, c1 HAVING sec_to_time(id) < c1;
 sec_to_time |    c1    
-------------+----------
 00:00:00    | 12:10:30
 00:00:01    | 23:12:13
 00:00:02    | 11:12:12
 00:00:03    | 16:00:00
 00:00:04    | 00:59:59
(5 rows)

-- select sec_to_time and as
--Testcase 2981:
EXPLAIN VERBOSE
SELECT sec_to_time(id) as sec_to_time1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..205.06 rows=2925 width=8)
   Output: sec_to_time(id)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- QUARTER()
-- select quarter (stub function, explain)
--Testcase 2982:
EXPLAIN VERBOSE
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=128)
   Output: quarter(c3), quarter((c2)::timestamp without time zone), quarter(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), quarter('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select quarter (stub function, result)
--Testcase 2983:
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub quarter(timestamp) is called
CONTEXT:  PL/pgSQL function quarter(timestamp without time zone) line 3 at RAISE
-- select quarter (stub function, not pushdown constraints, explain)
--Testcase 2984:
EXPLAIN VERBOSE
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=128)
   Output: quarter(c3), quarter((c2)::timestamp without time zone), quarter(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), quarter('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select quarter (stub function, not pushdown constraints, result)
--Testcase 2985:
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub quarter(timestamp) is called
CONTEXT:  PL/pgSQL function quarter(timestamp without time zone) line 3 at RAISE
-- select quarter (stub function, pushdown constraints, explain)
--Testcase 2986:
EXPLAIN VERBOSE
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=128)
   Output: quarter(c3), quarter((c2)::timestamp without time zone), quarter(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), quarter('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select quarter (stub function, pushdown constraints, result)
--Testcase 2987:
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub quarter(timestamp) is called
CONTEXT:  PL/pgSQL function quarter(timestamp without time zone) line 3 at RAISE
-- select quarter (stub function, quarter in constraints, explain)
--Testcase 2988:
EXPLAIN VERBOSE
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE quarter(c3) = quarter('2000-01-01'::timestamp);
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..150.20 rows=11 width=128)
   Output: quarter(c3), quarter((c2)::timestamp without time zone), quarter(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), quarter('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((quarter(`c3`) = quarter('2000-01-01 00:00:00')))
(4 rows)

-- select quarter (stub function, quarter in constraints, result)
--Testcase 2989:
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE quarter(c3) = quarter('2000-01-01'::timestamp);
ERROR:  stub quarter(timestamp) is called
CONTEXT:  PL/pgSQL function quarter(timestamp without time zone) line 3 at RAISE
-- select quarter (stub function, quarter in constraints, explain)
--Testcase 2990:
EXPLAIN VERBOSE
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE quarter('2021-01-01 12:00:00'::timestamp) = '1';
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=128)
   Output: quarter(c3), quarter((c2)::timestamp without time zone), quarter(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), quarter('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((quarter('2021-01-01 12:00:00') = '1'))
(4 rows)

-- select quarter (stub function, quarter in constraints, result)
--Testcase 2991:
SELECT quarter(c3), quarter(c2), quarter(date_sub(c3, '1 12:59:10')), quarter('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE quarter('2021-01-01 12:00:00'::timestamp) = '1';
ERROR:  stub quarter(timestamp) is called
CONTEXT:  PL/pgSQL function quarter(timestamp without time zone) line 3 at RAISE
-- select quarter with agg (pushdown, explain)
--Testcase 2992:
EXPLAIN VERBOSE
SELECT max(c3), quarter(max(c3)) FROM time_tbl;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (max(c3)), (quarter(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), quarter(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select quarter as nest function with agg (pushdown, result)
--Testcase 2993:
SELECT max(c3), quarter(max(c3)) FROM time_tbl;
         max         | quarter 
---------------------+---------
 2021-01-07 00:59:59 | 1
(1 row)

-- select quarter with non pushdown func and explicit constant (explain)
--Testcase 2994:
EXPLAIN VERBOSE
SELECT quarter(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=72)
   Output: quarter(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select quarter with non pushdown func and explicit constant (result)
--Testcase 2995:
SELECT quarter(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select quarter with order by (explain)
--Testcase 2996:
EXPLAIN VERBOSE
SELECT id, quarter(c3 + '1 12:59:10') FROM time_tbl order by quarter(c3 + '1 12:59:10');
                                                                                                                                         QUERY PLAN                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=36)
   Output: id, quarter((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY quarter((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, quarter((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select quarter with order by (result)
--Testcase 2997:
SELECT id, quarter(c3 + '1 12:59:10') FROM time_tbl order by quarter(c3 + '1 12:59:10');
ERROR:  stub quarter(timestamp) is called
CONTEXT:  PL/pgSQL function quarter(timestamp without time zone) line 3 at RAISE
-- select quarter with order by index (result)
--Testcase 2998:
SELECT id, quarter(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub quarter(timestamp) is called
CONTEXT:  PL/pgSQL function quarter(timestamp without time zone) line 3 at RAISE
-- select quarter with order by index (result)
--Testcase 2999:
SELECT id, quarter(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub quarter(timestamp) is called
CONTEXT:  PL/pgSQL function quarter(timestamp without time zone) line 3 at RAISE
-- select quarter with group by (explain)
--Testcase 3000:
EXPLAIN VERBOSE
SELECT max(c3), quarter(c3 + '1 12:59:10') FROM time_tbl group by quarter(c3 + '1 12:59:10');
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (max(c3)), (quarter((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), quarter((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select quarter with group by (result)
--Testcase 3001:
SELECT max(c3), quarter(c3 + '1 12:59:10') FROM time_tbl group by quarter(c3 + '1 12:59:10');
         max         | quarter 
---------------------+---------
 2021-01-07 00:59:59 | 1
(1 row)

-- select quarter with group by index (result)
--Testcase 3002:
SELECT id, quarter(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | quarter 
----+---------
  0 | 1
  1 | 1
  2 | 1
  3 | 1
  4 | 1
(5 rows)

-- select quarter with group by index (result)
--Testcase 3003:
SELECT id, quarter(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | quarter 
----+---------
  0 | 1
  1 | 1
  2 | 1
  3 | 1
  4 | 1
(5 rows)

-- select quarter with group by having (explain)
--Testcase 3004:
EXPLAIN VERBOSE
SELECT max(c3), quarter(c3 + '1 12:59:10') FROM time_tbl group by quarter(c3 + '1 12:59:10'), c3 HAVING quarter(c3 + '1 12:59:10') > '0';
                                                                                                                                               QUERY PLAN                                                                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=48)
   Output: (max(c3)), (quarter((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), quarter((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((quarter((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) > '0'))
(5 rows)

-- select quarter with group by having (result)
--Testcase 3005:
SELECT max(c3), quarter(c3 + '1 12:59:10') FROM time_tbl group by quarter(c3 + '1 12:59:10'), c3 HAVING quarter(c3 + '1 12:59:10') > '0';
         max         | quarter 
---------------------+---------
 2021-01-03 12:10:30 | 1
 2021-01-04 23:12:13 | 1
 2021-01-05 11:12:12 | 1
 2021-01-06 16:00:00 | 1
 2021-01-07 00:59:59 | 1
(5 rows)

-- select quarter with group by index having (result)
--Testcase 3006:
SELECT id, quarter(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING quarter(c3 + '1 12:59:10') > '0';
 id | quarter |         c3          
----+---------+---------------------
  0 | 1       | 2021-01-03 12:10:30
  1 | 1       | 2021-01-04 23:12:13
  2 | 1       | 2021-01-05 11:12:12
  3 | 1       | 2021-01-06 16:00:00
  4 | 1       | 2021-01-07 00:59:59
(5 rows)

-- select quarter with group by index having (result)
--Testcase 3007:
SELECT id, quarter(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING quarter(c3 + '1 12:59:10') > '0';
 id | quarter |         c3          
----+---------+---------------------
  0 | 1       | 2021-01-03 12:10:30
  1 | 1       | 2021-01-04 23:12:13
  2 | 1       | 2021-01-05 11:12:12
  3 | 1       | 2021-01-06 16:00:00
  4 | 1       | 2021-01-07 00:59:59
(5 rows)

-- select quarter and as
--Testcase 3008:
SELECT quarter(date_sub(c3, '1 12:59:10')) as quarter1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- PERIOD_DIFF()
-- select period_diff (stub function, explain)
--Testcase 3009:
EXPLAIN VERBOSE
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=4)
   Output: period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select period_diff (stub function, result)
--Testcase 3010:
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff (stub function, not pushdown constraints, explain)
--Testcase 3011:
EXPLAIN VERBOSE
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE to_hex(id) = '1';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.72 rows=13 width=4)
   Output: period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select period_diff (stub function, not pushdown constraints, result)
--Testcase 3012:
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff (stub function, pushdown constraints, explain)
--Testcase 3013:
EXPLAIN VERBOSE
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE id != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..205.68 rows=2547 width=4)
   Output: period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select period_diff (stub function, pushdown constraints, result)
--Testcase 3014:
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE id != 200;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff (stub function, period_diff in constraints, explain)
--Testcase 3015:
EXPLAIN VERBOSE
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE period_diff(mysql_extract('YEAR_MONTH', c3 ), 199710) > id;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..176.12 rows=853 width=4)
   Output: period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((period_diff(extract(YEAR_MONTH FROM `c3`), 199710) > `id`))
(4 rows)

-- select period_diff (stub function, period_diff in constraints, result)
--Testcase 3016:
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE period_diff(mysql_extract('YEAR_MONTH', c3 ), 199710) > id;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff with agg (pushdown, explain)
--Testcase 3017:
EXPLAIN VERBOSE
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=4)
   Output: period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select period_diff as nest function with agg (pushdown, result)
--Testcase 3018:
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff with non pushdown func and explicit constant (explain)
--Testcase 3019:
EXPLAIN VERBOSE
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), pi(), 4.1 FROM time_tbl;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select period_diff with non pushdown func and explicit constant (result)
--Testcase 3020:
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), pi(), 4.1 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff with order by (explain)
--Testcase 3021:
EXPLAIN VERBOSE
SELECT id, period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl order by period_diff(mysql_extract('YEAR_MONTH', c3 ), 199710);
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=12)
   Output: id, period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), period_diff(mysql_extract('YEAR_MONTH'::text, c3), 199710)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY period_diff(extract(YEAR_MONTH FROM `c3`), 199710) IS NULL ASC, period_diff(extract(YEAR_MONTH FROM `c3`), 199710) ASC
(4 rows)

-- select period_diff with order by (result)
--Testcase 3022:
SELECT id, period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl order by period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907);
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff with order by index (result)
--Testcase 3023:
SELECT id, period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl order by 2,1;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff with order by index (result)
--Testcase 3024:
SELECT id, period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl order by 1,2;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_diff with group by index (result)
--Testcase 3025:
SELECT id, period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by 2,1;
 id | period_diff 
----+-------------
  0 |          18
  1 |          18
  2 |          18
  3 |          18
  4 |          18
(5 rows)

-- select period_diff with group by index (result)
--Testcase 3026:
SELECT id, period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by 1,2;
 id | period_diff 
----+-------------
  0 |          18
  1 |          18
  2 |          18
  3 |          18
  4 |          18
(5 rows)

-- select period_diff with group by having (explain)
--Testcase 3027:
EXPLAIN VERBOSE
SELECT max(c3), period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by  period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907),c3 HAVING period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) > 0;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), period_diff(extract(YEAR_MONTH FROM `c3`), 201907), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((period_diff(extract(YEAR_MONTH FROM `c3`), 201907) > 0))
(5 rows)

-- select period_diff with group by having (result)
--Testcase 3028:
SELECT max(c3), period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by  period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907),c3 HAVING period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) > 0;
         max         | period_diff 
---------------------+-------------
 2021-01-03 12:10:30 |          18
 2021-01-04 23:12:13 |          18
 2021-01-05 11:12:12 |          18
 2021-01-06 16:00:00 |          18
 2021-01-07 00:59:59 |          18
(5 rows)

-- select period_diff with group by index having (result)
--Testcase 3029:
SELECT id, c3, period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by 3, 2, 1 HAVING period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) > 0;
 id |         c3          | period_diff 
----+---------------------+-------------
  0 | 2021-01-03 12:10:30 |          18
  1 | 2021-01-04 23:12:13 |          18
  2 | 2021-01-05 11:12:12 |          18
  3 | 2021-01-06 16:00:00 |          18
  4 | 2021-01-07 00:59:59 |          18
(5 rows)

-- select period_diff with group by index having (result)
--Testcase 3030:
SELECT id, c3, period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by 1, 2, 3 HAVING period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) > 0;
 id |         c3          | period_diff 
----+---------------------+-------------
  0 | 2021-01-03 12:10:30 |          18
  1 | 2021-01-04 23:12:13 |          18
  2 | 2021-01-05 11:12:12 |          18
  3 | 2021-01-06 16:00:00 |          18
  4 | 2021-01-07 00:59:59 |          18
(5 rows)

-- select period_diff and as
--Testcase 3031:
SELECT period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907) as period_diff1 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- PERIOD_ADD()
-- select period_add (stub function, explain)
--Testcase 3032:
EXPLAIN VERBOSE
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=4)
   Output: period_add(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select period_add (stub function, result)
--Testcase 3033:
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add (stub function, not pushdown constraints, explain)
--Testcase 3034:
EXPLAIN VERBOSE
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE to_hex(id) = '1';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.72 rows=13 width=4)
   Output: period_add(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select period_add (stub function, not pushdown constraints, result)
--Testcase 3035:
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add (stub function, pushdown constraints, explain)
--Testcase 3036:
EXPLAIN VERBOSE
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE id != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..205.68 rows=2547 width=4)
   Output: period_add(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select period_add (stub function, pushdown constraints, result)
--Testcase 3037:
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE id != 200;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add (stub function, period_add in constraints, explain)
--Testcase 3038:
EXPLAIN VERBOSE
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE period_add(mysql_extract('YEAR_MONTH', c3 ), 199710) > id;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..176.12 rows=853 width=4)
   Output: period_add(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((period_add(extract(YEAR_MONTH FROM `c3`), 199710) > `id`))
(4 rows)

-- select period_add (stub function, period_add in constraints, result)
--Testcase 3039:
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl WHERE period_add(mysql_extract('YEAR_MONTH', c3 ), 199710) > id;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add with agg (pushdown, explain)
--Testcase 3040:
EXPLAIN VERBOSE
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=4)
   Output: period_add(mysql_extract('YEAR_MONTH'::text, c3), 201907)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select period_add as nest function with agg (pushdown, result)
--Testcase 3041:
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add with non pushdown func and explicit constant (explain)
--Testcase 3042:
EXPLAIN VERBOSE
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907), pi(), 4.1 FROM time_tbl;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: period_add(mysql_extract('YEAR_MONTH'::text, c3), 201907), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select period_add with non pushdown func and explicit constant (result)
--Testcase 3043:
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907), pi(), 4.1 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add with order by (explain)
--Testcase 3044:
EXPLAIN VERBOSE
SELECT id, period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl order by period_add(mysql_extract('YEAR_MONTH', c3 ), 199710);
                                                                                             QUERY PLAN                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=12)
   Output: id, period_add(mysql_extract('YEAR_MONTH'::text, c3), 201907), period_add(mysql_extract('YEAR_MONTH'::text, c3), 199710)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY period_add(extract(YEAR_MONTH FROM `c3`), 199710) IS NULL ASC, period_add(extract(YEAR_MONTH FROM `c3`), 199710) ASC
(4 rows)

-- select period_add with order by (result)
--Testcase 3045:
SELECT id, period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl order by period_add(mysql_extract('YEAR_MONTH', c3 ), 201907);
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add with order by index (result)
--Testcase 3046:
SELECT id, period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl order by 2,1;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add with order by index (result)
--Testcase 3047:
SELECT id, period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl order by 1,2;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select period_add with group by index (result)
--Testcase 3048:
SELECT id, period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by 2,1;
 id | period_add 
----+------------
  0 |    1884608
  1 |    1884608
  2 |    1884608
  3 |    1884608
  4 |    1884608
(5 rows)

-- select period_add with group by index (result)
--Testcase 3049:
SELECT id, period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by 1,2;
 id | period_add 
----+------------
  0 |    1884608
  1 |    1884608
  2 |    1884608
  3 |    1884608
  4 |    1884608
(5 rows)

-- select period_add with group by having (explain)
--Testcase 3050:
EXPLAIN VERBOSE
SELECT max(c3), period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by period_add(mysql_extract('YEAR_MONTH', c3 ), 201907),c3 HAVING period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) > 0;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (period_add(mysql_extract('YEAR_MONTH'::text, c3), 201907)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), period_add(extract(YEAR_MONTH FROM `c3`), 201907), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((period_add(extract(YEAR_MONTH FROM `c3`), 201907) > 0))
(5 rows)

-- select period_add with group by having (result)
--Testcase 3051:
SELECT max(c3), period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by period_add(mysql_extract('YEAR_MONTH', c3 ), 201907),c3 HAVING period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) > 0;
         max         | period_add 
---------------------+------------
 2021-01-03 12:10:30 |    1884608
 2021-01-04 23:12:13 |    1884608
 2021-01-05 11:12:12 |    1884608
 2021-01-06 16:00:00 |    1884608
 2021-01-07 00:59:59 |    1884608
(5 rows)

-- select period_add with group by index having (result)
--Testcase 3052:
SELECT id, c3, period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by 3, 2, 1 HAVING period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) > 0;
 id |         c3          | period_add 
----+---------------------+------------
  0 | 2021-01-03 12:10:30 |    1884608
  1 | 2021-01-04 23:12:13 |    1884608
  2 | 2021-01-05 11:12:12 |    1884608
  3 | 2021-01-06 16:00:00 |    1884608
  4 | 2021-01-07 00:59:59 |    1884608
(5 rows)

-- select period_add with group by index having (result)
--Testcase 3053:
SELECT id, c3, period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) FROM time_tbl group by 1, 2, 3 HAVING period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) > 0;
 id |         c3          | period_add 
----+---------------------+------------
  0 | 2021-01-03 12:10:30 |    1884608
  1 | 2021-01-04 23:12:13 |    1884608
  2 | 2021-01-05 11:12:12 |    1884608
  3 | 2021-01-06 16:00:00 |    1884608
  4 | 2021-01-07 00:59:59 |    1884608
(5 rows)

-- select period_add and as
--Testcase 3054:
SELECT period_add(mysql_extract('YEAR_MONTH', c3 ), 201907) as period_add1 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- NOW()
-- mysql_now is mutable function, some executes will return different result
-- select mysql_now (stub function, explain)
--Testcase 3055:
EXPLAIN VERBOSE
SELECT mysql_now() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_now()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_now (stub function, not pushdown constraints, explain)
--Testcase 3056:
EXPLAIN VERBOSE
SELECT mysql_now() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_now()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_now (stub function, pushdown constraints, explain)
--Testcase 3057:
EXPLAIN VERBOSE
SELECT mysql_now() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=8)
   Output: mysql_now()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select mysql_now (stub function, mysql_now in constraints, explain)
--Testcase 3058:
EXPLAIN VERBOSE
SELECT mysql_now() FROM time_tbl WHERE mysql_now() > '2000-01-01 00:00:00'::timestamp;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_now()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((now() > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_now in constrains (stub function, explain)
--Testcase 3059:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE mysql_now() > '2000-01-01 00:00:00'::timestamp;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((now() > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_now in constrains (stub function, result)
--Testcase 3060:
SELECT c1 FROM time_tbl WHERE mysql_now() > '2000-01-01 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- mysql_now as parameter of addtime(stub function, explain)
--Testcase 3061:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_now(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..171.86 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(now(), '1 12:59:10.0') > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_now as parameter of addtime(stub function, result)
--Testcase 3062:
SELECT c1 FROM time_tbl WHERE addtime(mysql_now(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_now and agg (pushdown, explain)
--Testcase 3063:
EXPLAIN VERBOSE
SELECT mysql_now(), sum(id) FROM time_tbl;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (mysql_now()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT now(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_now and log2 (pushdown, explain)
--Testcase 3064:
EXPLAIN VERBOSE
SELECT mysql_now(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: mysql_now(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_now with non pushdown func and explicit constant (explain)
--Testcase 3065:
EXPLAIN VERBOSE
SELECT mysql_now(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: mysql_now(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_now with order by (explain)
--Testcase 3066:
EXPLAIN VERBOSE
SELECT mysql_now(), c1 FROM time_tbl ORDER BY mysql_now();
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: mysql_now(), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY now() IS NULL ASC, now() ASC
(4 rows)

-- select mysql_now with order by index (explain)
--Testcase 3067:
EXPLAIN VERBOSE
SELECT mysql_now(), c1 FROM time_tbl ORDER BY 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: mysql_now(), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY now() IS NULL ASC, now() ASC
(4 rows)

-- mysql_now constraints with order by (explain)
--Testcase 3068:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_now(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp ORDER BY c1;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(now(), '1 12:59:10.0') > '2000-01-01 00:00:00')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- mysql_now constraints with order by (result)
--Testcase 3069:
SELECT c1 FROM time_tbl WHERE addtime(mysql_now(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select mysql_now with group by (explain)
--Testcase 3070:
EXPLAIN VERBOSE
SELECT mysql_now(), c1 FROM time_tbl GROUP BY c1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_now()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT now(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_now with group by index (explain)
--Testcase 3071:
EXPLAIN VERBOSE
SELECT mysql_now(), c1 FROM time_tbl GROUP BY 2;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_now()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT now(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_now with group by having (explain)
--Testcase 3072:
EXPLAIN VERBOSE
SELECT mysql_now(), c1 FROM time_tbl GROUP BY mysql_now(),c1 HAVING mysql_now() > '2000-01-01 00:00:00'::timestamp;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_now()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT now(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((now() > '2000-01-01 00:00:00'))
(5 rows)

-- select mysql_now with group by index having (explain)
--Testcase 3073:
EXPLAIN VERBOSE
SELECT mysql_now(), c1 FROM time_tbl GROUP BY 2,1 HAVING mysql_now() > '2000-01-01 00:00:00'::timestamp;
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_now()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT now(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((now() > '2000-01-01 00:00:00'))
(5 rows)

-- mysql_now constraints with group by (explain)
--Testcase 3074:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_now(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp GROUP BY c1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(now(), '1 12:59:10.0') > '2000-01-01 00:00:00')) GROUP BY 1
(5 rows)

-- mysql_now constraints with group by (result)
--Testcase 3075:
SELECT c1 FROM time_tbl WHERE addtime(mysql_now(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_now and as
--Testcase 3076:
EXPLAIN VERBOSE
SELECT mysql_now() as mysql_now1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_now()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- MONTHNAME()
-- select monthname (stub function, explain)
--Testcase 3077:
EXPLAIN VERBOSE
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                                 QUERY PLAN                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=128)
   Output: monthname(c3), monthname((c2)::timestamp without time zone), monthname(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), monthname('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select monthname (stub function, result)
--Testcase 3078:
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub monthname(timestamp) is called
CONTEXT:  PL/pgSQL function monthname(timestamp without time zone) line 3 at RAISE
-- select monthname (stub function, not pushdown constraints, explain)
--Testcase 3079:
EXPLAIN VERBOSE
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                 QUERY PLAN                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=128)
   Output: monthname(c3), monthname((c2)::timestamp without time zone), monthname(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), monthname('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select monthname (stub function, not pushdown constraints, result)
--Testcase 3080:
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub monthname(timestamp) is called
CONTEXT:  PL/pgSQL function monthname(timestamp without time zone) line 3 at RAISE
-- select monthname (stub function, pushdown constraints, explain)
--Testcase 3081:
EXPLAIN VERBOSE
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                                 QUERY PLAN                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=128)
   Output: monthname(c3), monthname((c2)::timestamp without time zone), monthname(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), monthname('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select monthname (stub function, pushdown constraints, result)
--Testcase 3082:
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub monthname(timestamp) is called
CONTEXT:  PL/pgSQL function monthname(timestamp without time zone) line 3 at RAISE
-- select monthname (stub function, monthname in constraints, explain)
--Testcase 3083:
EXPLAIN VERBOSE
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE monthname(c3) = monthname('2000-01-01'::timestamp);
                                                                                                 QUERY PLAN                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..150.20 rows=11 width=128)
   Output: monthname(c3), monthname((c2)::timestamp without time zone), monthname(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), monthname('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((monthname(`c3`) = monthname('2000-01-01 00:00:00')))
(4 rows)

-- select monthname (stub function, monthname in constraints, result)
--Testcase 3084:
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE monthname(c3) = monthname('2000-01-01'::timestamp);
ERROR:  stub monthname(timestamp) is called
CONTEXT:  PL/pgSQL function monthname(timestamp without time zone) line 3 at RAISE
-- select monthname (stub function, monthname in constraints, explain)
--Testcase 3085:
EXPLAIN VERBOSE
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE monthname('2021-01-01 12:00:00'::timestamp) = 'January';
                                                                                                 QUERY PLAN                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=128)
   Output: monthname(c3), monthname((c2)::timestamp without time zone), monthname(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), monthname('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((monthname('2021-01-01 12:00:00') = 'January'))
(4 rows)

-- select monthname (stub function, monthname in constraints, result)
--Testcase 3086:
SELECT monthname(c3), monthname(c2), monthname(date_sub(c3, '1 12:59:10')), monthname('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE monthname('2021-01-01 12:00:00'::timestamp) = 'January';
ERROR:  stub monthname(timestamp) is called
CONTEXT:  PL/pgSQL function monthname(timestamp without time zone) line 3 at RAISE
-- select monthname with agg (pushdown, explain)
--Testcase 3087:
EXPLAIN VERBOSE
SELECT max(c3), monthname(max(c3)) FROM time_tbl;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (max(c3)), (monthname(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), monthname(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select monthname as nest function with agg (pushdown, result)
--Testcase 3088:
SELECT max(c3), monthname(max(c3)) FROM time_tbl;
         max         | monthname 
---------------------+-----------
 2021-01-07 00:59:59 | January
(1 row)

-- select monthname with non pushdown func and explicit constant (explain)
--Testcase 3089:
EXPLAIN VERBOSE
SELECT monthname(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=72)
   Output: monthname(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select monthname with non pushdown func and explicit constant (result)
--Testcase 3090:
SELECT monthname(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select monthname with order by (explain)
--Testcase 3091:
EXPLAIN VERBOSE
SELECT id, monthname(c3 + '1 12:59:10') FROM time_tbl order by monthname(c3 + '1 12:59:10');
                                                                                                                                           QUERY PLAN                                                                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=36)
   Output: id, monthname((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY monthname((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, monthname((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select monthname with order by (result)
--Testcase 3092:
SELECT id, monthname(c3 + '1 12:59:10') FROM time_tbl order by monthname(c3 + '1 12:59:10');
ERROR:  stub monthname(timestamp) is called
CONTEXT:  PL/pgSQL function monthname(timestamp without time zone) line 3 at RAISE
-- select monthname with order by index (result)
--Testcase 3093:
SELECT id, monthname(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub monthname(timestamp) is called
CONTEXT:  PL/pgSQL function monthname(timestamp without time zone) line 3 at RAISE
-- select monthname with order by index (result)
--Testcase 3094:
SELECT id, monthname(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub monthname(timestamp) is called
CONTEXT:  PL/pgSQL function monthname(timestamp without time zone) line 3 at RAISE
-- select monthname with group by (explain)
--Testcase 3095:
EXPLAIN VERBOSE
SELECT max(c3), monthname(c3 + '1 12:59:10') FROM time_tbl group by monthname(c3 + '1 12:59:10');
                                                                                    QUERY PLAN                                                                                    
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (max(c3)), (monthname((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), monthname((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select monthname with group by (result)
--Testcase 3096:
SELECT max(c3), monthname(c3 + '1 12:59:10') FROM time_tbl group by monthname(c3 + '1 12:59:10');
         max         | monthname 
---------------------+-----------
 2021-01-07 00:59:59 | January
(1 row)

-- select monthname with group by index (result)
--Testcase 3097:
SELECT id, monthname(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | monthname 
----+-----------
  0 | January
  1 | January
  2 | January
  3 | January
  4 | January
(5 rows)

-- select monthname with group by index (result)
--Testcase 3098:
SELECT id, monthname(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | monthname 
----+-----------
  0 | January
  1 | January
  2 | January
  3 | January
  4 | January
(5 rows)

-- select monthname with group by having (explain)
--Testcase 3099:
EXPLAIN VERBOSE
SELECT max(c3), monthname(c3 + '1 12:59:10') FROM time_tbl group by monthname(c3 + '1 12:59:10'), c3 HAVING monthname(c3 + '1 12:59:10') = 'January';
                                                                                                                                                    QUERY PLAN                                                                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=48)
   Output: (max(c3)), (monthname((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), monthname((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((monthname((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) = 'January'))
(5 rows)

-- select monthname with group by having (result)
--Testcase 3100:
SELECT max(c3), monthname(c3 + '1 12:59:10') FROM time_tbl group by monthname(c3 + '1 12:59:10'), c3 HAVING monthname(c3 + '1 12:59:10') = 'January';
         max         | monthname 
---------------------+-----------
 2021-01-03 12:10:30 | January
 2021-01-04 23:12:13 | January
 2021-01-05 11:12:12 | January
 2021-01-06 16:00:00 | January
 2021-01-07 00:59:59 | January
(5 rows)

-- select monthname with group by index having (result)
--Testcase 3101:
SELECT id, monthname(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING monthname(c3 + '1 12:59:10') = 'January';
 id | monthname |         c3          
----+-----------+---------------------
  0 | January   | 2021-01-03 12:10:30
  1 | January   | 2021-01-04 23:12:13
  2 | January   | 2021-01-05 11:12:12
  3 | January   | 2021-01-06 16:00:00
  4 | January   | 2021-01-07 00:59:59
(5 rows)

-- select monthname with group by index having (result)
--Testcase 3102:
SELECT id, monthname(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING monthname(c3 + '1 12:59:10') = 'January';
 id | monthname |         c3          
----+-----------+---------------------
  0 | January   | 2021-01-03 12:10:30
  1 | January   | 2021-01-04 23:12:13
  2 | January   | 2021-01-05 11:12:12
  3 | January   | 2021-01-06 16:00:00
  4 | January   | 2021-01-07 00:59:59
(5 rows)

-- select monthname and as
--Testcase 3103:
SELECT monthname(date_sub(c3, '1 12:59:10')) as monthname1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- MONTH()
-- select month (stub function, explain)
--Testcase 3104:
EXPLAIN VERBOSE
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=16)
   Output: month(c3), month((c2)::timestamp without time zone), month(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), month('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select month (stub function, result)
--Testcase 3105:
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub month(timestamp) is called
CONTEXT:  PL/pgSQL function month(timestamp without time zone) line 3 at RAISE
-- select month (stub function, not pushdown constraints, explain)
--Testcase 3106:
EXPLAIN VERBOSE
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: month(c3), month((c2)::timestamp without time zone), month(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), month('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select month (stub function, not pushdown constraints, result)
--Testcase 3107:
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub month(timestamp) is called
CONTEXT:  PL/pgSQL function month(timestamp without time zone) line 3 at RAISE
-- select month (stub function, pushdown constraints, explain)
--Testcase 3108:
EXPLAIN VERBOSE
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=16)
   Output: month(c3), month((c2)::timestamp without time zone), month(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), month('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select month (stub function, pushdown constraints, result)
--Testcase 3109:
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub month(timestamp) is called
CONTEXT:  PL/pgSQL function month(timestamp without time zone) line 3 at RAISE
-- select month (stub function, month in constraints, explain)
--Testcase 3110:
EXPLAIN VERBOSE
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE month(c3) = month('2000-01-01'::timestamp);
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..150.20 rows=11 width=16)
   Output: month(c3), month((c2)::timestamp without time zone), month(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), month('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((month(`c3`) = month('2000-01-01 00:00:00')))
(4 rows)

-- select month (stub function, month in constraints, result)
--Testcase 3111:
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE month(c3) = month('2000-01-01'::timestamp);
ERROR:  stub month(timestamp) is called
CONTEXT:  PL/pgSQL function month(timestamp without time zone) line 3 at RAISE
-- select month (stub function, month in constraints, explain)
--Testcase 3112:
EXPLAIN VERBOSE
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE month('2021-01-01 12:00:00'::timestamp) = '1';
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: month(c3), month((c2)::timestamp without time zone), month(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), month('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((month('2021-01-01 12:00:00') = 1))
(4 rows)

-- select month (stub function, month in constraints, result)
--Testcase 3113:
SELECT month(c3), month(c2), month(date_sub(c3, '1 12:59:10')), month('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE month('2021-01-01 12:00:00'::timestamp) = '1';
ERROR:  stub month(timestamp) is called
CONTEXT:  PL/pgSQL function month(timestamp without time zone) line 3 at RAISE
-- select month with agg (pushdown, explain)
--Testcase 3114:
EXPLAIN VERBOSE
SELECT max(c3), month(max(c3)) FROM time_tbl;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (month(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), month(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select month as nest function with agg (pushdown, result)
--Testcase 3115:
SELECT max(c3), month(max(c3)) FROM time_tbl;
         max         | month 
---------------------+-------
 2021-01-07 00:59:59 |     1
(1 row)

-- select month with non pushdown func and explicit constant (explain)
--Testcase 3116:
EXPLAIN VERBOSE
SELECT month(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: month(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select month with non pushdown func and explicit constant (result)
--Testcase 3117:
SELECT month(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select month with order by (explain)
--Testcase 3118:
EXPLAIN VERBOSE
SELECT id, month(c3 + '1 12:59:10') FROM time_tbl order by month(c3 + '1 12:59:10');
                                                                                                                                       QUERY PLAN                                                                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, month((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY month((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, month((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select month with order by (result)
--Testcase 3119:
SELECT id, month(c3 + '1 12:59:10') FROM time_tbl order by month(c3 + '1 12:59:10');
ERROR:  stub month(timestamp) is called
CONTEXT:  PL/pgSQL function month(timestamp without time zone) line 3 at RAISE
-- select month with order by index (result)
--Testcase 3120:
SELECT id, month(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub month(timestamp) is called
CONTEXT:  PL/pgSQL function month(timestamp without time zone) line 3 at RAISE
-- select month with order by index (result)
--Testcase 3121:
SELECT id, month(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub month(timestamp) is called
CONTEXT:  PL/pgSQL function month(timestamp without time zone) line 3 at RAISE
-- select month with group by (explain)
--Testcase 3122:
EXPLAIN VERBOSE
SELECT max(c3), month(c3 + '1 12:59:10') FROM time_tbl group by month(c3 + '1 12:59:10');
                                                                                  QUERY PLAN                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (month((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), month((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select month with group by (result)
--Testcase 3123:
SELECT max(c3), month(c3 + '1 12:59:10') FROM time_tbl group by month(c3 + '1 12:59:10');
         max         | month 
---------------------+-------
 2021-01-07 00:59:59 |     1
(1 row)

-- select month with group by index (result)
--Testcase 3124:
SELECT id, month(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | month 
----+-------
  0 |     1
  1 |     1
  2 |     1
  3 |     1
  4 |     1
(5 rows)

-- select month with group by index (result)
--Testcase 3125:
SELECT id, month(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | month 
----+-------
  0 |     1
  1 |     1
  2 |     1
  3 |     1
  4 |     1
(5 rows)

-- select month with group by having (explain)
--Testcase 3126:
EXPLAIN VERBOSE
SELECT max(c3), month(c3 + '1 12:59:10') FROM time_tbl group by month(c3 + '1 12:59:10'), c3 HAVING month(c3 + '1 12:59:10') < 12;
                                                                                                                                            QUERY PLAN                                                                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (month((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), month((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((month((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) < 12))
(5 rows)

-- select month with group by having (result)
--Testcase 3127:
SELECT max(c3), month(c3 + '1 12:59:10') FROM time_tbl group by month(c3 + '1 12:59:10'), c3 HAVING month(c3 + '1 12:59:10') < 12;
         max         | month 
---------------------+-------
 2021-01-03 12:10:30 |     1
 2021-01-04 23:12:13 |     1
 2021-01-05 11:12:12 |     1
 2021-01-06 16:00:00 |     1
 2021-01-07 00:59:59 |     1
(5 rows)

-- select month with group by index having (result)
--Testcase 3128:
SELECT id, month(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING month(c3 + '1 12:59:10') < 12;
 id | month |         c3          
----+-------+---------------------
  0 |     1 | 2021-01-03 12:10:30
  1 |     1 | 2021-01-04 23:12:13
  2 |     1 | 2021-01-05 11:12:12
  3 |     1 | 2021-01-06 16:00:00
  4 |     1 | 2021-01-07 00:59:59
(5 rows)

-- select month with group by index having (result)
--Testcase 3129:
SELECT id, month(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING month(c3 + '1 12:59:10') < 12;
 id | month |         c3          
----+-------+---------------------
  0 |     1 | 2021-01-03 12:10:30
  1 |     1 | 2021-01-04 23:12:13
  2 |     1 | 2021-01-05 11:12:12
  3 |     1 | 2021-01-06 16:00:00
  4 |     1 | 2021-01-07 00:59:59
(5 rows)

-- select month and as
--Testcase 3130:
SELECT month(date_sub(c3, '1 12:59:10')) as month1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- MINUTE()
-- select minute (stub function, explain)
--Testcase 3131:
EXPLAIN VERBOSE
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=16)
   Output: minute(c3), minute((c2)::timestamp without time zone), minute(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), minute('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select minute (stub function, result)
--Testcase 3132:
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub minute(timestamp) is called
CONTEXT:  PL/pgSQL function minute(timestamp without time zone) line 3 at RAISE
-- select minute (stub function, not pushdown constraints, explain)
--Testcase 3133:
EXPLAIN VERBOSE
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: minute(c3), minute((c2)::timestamp without time zone), minute(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), minute('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select minute (stub function, not pushdown constraints, result)
--Testcase 3134:
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub minute(timestamp) is called
CONTEXT:  PL/pgSQL function minute(timestamp without time zone) line 3 at RAISE
-- select minute (stub function, pushdown constraints, explain)
--Testcase 3135:
EXPLAIN VERBOSE
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=16)
   Output: minute(c3), minute((c2)::timestamp without time zone), minute(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), minute('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select minute (stub function, pushdown constraints, result)
--Testcase 3136:
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub minute(timestamp) is called
CONTEXT:  PL/pgSQL function minute(timestamp without time zone) line 3 at RAISE
-- select minute (stub function, minute in constraints, explain)
--Testcase 3137:
EXPLAIN VERBOSE
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE minute(c3) > minute('2000-01-01'::timestamp);
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..176.34 rows=758 width=16)
   Output: minute(c3), minute((c2)::timestamp without time zone), minute(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), minute('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((minute(`c3`) > minute('2000-01-01 00:00:00')))
(4 rows)

-- select minute (stub function, minute in constraints, result)
--Testcase 3138:
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE minute(c3) > minute('2000-01-01'::timestamp);
ERROR:  stub minute(timestamp) is called
CONTEXT:  PL/pgSQL function minute(timestamp without time zone) line 3 at RAISE
-- select minute (stub function, minute in constraints, explain)
--Testcase 3139:
EXPLAIN VERBOSE
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE minute('2021-01-01 12:00:00'::timestamp) < 1;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..170.66 rows=758 width=16)
   Output: minute(c3), minute((c2)::timestamp without time zone), minute(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), minute('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((minute('2021-01-01 12:00:00') < 1))
(4 rows)

-- select minute (stub function, minute in constraints, result)
--Testcase 3140:
SELECT minute(c3), minute(c2), minute(date_sub(c3, '1 12:59:10')), minute('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE minute('2021-01-01 12:00:00'::timestamp) < 1;
ERROR:  stub minute(timestamp) is called
CONTEXT:  PL/pgSQL function minute(timestamp without time zone) line 3 at RAISE
-- select minute with agg (pushdown, explain)
--Testcase 3141:
EXPLAIN VERBOSE
SELECT max(c3), minute(max(c3)) FROM time_tbl;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (minute(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), minute(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select minute as nest function with agg (pushdown, result)
--Testcase 3142:
SELECT max(c3), minute(max(c3)) FROM time_tbl;
         max         | minute 
---------------------+--------
 2021-01-07 00:59:59 |     59
(1 row)

-- select minute with non pushdown func and explicit constant (explain)
--Testcase 3143:
EXPLAIN VERBOSE
SELECT minute(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: minute(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select minute with non pushdown func and explicit constant (result)
--Testcase 3144:
SELECT minute(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select minute with order by (explain)
--Testcase 3145:
EXPLAIN VERBOSE
SELECT id, minute(c3 + '1 12:59:10') FROM time_tbl order by minute(c3 + '1 12:59:10');
                                                                                                                                        QUERY PLAN                                                                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, minute((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY minute((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, minute((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select minute with order by (result)
--Testcase 3146:
SELECT id, minute(c3 + '1 12:59:10') FROM time_tbl order by minute(c3 + '1 12:59:10');
ERROR:  stub minute(timestamp) is called
CONTEXT:  PL/pgSQL function minute(timestamp without time zone) line 3 at RAISE
-- select minute with order by index (result)
--Testcase 3147:
SELECT id, minute(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub minute(timestamp) is called
CONTEXT:  PL/pgSQL function minute(timestamp without time zone) line 3 at RAISE
-- select minute with order by index (result)
--Testcase 3148:
SELECT id, minute(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub minute(timestamp) is called
CONTEXT:  PL/pgSQL function minute(timestamp without time zone) line 3 at RAISE
-- select minute with group by (explain)
--Testcase 3149:
EXPLAIN VERBOSE
SELECT max(c3), minute(c3 + '1 12:59:10') FROM time_tbl group by minute(c3 + '1 12:59:10');
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (minute((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), minute((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select minute with group by (result)
--Testcase 3150:
SELECT max(c3), minute(c3 + '1 12:59:10') FROM time_tbl group by minute(c3 + '1 12:59:10');
         max         | minute 
---------------------+--------
 2021-01-03 12:10:30 |      9
 2021-01-05 11:12:12 |     11
 2021-01-07 00:59:59 |     59
(3 rows)

-- select minute with group by index (result)
--Testcase 3151:
SELECT id, minute(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id | minute 
----+--------
  0 |      9
  1 |     11
  2 |     11
  3 |     59
  4 |     59
(5 rows)

-- select minute with group by index (result)
--Testcase 3152:
SELECT id, minute(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id | minute 
----+--------
  0 |      9
  1 |     11
  2 |     11
  3 |     59
  4 |     59
(5 rows)

-- select minute with group by having (explain)
--Testcase 3153:
EXPLAIN VERBOSE
SELECT max(c3), minute(c3 + '1 12:59:10') FROM time_tbl group by minute(c3 + '1 12:59:10'), c3 HAVING minute(c3 + '1 12:59:10') < 60;
                                                                                                                                             QUERY PLAN                                                                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (minute((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), minute((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((minute((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) < 60))
(5 rows)

-- select minute with group by having (result)
--Testcase 3154:
SELECT max(c3), minute(c3 + '1 12:59:10') FROM time_tbl group by minute(c3 + '1 12:59:10'), c3 HAVING minute(c3 + '1 12:59:10') < 60;
         max         | minute 
---------------------+--------
 2021-01-03 12:10:30 |      9
 2021-01-04 23:12:13 |     11
 2021-01-05 11:12:12 |     11
 2021-01-06 16:00:00 |     59
 2021-01-07 00:59:59 |     59
(5 rows)

-- select minute with group by index having (result)
--Testcase 3155:
SELECT id, minute(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING minute(c3 + '1 12:59:10') < 60;
 id | minute |         c3          
----+--------+---------------------
  0 |      9 | 2021-01-03 12:10:30
  1 |     11 | 2021-01-04 23:12:13
  2 |     11 | 2021-01-05 11:12:12
  3 |     59 | 2021-01-06 16:00:00
  4 |     59 | 2021-01-07 00:59:59
(5 rows)

-- select minute with group by index having (result)
--Testcase 3156:
SELECT id, minute(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING minute(c3 + '1 12:59:10') < 60;
 id | minute |         c3          
----+--------+---------------------
  0 |      9 | 2021-01-03 12:10:30
  1 |     11 | 2021-01-04 23:12:13
  2 |     11 | 2021-01-05 11:12:12
  3 |     59 | 2021-01-06 16:00:00
  4 |     59 | 2021-01-07 00:59:59
(5 rows)

-- select minute and as
--Testcase 3157:
SELECT minute(date_sub(c3, '1 12:59:10')) as minute1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- MICROSECOND()
-- select microsecond (stub function, explain)
--Testcase 3158:
EXPLAIN VERBOSE
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=16)
   Output: microsecond(c3), microsecond((c2)::timestamp without time zone), microsecond(date_sub(c3, '@ 1 day 12 hours 59 mins 10.154 secs'::interval)), microsecond('2021-01-01 12:00:00.986'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select microsecond (stub function, result)
--Testcase 3159:
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl;
ERROR:  stub microsecond(timestamp) is called
CONTEXT:  PL/pgSQL function microsecond(timestamp without time zone) line 3 at RAISE
-- select microsecond (stub function, not pushdown constraints, explain)
--Testcase 3160:
EXPLAIN VERBOSE
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: microsecond(c3), microsecond((c2)::timestamp without time zone), microsecond(date_sub(c3, '@ 1 day 12 hours 59 mins 10.154 secs'::interval)), microsecond('2021-01-01 12:00:00.986'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select microsecond (stub function, not pushdown constraints, result)
--Testcase 3161:
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub microsecond(timestamp) is called
CONTEXT:  PL/pgSQL function microsecond(timestamp without time zone) line 3 at RAISE
-- select microsecond (stub function, pushdown constraints, explain)
--Testcase 3162:
EXPLAIN VERBOSE
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=16)
   Output: microsecond(c3), microsecond((c2)::timestamp without time zone), microsecond(date_sub(c3, '@ 1 day 12 hours 59 mins 10.154 secs'::interval)), microsecond('2021-01-01 12:00:00.986'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select microsecond (stub function, pushdown constraints, result)
--Testcase 3163:
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub microsecond(timestamp) is called
CONTEXT:  PL/pgSQL function microsecond(timestamp without time zone) line 3 at RAISE
-- select microsecond (stub function, microsecond in constraints, explain)
--Testcase 3164:
EXPLAIN VERBOSE
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl WHERE microsecond(c3) = microsecond('2000-01-01'::timestamp);
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..150.20 rows=11 width=16)
   Output: microsecond(c3), microsecond((c2)::timestamp without time zone), microsecond(date_sub(c3, '@ 1 day 12 hours 59 mins 10.154 secs'::interval)), microsecond('2021-01-01 12:00:00.986'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((microsecond(`c3`) = microsecond('2000-01-01 00:00:00')))
(4 rows)

-- select microsecond (stub function, microsecond in constraints, result)
--Testcase 3165:
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl WHERE microsecond(c3) = microsecond('2000-01-01'::timestamp);
ERROR:  stub microsecond(timestamp) is called
CONTEXT:  PL/pgSQL function microsecond(timestamp without time zone) line 3 at RAISE
-- select microsecond (stub function, microsecond in constraints, explain)
--Testcase 3166:
EXPLAIN VERBOSE
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl WHERE microsecond('2021-01-01 12:00:00'::timestamp) = '0';
                                                                                                         QUERY PLAN                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: microsecond(c3), microsecond((c2)::timestamp without time zone), microsecond(date_sub(c3, '@ 1 day 12 hours 59 mins 10.154 secs'::interval)), microsecond('2021-01-01 12:00:00.986'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((microsecond('2021-01-01 12:00:00') = 0))
(4 rows)

-- select microsecond (stub function, microsecond in constraints, result)
--Testcase 3167:
SELECT microsecond(c3), microsecond(c2), microsecond(date_sub(c3, '1 12:59:10.154')), microsecond('2021-01-01 12:00:00.986'::timestamp) FROM time_tbl WHERE microsecond('2021-01-01 12:00:00'::timestamp) = '0';
ERROR:  stub microsecond(timestamp) is called
CONTEXT:  PL/pgSQL function microsecond(timestamp without time zone) line 3 at RAISE
-- select microsecond with agg (pushdown, explain)
--Testcase 3168:
EXPLAIN VERBOSE
SELECT max(c3), microsecond(max(c3)) FROM time_tbl;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (microsecond(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), microsecond(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select microsecond as nest function with agg (pushdown, result)
--Testcase 3169:
SELECT max(c3), microsecond(max(c3)) FROM time_tbl;
         max         | microsecond 
---------------------+-------------
 2021-01-07 00:59:59 |           0
(1 row)

-- select microsecond with non pushdown func and explicit constant (explain)
--Testcase 3170:
EXPLAIN VERBOSE
SELECT microsecond(date_sub(c3, '1 12:59:10.999')), pi(), 4.1 FROM time_tbl;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: microsecond(date_sub(c3, '@ 1 day 12 hours 59 mins 10.999 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select microsecond with non pushdown func and explicit constant (result)
--Testcase 3171:
SELECT microsecond(date_sub(c3, '1 12:59:10.999')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select microsecond with order by (explain)
--Testcase 3172:
EXPLAIN VERBOSE
SELECT id, microsecond(c3 + '1 12:59:10.999') FROM time_tbl order by microsecond(c3 + '1 12:59:10.999');
                                                                                                                                                                           QUERY PLAN                                                                                                                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, microsecond((c3 + '@ 1 day 12 hours 59 mins 10.999 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY microsecond((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND + INTERVAL 999000 MICROSECOND)) IS NULL ASC, microsecond((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND + INTERVAL 999000 MICROSECOND)) ASC
(4 rows)

-- select microsecond with order by (result)
--Testcase 3173:
SELECT id, microsecond(c3 + '1 12:59:10.999') FROM time_tbl order by microsecond(c3 + '1 12:59:10.999');
ERROR:  stub microsecond(timestamp) is called
CONTEXT:  PL/pgSQL function microsecond(timestamp without time zone) line 3 at RAISE
-- select microsecond with order by index (result)
--Testcase 3174:
SELECT id, microsecond(c3 + '1 12:59:10.999') FROM time_tbl order by 2,1;
ERROR:  stub microsecond(timestamp) is called
CONTEXT:  PL/pgSQL function microsecond(timestamp without time zone) line 3 at RAISE
-- select microsecond with order by index (result)
--Testcase 3175:
SELECT id, microsecond(c3 + '1 12:59:10.999') FROM time_tbl order by 1,2;
ERROR:  stub microsecond(timestamp) is called
CONTEXT:  PL/pgSQL function microsecond(timestamp without time zone) line 3 at RAISE
-- select microsecond with group by (explain)
--Testcase 3176:
EXPLAIN VERBOSE
SELECT max(c3), microsecond(c3 + '1 12:59:10.999') FROM time_tbl group by microsecond(c3 + '1 12:59:10.999');
                                                                                                    QUERY PLAN                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (microsecond((c3 + '@ 1 day 12 hours 59 mins 10.999 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), microsecond((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND + INTERVAL 999000 MICROSECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select microsecond with group by (result)
--Testcase 3177:
SELECT max(c3), microsecond(c3 + '1 12:59:10.999') FROM time_tbl group by microsecond(c3 + '1 12:59:10.999');
         max         | microsecond 
---------------------+-------------
 2021-01-07 00:59:59 |      999000
(1 row)

-- select microsecond with group by index (result)
--Testcase 3178:
SELECT id, microsecond(c3 + '1 12:59:10.999') FROM time_tbl group by 2,1;
 id | microsecond 
----+-------------
  0 |      999000
  1 |      999000
  2 |      999000
  3 |      999000
  4 |      999000
(5 rows)

-- select microsecond with group by index (result)
--Testcase 3179:
SELECT id, microsecond(c3 + '1 12:59:10.999') FROM time_tbl group by 1,2;
 id | microsecond 
----+-------------
  0 |      999000
  1 |      999000
  2 |      999000
  3 |      999000
  4 |      999000
(5 rows)

-- select microsecond with group by having (explain)
--Testcase 3180:
EXPLAIN VERBOSE
SELECT max(c3), microsecond(c3 + '1 12:59:10.999') FROM time_tbl group by microsecond(c3 + '1 12:59:10.999'), c3 HAVING microsecond(c3 + '1 12:59:10.999') > 1000;
                                                                                                                                                                                 QUERY PLAN                                                                                                                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (microsecond((c3 + '@ 1 day 12 hours 59 mins 10.999 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), microsecond((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND + INTERVAL 999000 MICROSECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((microsecond((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND + INTERVAL 999000 MICROSECOND)) > 1000))
(5 rows)

-- select microsecond with group by having (result)
--Testcase 3181:
SELECT max(c3), microsecond(c3 + '1 12:59:10.999') FROM time_tbl group by microsecond(c3 + '1 12:59:10.999'), c3 HAVING microsecond(c3 + '1 12:59:10.999') > 1000;
         max         | microsecond 
---------------------+-------------
 2021-01-03 12:10:30 |      999000
 2021-01-04 23:12:13 |      999000
 2021-01-05 11:12:12 |      999000
 2021-01-06 16:00:00 |      999000
 2021-01-07 00:59:59 |      999000
(5 rows)

-- select microsecond with group by index having (result)
--Testcase 3182:
SELECT id, microsecond(c3 + '1 12:59:10.999'), c3 FROM time_tbl group by 3, 2, 1 HAVING microsecond(c3 + '1 12:59:10.999') > 1000;
 id | microsecond |         c3          
----+-------------+---------------------
  0 |      999000 | 2021-01-03 12:10:30
  1 |      999000 | 2021-01-04 23:12:13
  2 |      999000 | 2021-01-05 11:12:12
  3 |      999000 | 2021-01-06 16:00:00
  4 |      999000 | 2021-01-07 00:59:59
(5 rows)

-- select microsecond with group by index having (result)
--Testcase 3183:
SELECT id, microsecond(c3 + '1 12:59:10.999'), c3 FROM time_tbl group by 1, 2, 3 HAVING microsecond(c3 + '1 12:59:10.999') > 1000;
 id | microsecond |         c3          
----+-------------+---------------------
  0 |      999000 | 2021-01-03 12:10:30
  1 |      999000 | 2021-01-04 23:12:13
  2 |      999000 | 2021-01-05 11:12:12
  3 |      999000 | 2021-01-06 16:00:00
  4 |      999000 | 2021-01-07 00:59:59
(5 rows)

-- select microsecond and as
--Testcase 3184:
SELECT microsecond(date_sub(c3, '1 12:59:10.999')) as microsecond1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- MAKETIME()
-- select maketime (stub function, explain)
--Testcase 3185:
EXPLAIN VERBOSE
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.00 rows=2560 width=8)
   Output: maketime(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 15, 30)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select maketime (stub function, result)
--Testcase 3186:
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select maketime (stub function, not pushdown constraints, explain)
--Testcase 3187:
EXPLAIN VERBOSE
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl WHERE to_hex(id) = '1';
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.76 rows=13 width=8)
   Output: maketime(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 15, 30)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select maketime (stub function, not pushdown constraints, result)
--Testcase 3188:
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select maketime (stub function, pushdown constraints, explain)
--Testcase 3189:
EXPLAIN VERBOSE
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl WHERE id != 200;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.04 rows=2547 width=8)
   Output: maketime(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 15, 30)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select maketime (stub function, pushdown constraints, result)
--Testcase 3190:
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl WHERE id != 200;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select maketime (stub function, maketime in constraints, explain)
--Testcase 3191:
EXPLAIN VERBOSE
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl WHERE maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) > '12:59:10'::time;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..184.66 rows=853 width=8)
   Output: maketime(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 15, 30)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((maketime(period_diff(extract(YEAR_MONTH FROM `c3`), 201907), 15, 30) > '12:59:10'))
(4 rows)

-- select maketime (stub function, maketime in constraints, result)
--Testcase 3192:
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl WHERE maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) > '12:59:10'::time;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select maketime with agg (pushdown, explain)
--Testcase 3193:
EXPLAIN VERBOSE
SELECT max(c3), maketime(18, 15, 30) FROM time_tbl;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (max(c3)), (maketime(18, 15, 30))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), maketime(18, 15, 30) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select maketime as nest function with agg (pushdown, result)
--Testcase 3194:
SELECT max(c3), maketime(18, 15, 30) FROM time_tbl;
         max         | maketime 
---------------------+----------
 2021-01-07 00:59:59 | 18:15:30
(1 row)

-- select maketime with non pushdown func and explicit constant (explain)
--Testcase 3195:
EXPLAIN VERBOSE
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30), pi(), 4.1 FROM time_tbl;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.00 rows=2560 width=48)
   Output: maketime(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 15, 30), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select maketime with non pushdown func and explicit constant (result)
--Testcase 3196:
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30), pi(), 4.1 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select maketime with order by (explain)
--Testcase 3197:
EXPLAIN VERBOSE
SELECT id, maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl order by maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30);
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=12)
   Output: id, maketime(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 15, 30)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY maketime(period_diff(extract(YEAR_MONTH FROM `c3`), 201907), 15, 30) IS NULL ASC, maketime(period_diff(extract(YEAR_MONTH FROM `c3`), 201907), 15, 30) ASC
(4 rows)

-- select maketime with order by (result)
--Testcase 3198:
SELECT id, maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl order by maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30);
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select maketime with order by index (result)
--Testcase 3199:
SELECT id, maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl order by 2,1;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select maketime with order by index (result)
--Testcase 3200:
SELECT id, maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl order by 1,2;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select maketime with group by (explain)
--Testcase 3201:
EXPLAIN VERBOSE
SELECT max(c3), maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl group by maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30), c3;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=24)
   Output: (max(c3)), (maketime(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 15, 30)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), maketime(period_diff(extract(YEAR_MONTH FROM `c3`), 201907), 15, 30), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3
(5 rows)

-- select maketime with group by (result)
--Testcase 3202:
SELECT max(c3), maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl group by maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30), c3;
         max         | maketime 
---------------------+----------
 2021-01-03 12:10:30 | 18:15:30
 2021-01-04 23:12:13 | 18:15:30
 2021-01-05 11:12:12 | 18:15:30
 2021-01-06 16:00:00 | 18:15:30
 2021-01-07 00:59:59 | 18:15:30
(5 rows)

-- select maketime with group by index (result)
--Testcase 3203:
SELECT id, maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl group by 2,1;
 id | maketime 
----+----------
  0 | 18:15:30
  1 | 18:15:30
  2 | 18:15:30
  3 | 18:15:30
  4 | 18:15:30
(5 rows)

-- select maketime with group by index (result)
--Testcase 3204:
SELECT id, maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl group by 1,2;
 id | maketime 
----+----------
  0 | 18:15:30
  1 | 18:15:30
  2 | 18:15:30
  3 | 18:15:30
  4 | 18:15:30
(5 rows)

-- select maketime with group by index having (result)
--Testcase 3205:
SELECT id, c3, maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl group by 3, 2, 1 HAVING maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) > '12:00:00'::time;
 id |         c3          | maketime 
----+---------------------+----------
  0 | 2021-01-03 12:10:30 | 18:15:30
  1 | 2021-01-04 23:12:13 | 18:15:30
  2 | 2021-01-05 11:12:12 | 18:15:30
  3 | 2021-01-06 16:00:00 | 18:15:30
  4 | 2021-01-07 00:59:59 | 18:15:30
(5 rows)

-- select maketime with group by index having (result)
--Testcase 3206:
SELECT id, c3, maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) FROM time_tbl group by 1, 2, 3 HAVING maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) > '12:00:00'::time;
 id |         c3          | maketime 
----+---------------------+----------
  0 | 2021-01-03 12:10:30 | 18:15:30
  1 | 2021-01-04 23:12:13 | 18:15:30
  2 | 2021-01-05 11:12:12 | 18:15:30
  3 | 2021-01-06 16:00:00 | 18:15:30
  4 | 2021-01-07 00:59:59 | 18:15:30
(5 rows)

-- select maketime and as
--Testcase 3207:
SELECT maketime(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 15, 30) as maketime1 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- MAKEDATE()
-- select makedate (stub function, explain)
--Testcase 3208:
EXPLAIN VERBOSE
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.00 rows=2560 width=4)
   Output: makedate(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 90)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select makedate (stub function, result)
--Testcase 3209:
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select makedate (stub function, not pushdown constraints, explain)
--Testcase 3210:
EXPLAIN VERBOSE
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl WHERE to_hex(id) = '1';
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.76 rows=13 width=4)
   Output: makedate(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 90)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select makedate (stub function, not pushdown constraints, result)
--Testcase 3211:
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select makedate (stub function, pushdown constraints, explain)
--Testcase 3212:
EXPLAIN VERBOSE
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl WHERE id != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.04 rows=2547 width=4)
   Output: makedate(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 90)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select makedate (stub function, pushdown constraints, result)
--Testcase 3213:
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl WHERE id != 200;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select makedate (stub function, makedate in constraints, explain)
--Testcase 3214:
EXPLAIN VERBOSE
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl WHERE makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) < '2021-01-02'::date;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..184.66 rows=853 width=4)
   Output: makedate(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 90)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((makedate(period_diff(extract(YEAR_MONTH FROM `c3`), 201907), 90) < '2021-01-02'))
(4 rows)

-- select makedate (stub function, makedate in constraints, result)
--Testcase 3215:
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl WHERE makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) < '2021-01-02'::date;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select makedate with agg (pushdown, explain)
--Testcase 3216:
EXPLAIN VERBOSE
SELECT max(c3), makedate(18, 90) FROM time_tbl;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (makedate(18, 90))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), makedate(18, 90) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select makedate as nest function with agg (pushdown, result)
--Testcase 3217:
SELECT max(c3), makedate(18, 90) FROM time_tbl;
         max         |  makedate  
---------------------+------------
 2021-01-07 00:59:59 | 2018-03-31
(1 row)

-- select makedate with non pushdown func and explicit constant (explain)
--Testcase 3218:
EXPLAIN VERBOSE
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90), pi(), 4.1 FROM time_tbl;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.00 rows=2560 width=44)
   Output: makedate(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 90), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select makedate with non pushdown func and explicit constant (result)
--Testcase 3219:
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90), pi(), 4.1 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select makedate with order by (explain)
--Testcase 3220:
EXPLAIN VERBOSE
SELECT id, makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl order by makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90);
                                                                                                            QUERY PLAN                                                                                                             
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=8)
   Output: id, makedate(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 90)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY makedate(period_diff(extract(YEAR_MONTH FROM `c3`), 201907), 90) IS NULL ASC, makedate(period_diff(extract(YEAR_MONTH FROM `c3`), 201907), 90) ASC
(4 rows)

-- select makedate with order by (result)
--Testcase 3221:
SELECT id, makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl order by makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90);
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select makedate with order by index (result)
--Testcase 3222:
SELECT id, makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl order by 2,1;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select makedate with order by index (result)
--Testcase 3223:
SELECT id, makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl order by 1,2;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select makedate with group by (explain)
--Testcase 3224:
EXPLAIN VERBOSE
SELECT max(c3), makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl group by makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90), c3;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=20)
   Output: (max(c3)), (makedate(period_diff(mysql_extract('YEAR_MONTH'::text, c3), 201907), 90)), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), makedate(period_diff(extract(YEAR_MONTH FROM `c3`), 201907), 90), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3
(5 rows)

-- select makedate with group by (result)
--Testcase 3225:
SELECT max(c3), makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl group by makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90), c3;
         max         |  makedate  
---------------------+------------
 2021-01-03 12:10:30 | 2018-03-31
 2021-01-04 23:12:13 | 2018-03-31
 2021-01-05 11:12:12 | 2018-03-31
 2021-01-06 16:00:00 | 2018-03-31
 2021-01-07 00:59:59 | 2018-03-31
(5 rows)

-- select makedate with group by index (result)
--Testcase 3226:
SELECT id, makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl group by 2,1;
 id |  makedate  
----+------------
  0 | 2018-03-31
  1 | 2018-03-31
  2 | 2018-03-31
  3 | 2018-03-31
  4 | 2018-03-31
(5 rows)

-- select makedate with group by index (result)
--Testcase 3227:
SELECT id, makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl group by 1,2;
 id |  makedate  
----+------------
  0 | 2018-03-31
  1 | 2018-03-31
  2 | 2018-03-31
  3 | 2018-03-31
  4 | 2018-03-31
(5 rows)

-- select makedate with group by index having (result)
--Testcase 3228:
SELECT id, c3, makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl group by 3, 2, 1 HAVING makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) > '2008-03-31'::date;
 id |         c3          |  makedate  
----+---------------------+------------
  0 | 2021-01-03 12:10:30 | 2018-03-31
  1 | 2021-01-04 23:12:13 | 2018-03-31
  2 | 2021-01-05 11:12:12 | 2018-03-31
  3 | 2021-01-06 16:00:00 | 2018-03-31
  4 | 2021-01-07 00:59:59 | 2018-03-31
(5 rows)

-- select makedate with group by index having (result)
--Testcase 3229:
SELECT id, c3, makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) FROM time_tbl group by 1, 2, 3 HAVING makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) > '2008-03-31'::date;
 id |         c3          |  makedate  
----+---------------------+------------
  0 | 2021-01-03 12:10:30 | 2018-03-31
  1 | 2021-01-04 23:12:13 | 2018-03-31
  2 | 2021-01-05 11:12:12 | 2018-03-31
  3 | 2021-01-06 16:00:00 | 2018-03-31
  4 | 2021-01-07 00:59:59 | 2018-03-31
(5 rows)

-- select makedate and as
--Testcase 3230:
SELECT makedate(period_diff(mysql_extract('YEAR_MONTH', c3 ), 201907), 90) as makedate1 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- LOCALTIMESTAMP, LOCALTIMESTAMP()
-- mysql_localtimestamp is mutable function, some executes will return different result
-- select mysql_localtimestamp (stub function, explain)
--Testcase 3231:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_localtimestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_localtimestamp (stub function, not pushdown constraints, explain)
--Testcase 3232:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_localtimestamp()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_localtimestamp (stub function, pushdown constraints, explain)
--Testcase 3233:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=8)
   Output: mysql_localtimestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select mysql_localtimestamp (stub function, mysql_localtimestamp in constraints, explain)
--Testcase 3234:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp() FROM time_tbl WHERE mysql_localtimestamp() > '2000-01-01 00:00:00'::timestamp;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_localtimestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((localtimestamp() > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_localtimestamp in constrains (stub function, explain)
--Testcase 3235:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE mysql_localtimestamp() > '2000-01-01 00:00:00'::timestamp;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((localtimestamp() > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_localtimestamp in constrains (stub function, result)
--Testcase 3236:
SELECT c1 FROM time_tbl WHERE mysql_localtimestamp() > '2000-01-01 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- mysql_localtimestamp as parameter of addtime(stub function, explain)
--Testcase 3237:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtimestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..171.86 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(localtimestamp(), '1 12:59:10.0') > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_localtimestamp as parameter of addtime(stub function, result)
--Testcase 3238:
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtimestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_localtimestamp and agg (pushdown, explain)
--Testcase 3239:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), sum(id) FROM time_tbl;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (mysql_localtimestamp()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtimestamp(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_localtimestamp and log2 (pushdown, explain)
--Testcase 3240:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: mysql_localtimestamp(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_localtimestamp with non pushdown func and explicit constant (explain)
--Testcase 3241:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: mysql_localtimestamp(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_localtimestamp with order by (explain)
--Testcase 3242:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), c1 FROM time_tbl ORDER BY mysql_localtimestamp();
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: mysql_localtimestamp(), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY localtimestamp() IS NULL ASC, localtimestamp() ASC
(4 rows)

-- select mysql_localtimestamp with order by index (explain)
--Testcase 3243:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), c1 FROM time_tbl ORDER BY 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: mysql_localtimestamp(), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY localtimestamp() IS NULL ASC, localtimestamp() ASC
(4 rows)

-- mysql_localtimestamp constraints with order by (explain)
--Testcase 3244:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtimestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp ORDER BY c1;
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(localtimestamp(), '1 12:59:10.0') > '2000-01-01 00:00:00')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- mysql_localtimestamp constraints with order by (result)
--Testcase 3245:
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtimestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select mysql_localtimestamp with group by (explain)
--Testcase 3246:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), c1 FROM time_tbl GROUP BY c1;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_localtimestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtimestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_localtimestamp with group by index (explain)
--Testcase 3247:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), c1 FROM time_tbl GROUP BY 2;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_localtimestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtimestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_localtimestamp with group by having (explain)
--Testcase 3248:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), c1 FROM time_tbl GROUP BY mysql_localtimestamp(),c1 HAVING mysql_localtimestamp() > '2000-01-01 00:00:00'::timestamp;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_localtimestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtimestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((localtimestamp() > '2000-01-01 00:00:00'))
(5 rows)

-- select mysql_localtimestamp with group by index having (explain)
--Testcase 3249:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp(), c1 FROM time_tbl GROUP BY 2,1 HAVING mysql_localtimestamp() > '2000-01-01 00:00:00'::timestamp;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_localtimestamp()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtimestamp(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((localtimestamp() > '2000-01-01 00:00:00'))
(5 rows)

-- mysql_localtimestamp constraints with group by (explain)
--Testcase 3250:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtimestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp GROUP BY c1;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(localtimestamp(), '1 12:59:10.0') > '2000-01-01 00:00:00')) GROUP BY 1
(5 rows)

-- mysql_localtimestamp constraints with group by (result)
--Testcase 3251:
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtimestamp(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_localtimestamp and as
--Testcase 3252:
EXPLAIN VERBOSE
SELECT mysql_localtimestamp() as mysql_localtimestamp1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_localtimestamp()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- LOCALTIME(), LOCALTIME
-- mysql_localtime is mutable function, some executes will return different result
-- select mysql_localtime (stub function, explain)
--Testcase 3253:
EXPLAIN VERBOSE
SELECT mysql_localtime() FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_localtime()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_localtime (stub function, not pushdown constraints, explain)
--Testcase 3254:
EXPLAIN VERBOSE
SELECT mysql_localtime() FROM time_tbl WHERE to_hex(id) > '0';
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_localtime()
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_localtime (stub function, pushdown constraints, explain)
--Testcase 3255:
EXPLAIN VERBOSE
SELECT mysql_localtime() FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..153.04 rows=17 width=8)
   Output: mysql_localtime()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select mysql_localtime (stub function, mysql_localtime in constraints, explain)
--Testcase 3256:
EXPLAIN VERBOSE
SELECT mysql_localtime() FROM time_tbl WHERE mysql_localtime() > '2000-01-01 00:00:00'::timestamp;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..186.80 rows=1138 width=8)
   Output: mysql_localtime()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl` WHERE ((localtime() > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_localtime in constrains (stub function, explain)
--Testcase 3257:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE mysql_localtime() > '2000-01-01 00:00:00'::timestamp;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..165.46 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((localtime() > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_localtime in constrains (stub function, result)
--Testcase 3258:
SELECT c1 FROM time_tbl WHERE mysql_localtime() > '2000-01-01 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- mysql_localtime as parameter of addtime(stub function, explain)
--Testcase 3259:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtime(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..171.86 rows=853 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(localtime(), '1 12:59:10.0') > '2000-01-01 00:00:00'))
(4 rows)

-- mysql_localtime as parameter of addtime(stub function, result)
--Testcase 3260:
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtime(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_localtime and agg (pushdown, explain)
--Testcase 3261:
EXPLAIN VERBOSE
SELECT mysql_localtime(), sum(id) FROM time_tbl;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (mysql_localtime()), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtime(), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_localtime and log2 (pushdown, explain)
--Testcase 3262:
EXPLAIN VERBOSE
SELECT mysql_localtime(), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=16)
   Output: mysql_localtime(), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_localtime with non pushdown func and explicit constant (explain)
--Testcase 3263:
EXPLAIN VERBOSE
SELECT mysql_localtime(), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: mysql_localtime(), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_localtime with order by (explain)
--Testcase 3264:
EXPLAIN VERBOSE
SELECT mysql_localtime(), c1 FROM time_tbl ORDER BY mysql_localtime();
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: mysql_localtime(), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY localtime() IS NULL ASC, localtime() ASC
(4 rows)

-- select mysql_localtime with order by index (explain)
--Testcase 3265:
EXPLAIN VERBOSE
SELECT mysql_localtime(), c1 FROM time_tbl ORDER BY 1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.07 rows=30 width=16)
   Output: mysql_localtime(), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY localtime() IS NULL ASC, localtime() ASC
(4 rows)

-- mysql_localtime constraints with order by (explain)
--Testcase 3266:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtime(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp ORDER BY c1;
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.00 rows=30 width=8)
   Output: c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(localtime(), '1 12:59:10.0') > '2000-01-01 00:00:00')) ORDER BY `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- mysql_localtime constraints with order by (result)
--Testcase 3267:
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtime(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp ORDER BY c1;
    c1    
----------
 00:59:59
 11:12:12
 12:10:30
 16:00:00
 23:12:13
(5 rows)

-- select mysql_localtime with group by (explain)
--Testcase 3268:
EXPLAIN VERBOSE
SELECT mysql_localtime(), c1 FROM time_tbl GROUP BY c1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_localtime()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_localtime with group by index (explain)
--Testcase 3269:
EXPLAIN VERBOSE
SELECT mysql_localtime(), c1 FROM time_tbl GROUP BY 2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (mysql_localtime()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select mysql_localtime with group by having (explain)
--Testcase 3270:
EXPLAIN VERBOSE
SELECT mysql_localtime(), c1 FROM time_tbl GROUP BY mysql_localtime(),c1 HAVING mysql_localtime() > '2000-01-01 00:00:00'::timestamp;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_localtime()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2 HAVING ((localtime() > '2000-01-01 00:00:00'))
(5 rows)

-- select mysql_localtime with group by index having (explain)
--Testcase 3271:
EXPLAIN VERBOSE
SELECT mysql_localtime(), c1 FROM time_tbl GROUP BY 2,1 HAVING mysql_localtime() > '2000-01-01 00:00:00'::timestamp;
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=853 width=16)
   Output: (mysql_localtime()), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT localtime(), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 1 HAVING ((localtime() > '2000-01-01 00:00:00'))
(5 rows)

-- mysql_localtime constraints with group by (explain)
--Testcase 3272:
EXPLAIN VERBOSE
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtime(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp GROUP BY c1;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=10.00..15.00 rows=199 width=8)
   Output: c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((addtime(localtime(), '1 12:59:10.0') > '2000-01-01 00:00:00')) GROUP BY 1
(5 rows)

-- mysql_localtime constraints with group by (result)
--Testcase 3273:
SELECT c1 FROM time_tbl WHERE addtime(mysql_localtime(), '1 12:59:10') > '2000-01-01 00:00:00'::timestamp GROUP BY c1;
    c1    
----------
 12:10:30
 23:12:13
 11:12:12
 16:00:00
 00:59:59
(5 rows)

-- select mysql_localtime and as
--Testcase 3274:
EXPLAIN VERBOSE
SELECT mysql_localtime() as mysql_localtime1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=8)
   Output: mysql_localtime()
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- LAST_DAY()
-- select last_day (stub function, explain)
--Testcase 3275:
EXPLAIN VERBOSE
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2275 width=16)
   Output: last_day(c3), last_day((c2)::timestamp without time zone), last_day(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), last_day('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select last_day (stub function, result)
--Testcase 3276:
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub last_day(timestamp) is called
CONTEXT:  PL/pgSQL function last_day(timestamp without time zone) line 3 at RAISE
-- select last_day (stub function, not pushdown constraints, explain)
--Testcase 3277:
EXPLAIN VERBOSE
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: last_day(c3), last_day((c2)::timestamp without time zone), last_day(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), last_day('2021-01-01 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select last_day (stub function, not pushdown constraints, result)
--Testcase 3278:
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub last_day(timestamp) is called
CONTEXT:  PL/pgSQL function last_day(timestamp without time zone) line 3 at RAISE
-- select last_day (stub function, pushdown constraints, explain)
--Testcase 3279:
EXPLAIN VERBOSE
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.68 rows=2264 width=16)
   Output: last_day(c3), last_day((c2)::timestamp without time zone), last_day(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), last_day('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select last_day (stub function, pushdown constraints, result)
--Testcase 3280:
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub last_day(timestamp) is called
CONTEXT:  PL/pgSQL function last_day(timestamp without time zone) line 3 at RAISE
-- select last_day (stub function, last_day in constraints, explain)
--Testcase 3281:
EXPLAIN VERBOSE
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE last_day(c3) > last_day('2000-01-01'::timestamp);
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..176.34 rows=758 width=16)
   Output: last_day(c3), last_day((c2)::timestamp without time zone), last_day(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), last_day('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((last_day(`c3`) > last_day('2000-01-01 00:00:00')))
(4 rows)

-- select last_day (stub function, last_day in constraints, result)
--Testcase 3282:
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE last_day(c3) > last_day('2000-01-01'::timestamp);
ERROR:  stub last_day(timestamp) is called
CONTEXT:  PL/pgSQL function last_day(timestamp without time zone) line 3 at RAISE
-- select last_day (stub function, last_day in constraints, explain)
--Testcase 3283:
EXPLAIN VERBOSE
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE last_day('2021-01-01 12:00:00'::timestamp) = '2021-01-31';
                                                                                               QUERY PLAN                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.51 rows=11 width=16)
   Output: last_day(c3), last_day((c2)::timestamp without time zone), last_day(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), last_day('2021-01-01 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((last_day('2021-01-01 12:00:00') = '2021-01-31'))
(4 rows)

-- select last_day (stub function, last_day in constraints, result)
--Testcase 3284:
SELECT last_day(c3), last_day(c2), last_day(date_sub(c3, '1 12:59:10')), last_day('2021-01-01 12:00:00'::timestamp) FROM time_tbl WHERE last_day('2021-01-01 12:00:00'::timestamp) = '2021-01-31';
ERROR:  stub last_day(timestamp) is called
CONTEXT:  PL/pgSQL function last_day(timestamp without time zone) line 3 at RAISE
-- select last_day with agg (pushdown, explain)
--Testcase 3285:
EXPLAIN VERBOSE
SELECT max(c3), last_day(max(c3)) FROM time_tbl;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (last_day(max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), last_day(max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select last_day as nest function with agg (pushdown, result)
--Testcase 3286:
SELECT max(c3), last_day(max(c3)) FROM time_tbl;
         max         |  last_day  
---------------------+------------
 2021-01-07 00:59:59 | 2021-01-31
(1 row)

-- select last_day with non pushdown func and explicit constant (explain)
--Testcase 3287:
EXPLAIN VERBOSE
SELECT last_day(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: last_day(date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select last_day with non pushdown func and explicit constant (result)
--Testcase 3288:
SELECT last_day(date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select last_day with order by (explain)
--Testcase 3289:
EXPLAIN VERBOSE
SELECT id, last_day(c3 + '1 12:59:10') FROM time_tbl order by last_day(c3 + '1 12:59:10');
                                                                                                                                          QUERY PLAN                                                                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=8)
   Output: id, last_day((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY last_day((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) IS NULL ASC, last_day((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) ASC
(4 rows)

-- select last_day with order by (result)
--Testcase 3290:
SELECT id, last_day(c3 + '1 12:59:10') FROM time_tbl order by last_day(c3 + '1 12:59:10');
ERROR:  stub last_day(timestamp) is called
CONTEXT:  PL/pgSQL function last_day(timestamp without time zone) line 3 at RAISE
-- select last_day with order by index (result)
--Testcase 3291:
SELECT id, last_day(c3 + '1 12:59:10') FROM time_tbl order by 2,1;
ERROR:  stub last_day(timestamp) is called
CONTEXT:  PL/pgSQL function last_day(timestamp without time zone) line 3 at RAISE
-- select last_day with order by index (result)
--Testcase 3292:
SELECT id, last_day(c3 + '1 12:59:10') FROM time_tbl order by 1,2;
ERROR:  stub last_day(timestamp) is called
CONTEXT:  PL/pgSQL function last_day(timestamp without time zone) line 3 at RAISE
-- select last_day with group by (explain)
--Testcase 3293:
EXPLAIN VERBOSE
SELECT max(c3), last_day(c3 + '1 12:59:10') FROM time_tbl group by last_day(c3 + '1 12:59:10');
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (max(c3)), (last_day((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), last_day((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select last_day with group by (result)
--Testcase 3294:
SELECT max(c3), last_day(c3 + '1 12:59:10') FROM time_tbl group by last_day(c3 + '1 12:59:10');
         max         |  last_day  
---------------------+------------
 2021-01-07 00:59:59 | 2021-01-31
(1 row)

-- select last_day with group by index (result)
--Testcase 3295:
SELECT id, last_day(c3 + '1 12:59:10') FROM time_tbl group by 2,1;
 id |  last_day  
----+------------
  0 | 2021-01-31
  1 | 2021-01-31
  2 | 2021-01-31
  3 | 2021-01-31
  4 | 2021-01-31
(5 rows)

-- select last_day with group by index (result)
--Testcase 3296:
SELECT id, last_day(c3 + '1 12:59:10') FROM time_tbl group by 1,2;
 id |  last_day  
----+------------
  0 | 2021-01-31
  1 | 2021-01-31
  2 | 2021-01-31
  3 | 2021-01-31
  4 | 2021-01-31
(5 rows)

-- select last_day with group by having (explain)
--Testcase 3297:
EXPLAIN VERBOSE
SELECT max(c3), last_day(c3 + '1 12:59:10') FROM time_tbl group by last_day(c3 + '1 12:59:10'), c3 HAVING last_day(c3 + '1 12:59:10') > '2001-01-31'::date;
                                                                                                                                                    QUERY PLAN                                                                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=20)
   Output: (max(c3)), (last_day((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval))), c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), last_day((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)), `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3 HAVING ((last_day((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND)) > '2001-01-31'))
(5 rows)

-- select last_day with group by having (result)
--Testcase 3298:
SELECT max(c3), last_day(c3 + '1 12:59:10') FROM time_tbl group by last_day(c3 + '1 12:59:10'), c3 HAVING last_day(c3 + '1 12:59:10') > '2001-01-31'::date;
         max         |  last_day  
---------------------+------------
 2021-01-03 12:10:30 | 2021-01-31
 2021-01-04 23:12:13 | 2021-01-31
 2021-01-05 11:12:12 | 2021-01-31
 2021-01-06 16:00:00 | 2021-01-31
 2021-01-07 00:59:59 | 2021-01-31
(5 rows)

-- select last_day with group by index having (result)
--Testcase 3299:
SELECT id, last_day(c3 + '1 12:59:10'), c3 FROM time_tbl group by 3, 2, 1 HAVING last_day(c3 + '1 12:59:10') > '2001-01-31'::date;
 id |  last_day  |         c3          
----+------------+---------------------
  0 | 2021-01-31 | 2021-01-03 12:10:30
  1 | 2021-01-31 | 2021-01-04 23:12:13
  2 | 2021-01-31 | 2021-01-05 11:12:12
  3 | 2021-01-31 | 2021-01-06 16:00:00
  4 | 2021-01-31 | 2021-01-07 00:59:59
(5 rows)

-- select last_day with group by index having (result)
--Testcase 3300:
SELECT id, last_day(c3 + '1 12:59:10'), c3 FROM time_tbl group by 1, 2, 3 HAVING last_day(c3 + '1 12:59:10') > '2001-01-31'::date;
 id |  last_day  |         c3          
----+------------+---------------------
  0 | 2021-01-31 | 2021-01-03 12:10:30
  1 | 2021-01-31 | 2021-01-04 23:12:13
  2 | 2021-01-31 | 2021-01-05 11:12:12
  3 | 2021-01-31 | 2021-01-06 16:00:00
  4 | 2021-01-31 | 2021-01-07 00:59:59
(5 rows)

-- select last_day and as
--Testcase 3301:
SELECT last_day(date_sub(c3, '1 12:59:10')) as last_day1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- HOUR()
-- select hour (stub function, explain)
--Testcase 3302:
EXPLAIN VERBOSE
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=8)
   Output: hour(c1), hour('23:00:00'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select hour (stub function, result)
--Testcase 3303:
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl;
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- select hour (stub function, not pushdown constraints, explain)
--Testcase 3304:
EXPLAIN VERBOSE
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl WHERE to_hex(id) = '1';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.72 rows=13 width=8)
   Output: hour(c1), hour('23:00:00'::time without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select hour (stub function, not pushdown constraints, result)
--Testcase 3305:
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- select hour (stub function, pushdown constraints, explain)
--Testcase 3306:
EXPLAIN VERBOSE
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl WHERE id != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..205.68 rows=2547 width=8)
   Output: hour(c1), hour('23:00:00'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select hour (stub function, pushdown constraints, result)
--Testcase 3307:
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl WHERE id != 200;
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- select hour (stub function, hour in constraints, explain)
--Testcase 3308:
EXPLAIN VERBOSE
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl WHERE hour(c1) = 12;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..148.72 rows=13 width=8)
   Output: hour(c1), hour('23:00:00'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((hour(`c1`) = 12))
(4 rows)

-- select hour (stub function, hour in constraints, result)
--Testcase 3309:
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl WHERE hour(c1) = 12;
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- select hour (stub function, hour in constraints, explain)
--Testcase 3310:
EXPLAIN VERBOSE
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl WHERE hour('22:00:00'::time) > '12';
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..169.72 rows=853 width=8)
   Output: hour(c1), hour('23:00:00'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((hour('22:00:00') > 12))
(4 rows)

-- select hour (stub function, hour in constraints, result)
--Testcase 3311:
SELECT hour(c1), hour('23:00:00'::time) FROM time_tbl WHERE hour('22:00:00'::time) > '12';
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- select hour with agg (pushdown, explain)
--Testcase 3312:
EXPLAIN VERBOSE
SELECT max(c1), hour(max(c1)) FROM time_tbl;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c1)), (hour(max(c1)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c1`), hour(max(`c1`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select hour as nest function with agg (pushdown, result)
--Testcase 3313:
SELECT max(c1), hour(max(c1)) FROM time_tbl;
   max    | hour 
----------+------
 23:12:13 |   23
(1 row)

-- select hour with non pushdown func and explicit constant (explain)
--Testcase 3314:
EXPLAIN VERBOSE
SELECT hour(maketime(18, 15, 30)), pi(), 4.1 FROM time_tbl;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..229.45 rows=3413 width=44)
   Output: hour(maketime(18, 15, 30)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select hour with non pushdown func and explicit constant (result)
--Testcase 3315:
SELECT hour(maketime(18, 15, 30)), pi(), 4.1 FROM time_tbl;
ERROR:  stub maketime(integer, integer, integer) is called
CONTEXT:  PL/pgSQL function maketime(integer,integer,integer) line 3 at RAISE
-- select hour with order by (explain)
--Testcase 3316:
EXPLAIN VERBOSE
SELECT id, hour(c1), hour('23:00:00'::time) FROM time_tbl order by hour(c1), hour('23:00:00'::time);
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: id, hour(c1), hour('23:00:00'::time without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY hour(`c1`) IS NULL ASC, hour(`c1`) ASC, hour('23:00:00') IS NULL ASC, hour('23:00:00') ASC
(4 rows)

-- select hour with order by (result)
--Testcase 3317:
SELECT id, hour(c1), hour('23:00:00'::time) FROM time_tbl order by hour(c1), hour('23:00:00'::time);
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- select hour with order by index (result)
--Testcase 3318:
SELECT id, hour(c1), hour('23:00:00'::time) FROM time_tbl order by 3,2,1;
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- select hour with order by index (result)
--Testcase 3319:
SELECT id, hour(c1), hour('23:00:00'::time) FROM time_tbl order by 1,2,3;
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- select hour with group by (explain)
--Testcase 3320:
EXPLAIN VERBOSE
SELECT max(c3), hour('23:00:00'::time) FROM time_tbl group by hour('05:00:00'::time);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2560 width=16)
   Output: (max(c3)), (hour('23:00:00'::time without time zone)), (hour('05:00:00'::time without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), hour('23:00:00'), hour('05:00:00') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 3
(5 rows)

-- select hour with group by (result)
--Testcase 3321:
SELECT max(c3), hour('23:00:00'::time) FROM time_tbl group by hour('05:00:00'::time);
         max         | hour 
---------------------+------
 2021-01-07 00:59:59 |   23
(1 row)

-- select hour with group by index (result)
--Testcase 3322:
SELECT id, hour(c1), hour('23:00:00'::time) FROM time_tbl group by 3,2,1;
 id | hour | hour 
----+------+------
  0 |   12 |   23
  1 |   23 |   23
  2 |   11 |   23
  3 |   16 |   23
  4 |    0 |   23
(5 rows)

-- select hour with group by index (result)
--Testcase 3323:
SELECT id, hour(c1), hour('23:00:00'::time) FROM time_tbl group by 1,2,3;
 id | hour | hour 
----+------+------
  0 |   12 |   23
  1 |   23 |   23
  2 |   11 |   23
  3 |   16 |   23
  4 |    0 |   23
(5 rows)

-- select hour with group by having (explain)
--Testcase 3324:
EXPLAIN VERBOSE
SELECT max(c3), hour(c1), hour('23:00:00'::time) FROM time_tbl group by hour(c1),hour('23:00:00'::time), c1,c3 HAVING hour(c1) < 24;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=683 width=32)
   Output: (max(c3)), (hour(c1)), (hour('23:00:00'::time without time zone)), c1, c3
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), hour(`c1`), hour('23:00:00'), `c1`, `c3` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 4, 5 HAVING ((hour(`c1`) < 24))
(5 rows)

-- select hour with group by having (result)
--Testcase 3325:
SELECT max(c3), hour(c1), hour('23:00:00'::time) FROM time_tbl group by hour(c1),hour('23:00:00'::time), c1,c3 HAVING hour(c1) < 24;
         max         | hour | hour 
---------------------+------+------
 2021-01-03 12:10:30 |   12 |   23
 2021-01-04 23:12:13 |   23 |   23
 2021-01-05 11:12:12 |   11 |   23
 2021-01-06 16:00:00 |   16 |   23
 2021-01-07 00:59:59 |    0 |   23
(5 rows)

-- select hour with group by index having (result)
--Testcase 3326:
SELECT id, c1, hour(c1), hour('23:00:00'::time) FROM time_tbl group by 4, 3, 2, 1 HAVING hour(c1) < 24;
 id |    c1    | hour | hour 
----+----------+------+------
  0 | 12:10:30 |   12 |   23
  1 | 23:12:13 |   23 |   23
  2 | 11:12:12 |   11 |   23
  3 | 16:00:00 |   16 |   23
  4 | 00:59:59 |    0 |   23
(5 rows)

-- select hour with group by index having (result)
--Testcase 3327:
SELECT id, c1, hour(c1), hour('23:00:00'::time) FROM time_tbl group by 1, 2, 3, 4 HAVING hour(c1) < 24;
 id |    c1    | hour | hour 
----+----------+------+------
  0 | 12:10:30 |   12 |   23
  1 | 23:12:13 |   23 |   23
  2 | 11:12:12 |   11 |   23
  3 | 16:00:00 |   16 |   23
  4 | 00:59:59 |    0 |   23
(5 rows)

-- select hour and as
--Testcase 3328:
SELECT hour(c1) as hour1, hour('23:00:00'::time) as hour2 FROM time_tbl;
ERROR:  stub hour(time without time zone) is called
CONTEXT:  PL/pgSQL function hour(time without time zone) line 3 at RAISE
-- GET_FORMAT()
-- Returns a format string. This function is useful in combination with the DATE_FORMAT() and the STR_TO_DATE() functions.
-- select get_format (stub function, explain)
--Testcase 3329:
EXPLAIN VERBOSE
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl;
                                                                                                                  QUERY PLAN                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..218.06 rows=2275 width=128)
   Output: get_format('date'::text, 'usa'::text), date_format((c2)::timestamp without time zone, get_format('date'::text, 'usa'::text)), get_format('datetime'::text, 'jis'::text), date_format(c3, get_format('datetime'::text, 'jis'::text))
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select get_format (stub function, result)
--Testcase 3330:
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl;
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format (stub function, not pushdown constraints, explain)
--Testcase 3331:
EXPLAIN VERBOSE
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                                  QUERY PLAN                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.54 rows=11 width=128)
   Output: get_format('date'::text, 'usa'::text), date_format((c2)::timestamp without time zone, get_format('date'::text, 'usa'::text)), get_format('datetime'::text, 'jis'::text), date_format(c3, get_format('datetime'::text, 'jis'::text))
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select get_format (stub function, not pushdown constraints, result)
--Testcase 3332:
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format (stub function, pushdown constraints, explain)
--Testcase 3333:
EXPLAIN VERBOSE
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl WHERE id != 0;
                                                                                                                  QUERY PLAN                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..223.34 rows=2264 width=128)
   Output: get_format('date'::text, 'usa'::text), date_format((c2)::timestamp without time zone, get_format('date'::text, 'usa'::text)), get_format('datetime'::text, 'jis'::text), date_format(c3, get_format('datetime'::text, 'jis'::text))
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 0))
(4 rows)

-- select get_format (stub function, pushdown constraints, result)
--Testcase 3334:
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl WHERE id != 0;
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format (stub function, get_format in constraints, explain)
--Testcase 3335:
EXPLAIN VERBOSE
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl WHERE get_format('date', 'usa') IS NOT NULL;
                                                                                                                  QUERY PLAN                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..223.34 rows=2264 width=128)
   Output: get_format('date'::text, 'usa'::text), date_format((c2)::timestamp without time zone, get_format('date'::text, 'usa'::text)), get_format('datetime'::text, 'jis'::text), date_format(c3, get_format('datetime'::text, 'jis'::text))
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((get_format(date, 'usa') IS NOT NULL))
(4 rows)

-- select get_format (stub function, get_format in constraints, result)
--Testcase 3336:
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl WHERE get_format('date', 'usa') IS NOT NULL;
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format (stub function, get_format in constraints, explain)
--Testcase 3337:
EXPLAIN VERBOSE
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl WHERE date_format(c3, get_format('datetime', 'jis')) IS NOT NULL;
                                                                                                                  QUERY PLAN                                                                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..229.02 rows=2264 width=128)
   Output: get_format('date'::text, 'usa'::text), date_format((c2)::timestamp without time zone, get_format('date'::text, 'usa'::text)), get_format('datetime'::text, 'jis'::text), date_format(c3, get_format('datetime'::text, 'jis'::text))
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((date_format(`c3`, get_format(datetime, 'jis')) IS NOT NULL))
(4 rows)

-- select get_format (stub function, get_format in constraints, result)
--Testcase 3338:
SELECT get_format('date', 'usa'), date_format(c2, get_format('date', 'usa')), get_format('datetime', 'jis'), date_format(c3, get_format('datetime', 'jis')) FROM time_tbl WHERE date_format(c3, get_format('datetime', 'jis')) IS NOT NULL;
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format as nest function with agg (pushdown, explain)
--Testcase 3339:
EXPLAIN VERBOSE
SELECT max(c2), date_format(max(c3), get_format('datetime', 'jis')) FROM time_tbl;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=36)
   Output: (max(c2)), (date_format(max(c3), get_format('datetime'::text, 'jis'::text)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c2`), date_format(max(`c3`), get_format(datetime, 'jis')) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select get_format as nest function with agg (pushdown, result)
--Testcase 3340:
SELECT max(c2), date_format(max(c3), get_format('datetime', 'jis')) FROM time_tbl;
    max     |     date_format     
------------+---------------------
 2021-01-29 | 2021-01-07 00:59:59
(1 row)

-- select get_format with non pushdown func and explicit constant (explain)
--Testcase 3341:
EXPLAIN VERBOSE
SELECT get_format('datetime', 'jis'), pi(), 4.1 FROM time_tbl;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..220.92 rows=3413 width=72)
   Output: get_format('datetime'::text, 'jis'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select get_format with non pushdown func and explicit constant (result)
--Testcase 3342:
SELECT get_format('datetime', 'jis'), pi(), 4.1 FROM time_tbl;
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format with order by (explain)
--Testcase 3343:
EXPLAIN VERBOSE
SELECT id, date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) FROM time_tbl order by date_format(c3 + '1 12:59:10', get_format('datetime', 'jis'));
                                                                                                                                                                          QUERY PLAN                                                                                                                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.23 rows=30 width=36)
   Output: id, date_format((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), get_format('datetime'::text, 'jis'::text))
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY date_format((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), get_format(datetime, 'jis')) IS NULL ASC, date_format((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), get_format(datetime, 'jis')) ASC
(4 rows)

-- select get_format with order by (result)
--Testcase 3344:
SELECT id, date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) FROM time_tbl order by date_format(c3 + '1 12:59:10', get_format('datetime', 'jis'));
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format with order by index (result)
--Testcase 3345:
SELECT id, date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) FROM time_tbl order by 2,1;
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format with order by index (result)
--Testcase 3346:
SELECT id, date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) FROM time_tbl order by 1,2;
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- select get_format with group by (explain)
--Testcase 3347:
EXPLAIN VERBOSE
SELECT count(id), date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) FROM time_tbl group by date_format(c3 + '1 12:59:10', get_format('datetime', 'jis'));
                                                                                                    QUERY PLAN                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(id)), (date_format((c3 + '@ 1 day 12 hours 59 mins 10 secs'::interval), get_format('datetime'::text, 'jis'::text)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), date_format((`c3` + INTERVAL 1 DAY + INTERVAL 12 HOUR + INTERVAL 59 MINUTE + INTERVAL 10 SECOND), get_format(datetime, 'jis')) FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select get_format with group by (result)
--Testcase 3348:
SELECT count(id), date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) FROM time_tbl group by date_format(c3 + '1 12:59:10', get_format('datetime', 'jis'));
 count |     date_format     
-------+---------------------
     1 | 2021-01-05 01:09:40
     1 | 2021-01-06 12:11:23
     1 | 2021-01-07 00:11:22
     1 | 2021-01-08 04:59:10
     1 | 2021-01-08 13:59:09
(5 rows)

-- select get_format with group by index (result)
--Testcase 3349:
SELECT id, date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) FROM time_tbl group by 2,1;
 id |     date_format     
----+---------------------
  0 | 2021-01-05 01:09:40
  1 | 2021-01-06 12:11:23
  2 | 2021-01-07 00:11:22
  3 | 2021-01-08 04:59:10
  4 | 2021-01-08 13:59:09
(5 rows)

-- select get_format with group by index (result)
--Testcase 3350:
SELECT id, date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) FROM time_tbl group by 1,2;
 id |     date_format     
----+---------------------
  0 | 2021-01-05 01:09:40
  1 | 2021-01-06 12:11:23
  2 | 2021-01-07 00:11:22
  3 | 2021-01-08 04:59:10
  4 | 2021-01-08 13:59:09
(5 rows)

-- select get_format with group by index having (result)
--Testcase 3351:
SELECT id, date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')), c3 FROM time_tbl group by 3,2,1 HAVING date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) > '2000-01-02';
 id |     date_format     |         c3          
----+---------------------+---------------------
  0 | 2021-01-05 01:09:40 | 2021-01-03 12:10:30
  1 | 2021-01-06 12:11:23 | 2021-01-04 23:12:13
  2 | 2021-01-07 00:11:22 | 2021-01-05 11:12:12
  3 | 2021-01-08 04:59:10 | 2021-01-06 16:00:00
  4 | 2021-01-08 13:59:09 | 2021-01-07 00:59:59
(5 rows)

-- select get_format with group by index having (result)
--Testcase 3352:
SELECT id, date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')), c3 FROM time_tbl group by 1,2,3 HAVING date_format(c3 + '1 12:59:10', get_format('datetime', 'jis')) > '2000-01-02';
 id |     date_format     |         c3          
----+---------------------+---------------------
  0 | 2021-01-05 01:09:40 | 2021-01-03 12:10:30
  1 | 2021-01-06 12:11:23 | 2021-01-04 23:12:13
  2 | 2021-01-07 00:11:22 | 2021-01-05 11:12:12
  3 | 2021-01-08 04:59:10 | 2021-01-06 16:00:00
  4 | 2021-01-08 13:59:09 | 2021-01-07 00:59:59
(5 rows)

-- select get_format and as
--Testcase 3353:
SELECT get_format('datetime', 'jis') as get_format1 FROM time_tbl;
ERROR:  stub get_format(text, text) is called
CONTEXT:  PL/pgSQL function get_format(text,text) line 3 at RAISE
-- FROM_UNIXTIME()
-- select from_unixtime (stub function, explain)
--Testcase 3354:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..227.00 rows=2925 width=40)
   Output: from_unixtime('1447430881'::bigint), from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select from_unixtime (stub function, result)
--Testcase 3355:
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl;
ERROR:  stub from_unixtime(bigint) is called
CONTEXT:  PL/pgSQL function from_unixtime(bigint) line 3 at RAISE
-- select from_unixtime (stub function, not pushdown constraints, explain)
--Testcase 3356:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl WHERE to_hex(id) > '0';
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..183.12 rows=975 width=40)
   Output: from_unixtime('1447430881'::bigint), from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select from_unixtime (stub function, not pushdown constraints, result)
--Testcase 3357:
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl WHERE to_hex(id) > '0';
ERROR:  stub from_unixtime(bigint) is called
CONTEXT:  PL/pgSQL function from_unixtime(bigint) line 3 at RAISE
-- select from_unixtime (stub function, pushdown constraints, explain)
--Testcase 3358:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl WHERE id = 1;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..147.01 rows=15 width=40)
   Output: from_unixtime('1447430881'::bigint), from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select from_unixtime (stub function, pushdown constraints, result)
--Testcase 3359:
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl WHERE id = 1;
ERROR:  stub from_unixtime(bigint) is called
CONTEXT:  PL/pgSQL function from_unixtime(bigint) line 3 at RAISE
-- select from_unixtime (stub function, from_unixtime in constraints, explain)
--Testcase 3360:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl WHERE from_unixtime(id + 1447430881) > from_unixtime(1447430881);
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..205.06 rows=975 width=40)
   Output: from_unixtime('1447430881'::bigint), from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((from_unixtime((`id` + 1447430881)) > from_unixtime(1447430881)))
(4 rows)

-- select from_unixtime (stub function, from_unixtime in constraints, result)
--Testcase 3361:
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl WHERE from_unixtime(id + 1447430881) > from_unixtime(1447430881);
ERROR:  stub from_unixtime(bigint) is called
CONTEXT:  PL/pgSQL function from_unixtime(bigint) line 3 at RAISE
-- select from_unixtime and agg (pushdown, explain)
--Testcase 3362:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), sum(id) FROM time_tbl;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=16)
   Output: (from_unixtime('1447430881'::bigint)), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT from_unixtime(1447430881), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select from_unixtime and log2 (pushdown, result)
--Testcase 3363:
SELECT from_unixtime(1447430881), log2(id) FROM time_tbl;
ERROR:  stub from_unixtime(bigint) is called
CONTEXT:  PL/pgSQL function from_unixtime(bigint) line 3 at RAISE
-- select from_unixtime with non pushdown func and explicit constant (explain)
--Testcase 3364:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=44)
   Output: from_unixtime('1447430881'::bigint), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select from_unixtime with order by (explain)
--Testcase 3365:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x'), c1 FROM time_tbl ORDER BY from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x');
                                                                                                                                         QUERY PLAN                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=48)
   Output: from_unixtime('1447430881'::bigint), from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY from_unixtime(1447430881) IS NULL ASC, from_unixtime(1447430881) ASC, from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x') IS NULL ASC, from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x') ASC
(4 rows)

-- select from_unixtime with order by index (explain)
--Testcase 3366:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x'), c1 FROM time_tbl ORDER BY 1,2,3;
                                                                                                                                                       QUERY PLAN                                                                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=48)
   Output: from_unixtime('1447430881'::bigint), from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY from_unixtime(1447430881) IS NULL ASC, from_unixtime(1447430881) ASC, from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x') IS NULL ASC, from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x') ASC, `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- from_unixtime constraints with order by (explain)
--Testcase 3367:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl WHERE from_unixtime(id + 1447430881) > from_unixtime(1447430881) ORDER BY from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x');
                                                                                                                                                                           QUERY PLAN                                                                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=40)
   Output: from_unixtime('1447430881'::bigint), from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((from_unixtime((`id` + 1447430881)) > from_unixtime(1447430881))) ORDER BY from_unixtime(1447430881) IS NULL ASC, from_unixtime(1447430881) ASC, from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x') IS NULL ASC, from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x') ASC
(4 rows)

-- from_unixtime constraints with order by (result)
--Testcase 3368:
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') FROM time_tbl WHERE from_unixtime(id + 1447430881) > from_unixtime(1447430881) ORDER BY from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x');
ERROR:  stub from_unixtime(bigint) is called
CONTEXT:  PL/pgSQL function from_unixtime(bigint) line 3 at RAISE
-- select from_unixtime with group by (explain)
--Testcase 3369:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x'), c1 FROM time_tbl GROUP BY c1,id;
                                                                                 QUERY PLAN                                                                                 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=52)
   Output: (from_unixtime('1447430881'::bigint)), (from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)), c1, id
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT from_unixtime(1447430881), from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x'), `c1`, `id` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 3, 4
(5 rows)

-- select from_unixtime with group by index (explain)
--Testcase 3370:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x'), c1 FROM time_tbl GROUP BY 1,2,3;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2275 width=48)
   Output: (from_unixtime('1447430881'::bigint)), (from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT from_unixtime(1447430881), from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x'), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3
(5 rows)

-- select from_unixtime with group by index having (explain)
--Testcase 3371:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x'), c1 FROM time_tbl GROUP BY 1,2,3 HAVING from_unixtime(1447430881) = '2015-11-13 08:08:01';
                                                                                                              QUERY PLAN                                                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=11 width=48)
   Output: (from_unixtime('1447430881'::bigint)), (from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT from_unixtime(1447430881), from_unixtime((`id` + 1447430881), '%Y %D %M %h:%i:%s %x'), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3 HAVING ((from_unixtime(1447430881) = '2015-11-13 08:08:01'))
(5 rows)

-- select from_unixtime with group by index having (result)
--Testcase 3372:
SELECT from_unixtime(1447430881), from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x'), c1 FROM time_tbl GROUP BY 1,2,3 HAVING from_unixtime(1447430881) = '2015-11-13 08:08:01';
    from_unixtime    |          from_unixtime           |    c1    
---------------------+----------------------------------+----------
 2015-11-13 08:08:01 | 2015 13th November 08:08:01 2015 | 12:10:30
 2015-11-13 08:08:01 | 2015 13th November 08:08:02 2015 | 23:12:13
 2015-11-13 08:08:01 | 2015 13th November 08:08:03 2015 | 11:12:12
 2015-11-13 08:08:01 | 2015 13th November 08:08:04 2015 | 16:00:00
 2015-11-13 08:08:01 | 2015 13th November 08:08:05 2015 | 00:59:59
(5 rows)

-- select from_unixtime and as
--Testcase 3373:
EXPLAIN VERBOSE
SELECT from_unixtime(1447430881) as from_unixtime1, from_unixtime(id + 1447430881, '%Y %D %M %h:%i:%s %x') as from_unixtime2 FROM time_tbl;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..227.00 rows=2925 width=40)
   Output: from_unixtime('1447430881'::bigint), from_unixtime(((id + 1447430881))::bigint, '%Y %D %M %h:%i:%s %x'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- FROM_DAYS()
-- select from_days (stub function, explain)
--Testcase 3374:
EXPLAIN VERBOSE
SELECT from_days(id + 200719) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=4)
   Output: from_days((id + 200719))
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select from_days (stub function, result)
--Testcase 3375:
SELECT from_days(id + 200719) FROM time_tbl;
ERROR:  stub from_days(integer) is called
CONTEXT:  PL/pgSQL function from_days(integer) line 3 at RAISE
-- select from_days (stub function, not pushdown constraints, explain)
--Testcase 3376:
EXPLAIN VERBOSE
SELECT from_days(id + 200719) FROM time_tbl WHERE to_hex(id) > '0';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.25 rows=975 width=4)
   Output: from_days((id + 200719))
   Filter: (to_hex(time_tbl.id) > '0'::text)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select from_days (stub function, not pushdown constraints, result)
--Testcase 3377:
SELECT from_days(id + 200719) FROM time_tbl WHERE to_hex(id) > '0';
ERROR:  stub from_days(integer) is called
CONTEXT:  PL/pgSQL function from_days(integer) line 3 at RAISE
-- select from_days (stub function, pushdown constraints, explain)
--Testcase 3378:
EXPLAIN VERBOSE
SELECT from_days(id + 200719) FROM time_tbl WHERE id = 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..146.94 rows=15 width=4)
   Output: from_days((id + 200719))
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` = 1))
(4 rows)

-- select from_days (stub function, pushdown constraints, result)
--Testcase 3379:
SELECT from_days(id + 200719) FROM time_tbl WHERE id = 1;
ERROR:  stub from_days(integer) is called
CONTEXT:  PL/pgSQL function from_days(integer) line 3 at RAISE
-- from_days in constrains (stub function, explain)
--Testcase 3380:
EXPLAIN VERBOSE
SELECT from_days(id + 200719) FROM time_tbl WHERE from_days(id + 200719) > from_days(day('2001-01-01'::date));
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..200.19 rows=975 width=4)
   Output: from_days((id + 200719))
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((from_days((`id` + 200719)) > from_days(day('2001-01-01 00:00:00'))))
(4 rows)

-- from_days in constrains (stub function, result)
--Testcase 3381:
SELECT from_days(id + 200719) FROM time_tbl WHERE from_days(id + 200719) > from_days(day('2001-01-01'::date));
ERROR:  stub from_days(integer) is called
CONTEXT:  PL/pgSQL function from_days(integer) line 3 at RAISE
-- select from_days and agg (pushdown, explain)
--Testcase 3382:
EXPLAIN VERBOSE
SELECT from_days(max(id) + 200719), sum(id) FROM time_tbl;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (from_days((max(id) + 200719))), (sum(id))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT from_days((max(`id`) + 200719)), sum(`id`) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select from_days and agg (pushdown, result)
--Testcase 3383:
SELECT from_days(max(id) + 200719), sum(id) FROM time_tbl;
 from_days  | sum 
------------+-----
 0549-07-24 |  10
(1 row)

-- select from_days and log2 (pushdown, explain)
--Testcase 3384:
EXPLAIN VERBOSE
SELECT from_days(id + 200719), log2(id) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..227.00 rows=2925 width=12)
   Output: from_days((id + 200719)), log2((id)::double precision)
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select from_days and log2 (pushdown, result)
--Testcase 3385:
SELECT from_days(id + 200719), log2(id) FROM time_tbl;
ERROR:  stub from_days(integer) is called
CONTEXT:  PL/pgSQL function from_days(integer) line 3 at RAISE
-- select from_days with non pushdown func and explicit constant (explain)
--Testcase 3386:
EXPLAIN VERBOSE
SELECT from_days(id + 200719), to_hex(id), 4 FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.69 rows=2925 width=40)
   Output: from_days((id + 200719)), to_hex(id), 4
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select from_days with order by (explain)
--Testcase 3387:
EXPLAIN VERBOSE
SELECT from_days(id + 200719), c1 FROM time_tbl ORDER BY from_days(id + 200719);
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: from_days((id + 200719)), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY from_days((`id` + 200719)) IS NULL ASC, from_days((`id` + 200719)) ASC
(4 rows)

-- select from_days with order by index (explain)
--Testcase 3388:
EXPLAIN VERBOSE
SELECT from_days(id + 200719), c1 FROM time_tbl ORDER BY 1,2;
                                                                                    QUERY PLAN                                                                                     
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: from_days((id + 200719)), c1
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY from_days((`id` + 200719)) IS NULL ASC, from_days((`id` + 200719)) ASC, `c1` IS NULL ASC, `c1` ASC
(4 rows)

-- from_days constraints with order by (explain)
--Testcase 3389:
EXPLAIN VERBOSE
SELECT from_days(id + 200719) FROM time_tbl WHERE from_days(id + 200719) > from_days(day('2001-01-01'::date)) ORDER BY from_days(id + 200719);
                                                                                                          QUERY PLAN                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=4)
   Output: from_days((id + 200719))
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((from_days((`id` + 200719)) > from_days(day('2001-01-01 00:00:00')))) ORDER BY from_days((`id` + 200719)) IS NULL ASC, from_days((`id` + 200719)) ASC
(4 rows)

-- from_days constraints with order by (result)
--Testcase 3390:
SELECT from_days(id + 200719) FROM time_tbl WHERE from_days(id + 200719) > from_days(day('2001-01-01'::date)) ORDER BY from_days(id + 200719);
ERROR:  stub from_days(integer) is called
CONTEXT:  PL/pgSQL function from_days(integer) line 3 at RAISE
-- select from_days with group by (explain)
--Testcase 3391:
EXPLAIN VERBOSE
SELECT from_days(id + 200719), c1 FROM time_tbl GROUP BY c1,id;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=16)
   Output: (from_days((id + 200719))), c1, id
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT from_days((`id` + 200719)), `c1`, `id` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3
(5 rows)

-- select from_days with group by index (explain)
--Testcase 3392:
EXPLAIN VERBOSE
SELECT from_days(id + 200719), c1 FROM time_tbl GROUP BY 1,2;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=12)
   Output: (from_days((id + 200719))), c1
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT from_days((`id` + 200719)), `c1` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2
(5 rows)

-- select from_days with group by having (explain)
--Testcase 3393:
EXPLAIN VERBOSE
SELECT from_days(id + 200719), c1 FROM time_tbl GROUP BY from_days(id + 200719),c1,id HAVING from_days(id + 200719) > '0549-07-21';
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=76 width=16)
   Output: (from_days((id + 200719))), c1, id
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT from_days((`id` + 200719)), `c1`, `id` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 1, 2, 3 HAVING ((from_days((`id` + 200719)) > '0549-07-21'))
(5 rows)

-- select from_days with group by index having (result)
--Testcase 3394:
SELECT id, from_days(id + 200719), c1 FROM time_tbl GROUP BY 1,2,3 HAVING from_days(id + 200719) > '0549-07-21';
 id | from_days  |    c1    
----+------------+----------
  2 | 0549-07-22 | 11:12:12
  3 | 0549-07-23 | 16:00:00
  4 | 0549-07-24 | 00:59:59
(3 rows)

-- select from_days and as
--Testcase 3395:
EXPLAIN VERBOSE
SELECT from_days(id + 200719) as from_days1 FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=4)
   Output: from_days((id + 200719))
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- EXTRACT()
-- select mysql_extract (stub function, explain)
--Testcase 3396:
EXPLAIN VERBOSE
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..201.00 rows=2275 width=12)
   Output: mysql_extract('YEAR'::text, (c2)::timestamp without time zone), mysql_extract('MICROSECOND'::text, '2021-01-03 12:10:30.123456'::timestamp without time zone), mysql_extract('DAY_MINUTE'::text, c3)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_extract (stub function, result)
--Testcase 3397:
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select mysql_extract (stub function, not pushdown constraints, explain)
--Testcase 3398:
EXPLAIN VERBOSE
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.46 rows=11 width=12)
   Output: mysql_extract('YEAR'::text, (c2)::timestamp without time zone), mysql_extract('MICROSECOND'::text, '2021-01-03 12:10:30.123456'::timestamp without time zone), mysql_extract('DAY_MINUTE'::text, c3)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_extract (stub function, not pushdown constraints, result)
--Testcase 3399:
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select mysql_extract (stub function, pushdown constraints, explain)
--Testcase 3400:
EXPLAIN VERBOSE
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl WHERE id != 200;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.36 rows=2264 width=12)
   Output: mysql_extract('YEAR'::text, (c2)::timestamp without time zone), mysql_extract('MICROSECOND'::text, '2021-01-03 12:10:30.123456'::timestamp without time zone), mysql_extract('DAY_MINUTE'::text, c3)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select mysql_extract (stub function, pushdown constraints, result)
--Testcase 3401:
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl WHERE id != 200;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select mysql_extract (stub function, mysql_extract in constraints, explain)
--Testcase 3402:
EXPLAIN VERBOSE
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl WHERE mysql_extract('YEAR_MONTH', c3 ) != mysql_extract('YEAR_MONTH', '2000-01-01'::timestamp);
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..217.73 rows=2264 width=12)
   Output: mysql_extract('YEAR'::text, (c2)::timestamp without time zone), mysql_extract('MICROSECOND'::text, '2021-01-03 12:10:30.123456'::timestamp without time zone), mysql_extract('DAY_MINUTE'::text, c3)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((extract(YEAR_MONTH FROM `c3`) <> extract(YEAR_MONTH FROM '2000-01-01 00:00:00')))
(4 rows)

-- select mysql_extract (stub function, mysql_extract in constraints, result)
--Testcase 3403:
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl WHERE mysql_extract('YEAR_MONTH', c3 ) != mysql_extract('YEAR_MONTH', '2000-01-01'::timestamp);
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select mysql_extract (stub function, mysql_extract in constraints, explain)
--Testcase 3404:
EXPLAIN VERBOSE
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl WHERE mysql_extract('YEAR_MONTH', c3 ) > '1';
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..166.87 rows=758 width=12)
   Output: mysql_extract('YEAR'::text, (c2)::timestamp without time zone), mysql_extract('MICROSECOND'::text, '2021-01-03 12:10:30.123456'::timestamp without time zone), mysql_extract('DAY_MINUTE'::text, c3)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((extract(YEAR_MONTH FROM `c3`) > 1))
(4 rows)

-- select mysql_extract (stub function, mysql_extract in constraints, result)
--Testcase 3405:
SELECT mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl WHERE mysql_extract('YEAR_MONTH', c3 ) > '1';
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select mysql_extract with agg (pushdown, explain)
--Testcase 3406:
EXPLAIN VERBOSE
SELECT max(c3), mysql_extract('YEAR', max(c3)) FROM time_tbl;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (max(c3)), (mysql_extract('YEAR'::text, max(c3)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), extract(YEAR FROM max(`c3`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select mysql_extract as nest function with agg (pushdown, result)
--Testcase 3407:
SELECT max(c3), mysql_extract('YEAR', max(c3)) FROM time_tbl;
         max         | mysql_extract 
---------------------+---------------
 2021-01-07 00:59:59 |          2021
(1 row)

-- select mysql_extract with non pushdown func and explicit constant (explain)
--Testcase 3408:
EXPLAIN VERBOSE
SELECT mysql_extract('YEAR', date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..199.60 rows=2560 width=44)
   Output: mysql_extract('YEAR'::text, date_sub(c3, '@ 1 day 12 hours 59 mins 10 secs'::interval)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select mysql_extract with non pushdown func and explicit constant (result)
--Testcase 3409:
SELECT mysql_extract('YEAR', date_sub(c3, '1 12:59:10')), pi(), 4.1 FROM time_tbl;
ERROR:  stub date_sub(timestamp, interval) is called
CONTEXT:  PL/pgSQL function date_sub(timestamp without time zone,interval) line 3 at RAISE
-- select mysql_extract with order by (explain)
--Testcase 3410:
EXPLAIN VERBOSE
SELECT id, mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl order by mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3);
                                                                                                                                                                             QUERY PLAN                                                                                                                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.30 rows=30 width=16)
   Output: id, mysql_extract('YEAR'::text, (c2)::timestamp without time zone), mysql_extract('MICROSECOND'::text, '2021-01-03 12:10:30.123456'::timestamp without time zone), mysql_extract('DAY_MINUTE'::text, c3)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY extract(YEAR FROM `c2`) IS NULL ASC, extract(YEAR FROM `c2`) ASC, extract(MICROSECOND FROM '2021-01-03 12:10:30.123456') IS NULL ASC, extract(MICROSECOND FROM '2021-01-03 12:10:30.123456') ASC, extract(DAY_MINUTE FROM `c3`) IS NULL ASC, extract(DAY_MINUTE FROM `c3`) ASC
(4 rows)

-- select mysql_extract with order by (result)
--Testcase 3411:
SELECT id, mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl order by mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3);
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select mysql_extract with order by index (result)
--Testcase 3412:
SELECT id, mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl order by 4,3,2,1;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select mysql_extract with order by index (result)
--Testcase 3413:
SELECT id, mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl order by 1,2,3,4;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- select mysql_extract with group by (explain)
--Testcase 3414:
EXPLAIN VERBOSE
SELECT max(c3), mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl group by mysql_extract('DAY_MINUTE', c3),c2;
                                                                                                             QUERY PLAN                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=228 width=24)
   Output: (max(c3)), (mysql_extract('YEAR'::text, (c2)::timestamp without time zone)), (mysql_extract('MICROSECOND'::text, '2021-01-03 12:10:30.123456'::timestamp without time zone)), (mysql_extract('DAY_MINUTE'::text, c3)), c2
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), extract(YEAR FROM `c2`), extract(MICROSECOND FROM '2021-01-03 12:10:30.123456'), extract(DAY_MINUTE FROM `c3`), `c2` FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 4, 5
(5 rows)

-- select mysql_extract with group by (result)
--Testcase 3415:
SELECT max(c3), mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl group by mysql_extract('DAY_MINUTE', c3),c2;
         max         | mysql_extract | mysql_extract | mysql_extract 
---------------------+---------------+---------------+---------------
 2021-01-03 12:10:30 |          2021 |        123456 |         31210
 2021-01-04 23:12:13 |          2021 |        123456 |         42312
 2021-01-05 11:12:12 |          2021 |        123456 |         51112
 2021-01-06 16:00:00 |          2021 |        123456 |         61600
 2021-01-07 00:59:59 |          2021 |        123456 |         70059
(5 rows)

-- select mysql_extract with group by index (result)
--Testcase 3416:
SELECT id, mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl group by 4,3,2,1;
 id | mysql_extract | mysql_extract | mysql_extract 
----+---------------+---------------+---------------
  0 |          2021 |        123456 |         31210
  1 |          2021 |        123456 |         42312
  2 |          2021 |        123456 |         51112
  3 |          2021 |        123456 |         61600
  4 |          2021 |        123456 |         70059
(5 rows)

-- select mysql_extract with group by index (result)
--Testcase 3417:
SELECT id, mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3) FROM time_tbl group by 1,2,3,4;
 id | mysql_extract | mysql_extract | mysql_extract 
----+---------------+---------------+---------------
  0 |          2021 |        123456 |         31210
  1 |          2021 |        123456 |         42312
  2 |          2021 |        123456 |         51112
  3 |          2021 |        123456 |         61600
  4 |          2021 |        123456 |         70059
(5 rows)

-- select mysql_extract with group by index having (result)
--Testcase 3418:
SELECT id, mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3), c2 FROM time_tbl group by 5, 4, 3, 2, 1 HAVING mysql_extract('YEAR', c2) > 2000;
 id | mysql_extract | mysql_extract | mysql_extract |     c2     
----+---------------+---------------+---------------+------------
  0 |          2021 |        123456 |         31210 | 2021-01-02
  1 |          2021 |        123456 |         42312 | 2021-01-01
  2 |          2021 |        123456 |         51112 | 2021-01-10
  3 |          2021 |        123456 |         61600 | 2021-01-15
  4 |          2021 |        123456 |         70059 | 2021-01-29
(5 rows)

-- select mysql_extract with group by index having (result)
--Testcase 3419:
SELECT id, mysql_extract('YEAR', c2), mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp), mysql_extract('DAY_MINUTE', c3), c2 FROM time_tbl group by 1, 2, 3, 4, 5 HAVING mysql_extract('YEAR', c2) > 2000;
 id | mysql_extract | mysql_extract | mysql_extract |     c2     
----+---------------+---------------+---------------+------------
  0 |          2021 |        123456 |         31210 | 2021-01-02
  1 |          2021 |        123456 |         42312 | 2021-01-01
  2 |          2021 |        123456 |         51112 | 2021-01-10
  3 |          2021 |        123456 |         61600 | 2021-01-15
  4 |          2021 |        123456 |         70059 | 2021-01-29
(5 rows)

-- select mysql_extract and as
--Testcase 3420:
SELECT mysql_extract('YEAR', c2) as mysql_extract1, mysql_extract('MICROSECOND', '2021-01-03 12:10:30.123456'::timestamp) as mysql_extract2, mysql_extract('DAY_MINUTE', c3) as mysql_extract3 FROM time_tbl;
ERROR:  stub mysql_extract(text, timestamp) is called
CONTEXT:  PL/pgSQL function mysql_extract(text,timestamp without time zone) line 3 at RAISE
-- DAYOFYEAR()
-- select dayofyear (stub function, explain)
--Testcase 3421:
EXPLAIN VERBOSE
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=8)
   Output: dayofyear(c2), dayofyear('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select dayofyear (stub function, result)
--Testcase 3422:
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl;
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear (stub function, not pushdown constraints, explain)
--Testcase 3423:
EXPLAIN VERBOSE
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl WHERE to_hex(id) = '1';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..154.25 rows=15 width=8)
   Output: dayofyear(c2), dayofyear('2021-01-01'::date)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select dayofyear (stub function, not pushdown constraints, result)
--Testcase 3424:
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear (stub function, pushdown constraints, explain)
--Testcase 3425:
EXPLAIN VERBOSE
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl WHERE id != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.31 rows=2910 width=8)
   Output: dayofyear(c2), dayofyear('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select dayofyear (stub function, pushdown constraints, result)
--Testcase 3426:
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl WHERE id != 200;
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear (stub function, dayofyear in constraints, explain)
--Testcase 3427:
EXPLAIN VERBOSE
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl WHERE dayofyear(c2) != dayofyear('2000-01-01'::date);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..233.94 rows=2910 width=8)
   Output: dayofyear(c2), dayofyear('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((dayofyear(`c2`) <> dayofyear('2000-01-01')))
(4 rows)

-- select dayofyear (stub function, dayofyear in constraints, result)
--Testcase 3428:
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl WHERE dayofyear(c2) != dayofyear('2000-01-01'::date);
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear (stub function, dayofyear in constraints, explain)
--Testcase 3429:
EXPLAIN VERBOSE
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl WHERE dayofyear('2021-01-01 12:00:00'::date) > 0;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.25 rows=975 width=8)
   Output: dayofyear(c2), dayofyear('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((dayofyear('2021-01-01') > 0))
(4 rows)

-- select dayofyear (stub function, dayofyear in constraints, result)
--Testcase 3430:
SELECT dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl WHERE dayofyear('2021-01-01 12:00:00'::date) > 0;
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear with agg (pushdown, explain)
--Testcase 3431:
EXPLAIN VERBOSE
SELECT max(c2), dayofyear(max(c2)) FROM time_tbl;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
   Output: (max(c2)), (dayofyear(max(c2)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c2`), dayofyear(max(`c2`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select dayofyear as nest function with agg (pushdown, result)
--Testcase 3432:
SELECT max(c2), dayofyear(max(c2)) FROM time_tbl;
    max     | dayofyear 
------------+-----------
 2021-01-29 |        29
(1 row)

-- select dayofyear with non pushdown func and explicit constant (explain)
--Testcase 3433:
EXPLAIN VERBOSE
SELECT dayofyear(c2), dayofyear('2021-01-01'::date), pi(), 4.1 FROM time_tbl;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=48)
   Output: dayofyear(c2), dayofyear('2021-01-01'::date), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select dayofyear with non pushdown func and explicit constant (result)
--Testcase 3434:
SELECT dayofyear(c2), dayofyear('2021-01-01'::date), pi(), 4.1 FROM time_tbl;
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear with order by (explain)
--Testcase 3435:
EXPLAIN VERBOSE
SELECT id, dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl order by dayofyear(c2), dayofyear('2021-01-01'::date);
                                                                                            QUERY PLAN                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: id, dayofyear(c2), dayofyear('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY dayofyear(`c2`) IS NULL ASC, dayofyear(`c2`) ASC, dayofyear('2021-01-01') IS NULL ASC, dayofyear('2021-01-01') ASC
(4 rows)

-- select dayofyear with order by (result)
--Testcase 3436:
SELECT id, dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl order by dayofyear(c2), dayofyear('2021-01-01'::date);
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear with order by index (result)
--Testcase 3437:
SELECT id, dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl order by 3,2,1;
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear with order by index (result)
--Testcase 3438:
SELECT id, dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl order by 1,2,3;
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- select dayofyear with group by (explain)
--Testcase 3439:
EXPLAIN VERBOSE
SELECT max(c3), dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl group by dayofyear(c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (max(c3)), (dayofyear(c2)), (dayofyear('2021-01-01'::date))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), dayofyear(`c2`), dayofyear('2021-01-01') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select dayofyear with group by (result)
--Testcase 3440:
SELECT max(c3), dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl group by dayofyear(c2);
         max         | dayofyear | dayofyear 
---------------------+-----------+-----------
 2021-01-03 12:10:30 |         2 |         1
 2021-01-04 23:12:13 |         1 |         1
 2021-01-05 11:12:12 |        10 |         1
 2021-01-06 16:00:00 |        15 |         1
 2021-01-07 00:59:59 |        29 |         1
(5 rows)

-- select dayofyear with group by index (result)
--Testcase 3441:
SELECT id, dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl group by 3,2,1;
 id | dayofyear | dayofyear 
----+-----------+-----------
  0 |         2 |         1
  1 |         1 |         1
  2 |        10 |         1
  3 |        15 |         1
  4 |        29 |         1
(5 rows)

-- select dayofyear with group by index (result)
--Testcase 3442:
SELECT id, dayofyear(c2), dayofyear('2021-01-01'::date) FROM time_tbl group by 1,2,3;
 id | dayofyear | dayofyear 
----+-----------+-----------
  0 |         2 |         1
  1 |         1 |         1
  2 |        10 |         1
  3 |        15 |         1
  4 |        29 |         1
(5 rows)

-- select dayofyear with group by index having (result)
--Testcase 3443:
SELECT id, dayofyear(c2), dayofyear('2021-01-01'::date), c2 FROM time_tbl group by 4, 3, 2, 1 HAVING dayofyear(c2) > 0;
 id | dayofyear | dayofyear |     c2     
----+-----------+-----------+------------
  0 |         2 |         1 | 2021-01-02
  1 |         1 |         1 | 2021-01-01
  2 |        10 |         1 | 2021-01-10
  3 |        15 |         1 | 2021-01-15
  4 |        29 |         1 | 2021-01-29
(5 rows)

-- select dayofyear with group by index having (result)
--Testcase 3444:
SELECT id, dayofyear(c2), dayofyear('2021-01-01'::date), c2 FROM time_tbl group by 1, 2, 3, 4 HAVING dayofyear(c2) > 0;
 id | dayofyear | dayofyear |     c2     
----+-----------+-----------+------------
  0 |         2 |         1 | 2021-01-02
  1 |         1 |         1 | 2021-01-01
  2 |        10 |         1 | 2021-01-10
  3 |        15 |         1 | 2021-01-15
  4 |        29 |         1 | 2021-01-29
(5 rows)

-- select dayofyear and as
--Testcase 3445:
SELECT dayofyear(c2) as dayofyear1, dayofyear('2021-01-01'::date) as dayofyear2 FROM time_tbl;
ERROR:  stub dayofyear(date) is called
CONTEXT:  PL/pgSQL function dayofyear(date) line 3 at RAISE
-- DAYOFWEEK()
-- select dayofweek (stub function, explain)
--Testcase 3446:
EXPLAIN VERBOSE
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=8)
   Output: dayofweek(c2), dayofweek('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select dayofweek (stub function, result)
--Testcase 3447:
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl;
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek (stub function, not pushdown constraints, explain)
--Testcase 3448:
EXPLAIN VERBOSE
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl WHERE to_hex(id) = '1';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..154.25 rows=15 width=8)
   Output: dayofweek(c2), dayofweek('2021-01-01'::date)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select dayofweek (stub function, not pushdown constraints, result)
--Testcase 3449:
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek (stub function, pushdown constraints, explain)
--Testcase 3450:
EXPLAIN VERBOSE
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl WHERE id != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.31 rows=2910 width=8)
   Output: dayofweek(c2), dayofweek('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select dayofweek (stub function, pushdown constraints, result)
--Testcase 3451:
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl WHERE id != 200;
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek (stub function, dayofweek in constraints, explain)
--Testcase 3452:
EXPLAIN VERBOSE
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl WHERE dayofweek(c2) != dayofweek('2000-01-01'::date);
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..233.94 rows=2910 width=8)
   Output: dayofweek(c2), dayofweek('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((dayofweek(`c2`) <> dayofweek('2000-01-01')))
(4 rows)

-- select dayofweek (stub function, dayofweek in constraints, result)
--Testcase 3453:
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl WHERE dayofweek(c2) != dayofweek('2000-01-01'::date);
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek (stub function, dayofweek in constraints, explain)
--Testcase 3454:
EXPLAIN VERBOSE
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl WHERE dayofweek('2021-01-01 12:00:00'::date) > 0;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.25 rows=975 width=8)
   Output: dayofweek(c2), dayofweek('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((dayofweek('2021-01-01') > 0))
(4 rows)

-- select dayofweek (stub function, dayofweek in constraints, result)
--Testcase 3455:
SELECT dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl WHERE dayofweek('2021-01-01 12:00:00'::date) > 0;
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek with agg (pushdown, explain)
--Testcase 3456:
EXPLAIN VERBOSE
SELECT max(c2), dayofweek(max(c2)) FROM time_tbl;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
   Output: (max(c2)), (dayofweek(max(c2)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c2`), dayofweek(max(`c2`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select dayofweek as nest function with agg (pushdown, result)
--Testcase 3457:
SELECT max(c2), dayofweek(max(c2)) FROM time_tbl;
    max     | dayofweek 
------------+-----------
 2021-01-29 |         6
(1 row)

-- select dayofweek with non pushdown func and explicit constant (explain)
--Testcase 3458:
EXPLAIN VERBOSE
SELECT dayofweek(c2), dayofweek('2021-01-01'::date), pi(), 4.1 FROM time_tbl;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=48)
   Output: dayofweek(c2), dayofweek('2021-01-01'::date), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select dayofweek with non pushdown func and explicit constant (result)
--Testcase 3459:
SELECT dayofweek(c2), dayofweek('2021-01-01'::date), pi(), 4.1 FROM time_tbl;
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek with order by (explain)
--Testcase 3460:
EXPLAIN VERBOSE
SELECT id, dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl order by dayofweek(c2), dayofweek('2021-01-01'::date);
                                                                                            QUERY PLAN                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: id, dayofweek(c2), dayofweek('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY dayofweek(`c2`) IS NULL ASC, dayofweek(`c2`) ASC, dayofweek('2021-01-01') IS NULL ASC, dayofweek('2021-01-01') ASC
(4 rows)

-- select dayofweek with order by (result)
--Testcase 3461:
SELECT id, dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl order by dayofweek(c2), dayofweek('2021-01-01'::date);
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek with order by index (result)
--Testcase 3462:
SELECT id, dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl order by 3,2,1;
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek with order by index (result)
--Testcase 3463:
SELECT id, dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl order by 1,2,3;
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- select dayofweek with group by (explain)
--Testcase 3464:
EXPLAIN VERBOSE
SELECT max(c3), dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl group by dayofweek(c2);
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (max(c3)), (dayofweek(c2)), (dayofweek('2021-01-01'::date))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), dayofweek(`c2`), dayofweek('2021-01-01') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select dayofweek with group by (result)
--Testcase 3465:
SELECT max(c3), dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl group by dayofweek(c2);
         max         | dayofweek | dayofweek 
---------------------+-----------+-----------
 2021-01-03 12:10:30 |         7 |         6
 2021-01-07 00:59:59 |         6 |         6
 2021-01-05 11:12:12 |         1 |         6
(3 rows)

-- select dayofweek with group by index (result)
--Testcase 3466:
SELECT id, dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl group by 3,2,1;
 id | dayofweek | dayofweek 
----+-----------+-----------
  0 |         7 |         6
  1 |         6 |         6
  2 |         1 |         6
  3 |         6 |         6
  4 |         6 |         6
(5 rows)

-- select dayofweek with group by index (result)
--Testcase 3467:
SELECT id, dayofweek(c2), dayofweek('2021-01-01'::date) FROM time_tbl group by 1,2,3;
 id | dayofweek | dayofweek 
----+-----------+-----------
  0 |         7 |         6
  1 |         6 |         6
  2 |         1 |         6
  3 |         6 |         6
  4 |         6 |         6
(5 rows)

-- select dayofweek with group by index having (result)
--Testcase 3468:
SELECT id, dayofweek(c2), dayofweek('2021-01-01'::date), c2 FROM time_tbl group by 4, 3, 2, 1 HAVING dayofweek(c2) > 0;
 id | dayofweek | dayofweek |     c2     
----+-----------+-----------+------------
  0 |         7 |         6 | 2021-01-02
  1 |         6 |         6 | 2021-01-01
  2 |         1 |         6 | 2021-01-10
  3 |         6 |         6 | 2021-01-15
  4 |         6 |         6 | 2021-01-29
(5 rows)

-- select dayofweek with group by index having (result)
--Testcase 3469:
SELECT id, dayofweek(c2), dayofweek('2021-01-01'::date), c2 FROM time_tbl group by 1, 2, 3, 4 HAVING dayofweek(c2) > 0;
 id | dayofweek | dayofweek |     c2     
----+-----------+-----------+------------
  0 |         7 |         6 | 2021-01-02
  1 |         6 |         6 | 2021-01-01
  2 |         1 |         6 | 2021-01-10
  3 |         6 |         6 | 2021-01-15
  4 |         6 |         6 | 2021-01-29
(5 rows)

-- select dayofweek and as
--Testcase 3470:
SELECT dayofweek(c2) as dayofweek1, dayofweek('2021-01-01'::date) as dayofweek2 FROM time_tbl;
ERROR:  stub dayofweek(date) is called
CONTEXT:  PL/pgSQL function dayofweek(date) line 3 at RAISE
-- DAYOFMONTH()
-- select dayofmonth (stub function, explain)
--Testcase 3471:
EXPLAIN VERBOSE
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=8)
   Output: dayofmonth(c2), dayofmonth('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select dayofmonth (stub function, result)
--Testcase 3472:
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl;
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth (stub function, not pushdown constraints, explain)
--Testcase 3473:
EXPLAIN VERBOSE
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl WHERE to_hex(id) = '1';
                               QUERY PLAN                               
------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..154.25 rows=15 width=8)
   Output: dayofmonth(c2), dayofmonth('2021-01-01'::date)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select dayofmonth (stub function, not pushdown constraints, result)
--Testcase 3474:
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth (stub function, pushdown constraints, explain)
--Testcase 3475:
EXPLAIN VERBOSE
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl WHERE id != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.31 rows=2910 width=8)
   Output: dayofmonth(c2), dayofmonth('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select dayofmonth (stub function, pushdown constraints, result)
--Testcase 3476:
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl WHERE id != 200;
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth (stub function, dayofmonth in constraints, explain)
--Testcase 3477:
EXPLAIN VERBOSE
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl WHERE dayofmonth(c2) != dayofmonth('2000-01-01'::date);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..233.94 rows=2910 width=8)
   Output: dayofmonth(c2), dayofmonth('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((dayofmonth(`c2`) <> dayofmonth('2000-01-01')))
(4 rows)

-- select dayofmonth (stub function, dayofmonth in constraints, result)
--Testcase 3478:
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl WHERE dayofmonth(c2) != dayofmonth('2000-01-01'::date);
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth (stub function, dayofmonth in constraints, explain)
--Testcase 3479:
EXPLAIN VERBOSE
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl WHERE dayofmonth('2021-01-01 12:00:00'::date) > 0;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..178.25 rows=975 width=8)
   Output: dayofmonth(c2), dayofmonth('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((dayofmonth('2021-01-01') > 0))
(4 rows)

-- select dayofmonth (stub function, dayofmonth in constraints, result)
--Testcase 3480:
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl WHERE dayofmonth('2021-01-01 12:00:00'::date) > 0;
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth with agg (pushdown, explain)
--Testcase 3481:
EXPLAIN VERBOSE
SELECT max(c2), dayofmonth(max(c2)) FROM time_tbl;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
   Output: (max(c2)), (dayofmonth(max(c2)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c2`), dayofmonth(max(`c2`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select dayofmonth as nest function with agg (pushdown, result)
--Testcase 3482:
SELECT max(c2), dayofmonth(max(c2)) FROM time_tbl;
    max     | dayofmonth 
------------+------------
 2021-01-29 |         29
(1 row)

-- select dayofmonth with non pushdown func and explicit constant (explain)
--Testcase 3483:
EXPLAIN VERBOSE
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date), pi(), 4.1 FROM time_tbl;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=48)
   Output: dayofmonth(c2), dayofmonth('2021-01-01'::date), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select dayofmonth with non pushdown func and explicit constant (result)
--Testcase 3484:
SELECT dayofmonth(c2), dayofmonth('2021-01-01'::date), pi(), 4.1 FROM time_tbl;
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth with order by (explain)
--Testcase 3485:
EXPLAIN VERBOSE
SELECT id, dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl order by dayofmonth(c2), dayofmonth('2021-01-01'::date);
                                                                                              QUERY PLAN                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=12)
   Output: id, dayofmonth(c2), dayofmonth('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY dayofmonth(`c2`) IS NULL ASC, dayofmonth(`c2`) ASC, dayofmonth('2021-01-01') IS NULL ASC, dayofmonth('2021-01-01') ASC
(4 rows)

-- select dayofmonth with order by (result)
--Testcase 3486:
SELECT id, dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl order by dayofmonth(c2), dayofmonth('2021-01-01'::date);
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth with order by index (result)
--Testcase 3487:
SELECT id, dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl order by 3,2,1;
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth with order by index (result)
--Testcase 3488:
SELECT id, dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl order by 1,2,3;
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- select dayofmonth with group by (explain)
--Testcase 3489:
EXPLAIN VERBOSE
SELECT max(c3), dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl group by dayofmonth(c2);
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=16)
   Output: (max(c3)), (dayofmonth(c2)), (dayofmonth('2021-01-01'::date))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), dayofmonth(`c2`), dayofmonth('2021-01-01') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select dayofmonth with group by (result)
--Testcase 3490:
SELECT max(c3), dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl group by dayofmonth(c2);
         max         | dayofmonth | dayofmonth 
---------------------+------------+------------
 2021-01-03 12:10:30 |          2 |          1
 2021-01-04 23:12:13 |          1 |          1
 2021-01-05 11:12:12 |         10 |          1
 2021-01-06 16:00:00 |         15 |          1
 2021-01-07 00:59:59 |         29 |          1
(5 rows)

-- select dayofmonth with group by index (result)
--Testcase 3491:
SELECT id, dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl group by 3,2,1;
 id | dayofmonth | dayofmonth 
----+------------+------------
  0 |          2 |          1
  1 |          1 |          1
  2 |         10 |          1
  3 |         15 |          1
  4 |         29 |          1
(5 rows)

-- select dayofmonth with group by index (result)
--Testcase 3492:
SELECT id, dayofmonth(c2), dayofmonth('2021-01-01'::date) FROM time_tbl group by 1,2,3;
 id | dayofmonth | dayofmonth 
----+------------+------------
  0 |          2 |          1
  1 |          1 |          1
  2 |         10 |          1
  3 |         15 |          1
  4 |         29 |          1
(5 rows)

-- select dayofmonth with group by index having (result)
--Testcase 3493:
SELECT id, dayofmonth(c2), dayofmonth('2021-01-01'::date), c2 FROM time_tbl group by 4, 3, 2, 1 HAVING dayofmonth(c2) > 0;
 id | dayofmonth | dayofmonth |     c2     
----+------------+------------+------------
  0 |          2 |          1 | 2021-01-02
  1 |          1 |          1 | 2021-01-01
  2 |         10 |          1 | 2021-01-10
  3 |         15 |          1 | 2021-01-15
  4 |         29 |          1 | 2021-01-29
(5 rows)

-- select dayofmonth with group by index having (result)
--Testcase 3494:
SELECT id, dayofmonth(c2), dayofmonth('2021-01-01'::date), c2 FROM time_tbl group by 1, 2, 3, 4 HAVING dayofmonth(c2) > 0;
 id | dayofmonth | dayofmonth |     c2     
----+------------+------------+------------
  0 |          2 |          1 | 2021-01-02
  1 |          1 |          1 | 2021-01-01
  2 |         10 |          1 | 2021-01-10
  3 |         15 |          1 | 2021-01-15
  4 |         29 |          1 | 2021-01-29
(5 rows)

-- select dayofmonth and as
--Testcase 3495:
SELECT dayofmonth(c2) as dayofmonth1, dayofmonth('2021-01-01'::date) as dayofmonth2 FROM time_tbl;
ERROR:  stub dayofmonth(date) is called
CONTEXT:  PL/pgSQL function dayofmonth(date) line 3 at RAISE
-- DAYNAME()
-- select dayname (stub function, explain)
--Testcase 3496:
EXPLAIN VERBOSE
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=64)
   Output: dayname(c2), dayname('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select dayname (stub function, result)
--Testcase 3497:
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl;
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- select dayname (stub function, not pushdown constraints, explain)
--Testcase 3498:
EXPLAIN VERBOSE
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl WHERE to_hex(id) = '1';
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..154.25 rows=15 width=64)
   Output: dayname(c2), dayname('2021-01-01'::date)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select dayname (stub function, not pushdown constraints, result)
--Testcase 3499:
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- select dayname (stub function, pushdown constraints, explain)
--Testcase 3500:
EXPLAIN VERBOSE
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl WHERE id != 200;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..219.31 rows=2910 width=64)
   Output: dayname(c2), dayname('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select dayname (stub function, pushdown constraints, result)
--Testcase 3501:
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl WHERE id != 200;
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- select dayname (stub function, dayname in constraints, explain)
--Testcase 3502:
EXPLAIN VERBOSE
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl WHERE dayname(c2) != dayname('2000-01-01'::date);
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..233.94 rows=2910 width=64)
   Output: dayname(c2), dayname('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((dayname(`c2`) <> dayname('2000-01-01')))
(4 rows)

-- select dayname (stub function, dayname in constraints, result)
--Testcase 3503:
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl WHERE dayname(c2) != dayname('2000-01-01'::date);
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- select dayname (stub function, dayname in constraints, explain)
--Testcase 3504:
EXPLAIN VERBOSE
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl WHERE dayname('2021-01-01 12:00:00'::date) = 'Friday';
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..154.25 rows=15 width=64)
   Output: dayname(c2), dayname('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((dayname('2021-01-01') = 'Friday'))
(4 rows)

-- select dayname (stub function, dayname in constraints, result)
--Testcase 3505:
SELECT dayname(c2), dayname('2021-01-01'::date) FROM time_tbl WHERE dayname('2021-01-01 12:00:00'::date) > 'Friday';
 dayname | dayname 
---------+---------
(0 rows)

-- select dayname with agg (pushdown, explain)
--Testcase 3506:
EXPLAIN VERBOSE
SELECT max(c2), dayname(max(c2)) FROM time_tbl;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=36)
   Output: (max(c2)), (dayname(max(c2)))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c2`), dayname(max(`c2`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select dayname as nest function with agg (pushdown, result)
--Testcase 3507:
SELECT max(c2), dayname(max(c2)) FROM time_tbl;
    max     | dayname 
------------+---------
 2021-01-29 | Friday
(1 row)

-- select dayname with non pushdown func and explicit constant (explain)
--Testcase 3508:
EXPLAIN VERBOSE
SELECT dayname(c2), dayname('2021-01-01'::date), pi(), 4.1 FROM time_tbl;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.38 rows=2925 width=104)
   Output: dayname(c2), dayname('2021-01-01'::date), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select dayname with non pushdown func and explicit constant (result)
--Testcase 3509:
SELECT dayname(c2), dayname('2021-01-01'::date), pi(), 4.1 FROM time_tbl;
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- select dayname with order by (explain)
--Testcase 3510:
EXPLAIN VERBOSE
SELECT id, dayname(c2), dayname('2021-01-01'::date) FROM time_tbl order by dayname(c2), dayname('2021-01-01'::date);
                                                                                        QUERY PLAN                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.15 rows=30 width=68)
   Output: id, dayname(c2), dayname('2021-01-01'::date)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY dayname(`c2`) IS NULL ASC, dayname(`c2`) ASC, dayname('2021-01-01') IS NULL ASC, dayname('2021-01-01') ASC
(4 rows)

-- select dayname with order by (result)
--Testcase 3511:
SELECT id, dayname(c2), dayname('2021-01-01'::date) FROM time_tbl order by dayname(c2), dayname('2021-01-01'::date);
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- select dayname with order by index (result)
--Testcase 3512:
SELECT id, dayname(c2), dayname('2021-01-01'::date) FROM time_tbl order by 3,2,1;
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- select dayname with order by index (result)
--Testcase 3513:
SELECT id, dayname(c2), dayname('2021-01-01'::date) FROM time_tbl order by 1,2,3;
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- select dayname with group by (explain)
--Testcase 3514:
EXPLAIN VERBOSE
SELECT max(c3), dayname(c2), dayname('2021-01-01'::date) FROM time_tbl group by dayname(c2);
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=72)
   Output: (max(c3)), (dayname(c2)), (dayname('2021-01-01'::date))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), dayname(`c2`), dayname('2021-01-01') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2
(5 rows)

-- select dayname with group by (result)
--Testcase 3515:
SELECT max(c3), dayname(c2), dayname('2021-01-01'::date) FROM time_tbl group by dayname(c2);
         max         | dayname  | dayname 
---------------------+----------+---------
 2021-01-03 12:10:30 | Saturday | Friday
 2021-01-07 00:59:59 | Friday   | Friday
 2021-01-05 11:12:12 | Sunday   | Friday
(3 rows)

-- select dayname with group by index (result)
--Testcase 3516:
SELECT id, dayname(c2), dayname('2021-01-01'::date) FROM time_tbl group by 3,2,1;
 id | dayname  | dayname 
----+----------+---------
  0 | Saturday | Friday
  1 | Friday   | Friday
  2 | Sunday   | Friday
  3 | Friday   | Friday
  4 | Friday   | Friday
(5 rows)

-- select dayname with group by index (result)
--Testcase 3517:
SELECT id, dayname(c2), dayname('2021-01-01'::date) FROM time_tbl group by 1,2,3;
 id | dayname  | dayname 
----+----------+---------
  0 | Saturday | Friday
  1 | Friday   | Friday
  2 | Sunday   | Friday
  3 | Friday   | Friday
  4 | Friday   | Friday
(5 rows)

-- select dayname with group by index having (result)
--Testcase 3518:
SELECT id, dayname(c2), dayname('2021-01-01'::date), c2 FROM time_tbl group by 4, 3, 2, 1 HAVING dayname(c2) = 'Friday';
 id | dayname | dayname |     c2     
----+---------+---------+------------
  1 | Friday  | Friday  | 2021-01-01
  3 | Friday  | Friday  | 2021-01-15
  4 | Friday  | Friday  | 2021-01-29
(3 rows)

-- select dayname with group by index having (result)
--Testcase 3519:
SELECT id, dayname(c2), dayname('2021-01-01'::date), c2 FROM time_tbl group by 1, 2, 3, 4 HAVING dayname(c2) > 'Friday';
 id | dayname  | dayname |     c2     
----+----------+---------+------------
  0 | Saturday | Friday  | 2021-01-02
  2 | Sunday   | Friday  | 2021-01-10
(2 rows)

-- select dayname and as
--Testcase 3520:
SELECT dayname(c2) as dayname1, dayname('2021-01-01'::date) as dayname2 FROM time_tbl;
ERROR:  stub dayname(date) is called
CONTEXT:  PL/pgSQL function dayname(date) line 3 at RAISE
-- DAY()
-- select day (stub function, explain)
--Testcase 3521:
EXPLAIN VERBOSE
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.69 rows=2275 width=16)
   Output: day((c2)::timestamp without time zone), day(c3), day('2021-01-01 00:00:00'::timestamp without time zone), day('1997-01-31 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select day (stub function, result)
--Testcase 3522:
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl;
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day (stub function, not pushdown constraints, explain)
--Testcase 3523:
EXPLAIN VERBOSE
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..144.48 rows=11 width=16)
   Output: day((c2)::timestamp without time zone), day(c3), day('2021-01-01 00:00:00'::timestamp without time zone), day('1997-01-31 12:00:00'::timestamp without time zone)
   Filter: (to_hex(time_tbl.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select day (stub function, not pushdown constraints, result)
--Testcase 3524:
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl WHERE to_hex(id) = '1';
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day (stub function, pushdown constraints, explain)
--Testcase 3525:
EXPLAIN VERBOSE
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..212.02 rows=2264 width=16)
   Output: day((c2)::timestamp without time zone), day(c3), day('2021-01-01 00:00:00'::timestamp without time zone), day('1997-01-31 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((`id` <> 200))
(4 rows)

-- select day (stub function, pushdown constraints, result)
--Testcase 3526:
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl WHERE id != 200;
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day (stub function, day in constraints, explain)
--Testcase 3527:
EXPLAIN VERBOSE
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl WHERE day(c2) != day('2000-01-01'::date);
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..229.08 rows=2264 width=16)
   Output: day((c2)::timestamp without time zone), day(c3), day('2021-01-01 00:00:00'::timestamp without time zone), day('1997-01-31 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((day(`c2`) <> day('2000-01-01 00:00:00')))
(4 rows)

-- select day (stub function, day in constraints, result)
--Testcase 3528:
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl WHERE day(c2) != day('2000-01-01'::date);
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day (stub function, day in constraints, explain)
--Testcase 3529:
EXPLAIN VERBOSE
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl WHERE day('2021-01-01 12:00:00'::date) > 0;
                                                                                 QUERY PLAN                                                                                  
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..168.76 rows=758 width=16)
   Output: day((c2)::timestamp without time zone), day(c3), day('2021-01-01 00:00:00'::timestamp without time zone), day('1997-01-31 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` WHERE ((day('2021-01-01 00:00:00') > 0))
(4 rows)

-- select day (stub function, day in constraints, result)
--Testcase 3530:
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl WHERE day('2021-01-01 12:00:00'::date) > 0;
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day with agg (pushdown, explain)
--Testcase 3531:
EXPLAIN VERBOSE
SELECT max(c2), day(max(c2)) FROM time_tbl;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=8)
   Output: (max(c2)), (day((max(c2))::timestamp without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c2`), day(max(`c2`)) FROM `mysql_fdw_regress`.`time_tbl`
(5 rows)

-- select day as nest function with agg (pushdown, result)
--Testcase 3532:
SELECT max(c2), day(max(c2)) FROM time_tbl;
    max     | day 
------------+-----
 2021-01-29 |  29
(1 row)

-- select day with non pushdown func and explicit constant (explain)
--Testcase 3533:
EXPLAIN VERBOSE
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp), pi(), 4.1 FROM time_tbl;
                                                                                                       QUERY PLAN                                                                                                        
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=100.00..206.69 rows=2275 width=56)
   Output: day((c2)::timestamp without time zone), day(c3), day('2021-01-01 00:00:00'::timestamp without time zone), day('1997-01-31 12:00:00'::timestamp without time zone), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl`
(4 rows)

-- select day with non pushdown func and explicit constant (result)
--Testcase 3534:
SELECT day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp), pi(), 4.1 FROM time_tbl;
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day with order by (explain)
--Testcase 3535:
EXPLAIN VERBOSE
SELECT id, day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl order by day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp);
                                                                                                                                                   QUERY PLAN                                                                                                                                                    
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.time_tbl  (cost=30.00..30.38 rows=30 width=20)
   Output: id, day((c2)::timestamp without time zone), day(c3), day('2021-01-01 00:00:00'::timestamp without time zone), day('1997-01-31 12:00:00'::timestamp without time zone)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c2`, `c3` FROM `mysql_fdw_regress`.`time_tbl` ORDER BY day(`c2`) IS NULL ASC, day(`c2`) ASC, day(`c3`) IS NULL ASC, day(`c3`) ASC, day('2021-01-01 00:00:00') IS NULL ASC, day('2021-01-01 00:00:00') ASC, day('1997-01-31 12:00:00') IS NULL ASC, day('1997-01-31 12:00:00') ASC
(4 rows)

-- select day with order by (result)
--Testcase 3536:
SELECT id, day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl order by day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp);
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day with order by index (result)
--Testcase 3537:
SELECT id, day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl order by 5,4,3,2,1;
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day with order by index (result)
--Testcase 3538:
SELECT id, day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl order by 1,2,3,4,5;
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
-- select day with group by (explain)
--Testcase 3539:
EXPLAIN VERBOSE
SELECT max(c3), day(c2), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl group by day(c2), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp);
                                                                                     QUERY PLAN                                                                                      
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2275 width=20)
   Output: (max(c3)), (day((c2)::timestamp without time zone)), (day('2021-01-01 00:00:00'::timestamp without time zone)), (day('1997-01-31 12:00:00'::timestamp without time zone))
   Relations: Aggregate on (mysql_fdw_regress.time_tbl)
   Local server startup cost: 10
   Remote query: SELECT max(`c3`), day(`c2`), day('2021-01-01 00:00:00'), day('1997-01-31 12:00:00') FROM `mysql_fdw_regress`.`time_tbl` GROUP BY 2, 3, 4
(5 rows)

-- select day with group by (result)
--Testcase 3540:
SELECT max(c3), day(c2), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl group by day(c2);
         max         | day | day | day 
---------------------+-----+-----+-----
 2021-01-03 12:10:30 |   2 |   1 |  31
 2021-01-04 23:12:13 |   1 |   1 |  31
 2021-01-05 11:12:12 |  10 |   1 |  31
 2021-01-06 16:00:00 |  15 |   1 |  31
 2021-01-07 00:59:59 |  29 |   1 |  31
(5 rows)

-- select day with group by index (result)
--Testcase 3541:
SELECT id, day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl group by 5,4,3,2,1;
 id | day | day | day | day 
----+-----+-----+-----+-----
  0 |   2 |   3 |   1 |  31
  1 |   1 |   4 |   1 |  31
  2 |  10 |   5 |   1 |  31
  3 |  15 |   6 |   1 |  31
  4 |  29 |   7 |   1 |  31
(5 rows)

-- select day with group by index (result)
--Testcase 3542:
SELECT id, day(c2), day(c3), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp) FROM time_tbl group by 1,2,3,4,5;
 id | day | day | day | day 
----+-----+-----+-----+-----
  0 |   2 |   3 |   1 |  31
  1 |   1 |   4 |   1 |  31
  2 |  10 |   5 |   1 |  31
  3 |  15 |   6 |   1 |  31
  4 |  29 |   7 |   1 |  31
(5 rows)

-- select day with group by index having (result)
--Testcase 3543:
SELECT id, day(c2), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp), c2 FROM time_tbl group by 5,4,3,2,1 HAVING day(c2) > 0;
 id | day | day | day |     c2     
----+-----+-----+-----+------------
  0 |   2 |   1 |  31 | 2021-01-02
  1 |   1 |   1 |  31 | 2021-01-01
  2 |  10 |   1 |  31 | 2021-01-10
  3 |  15 |   1 |  31 | 2021-01-15
  4 |  29 |   1 |  31 | 2021-01-29
(5 rows)

-- select day with group by index having (result)
--Testcase 3544:
SELECT id, day(c2), day('2021-01-01'::date), day('1997-01-31 12:00:00'::timestamp), c2 FROM time_tbl group by 1,2,3,4,5 HAVING day(c2) > 0;
 id | day | day | day |     c2     
----+-----+-----+-----+------------
  0 |   2 |   1 |  31 | 2021-01-02
  1 |   1 |   1 |  31 | 2021-01-01
  2 |  10 |   1 |  31 | 2021-01-10
  3 |  15 |   1 |  31 | 2021-01-15
  4 |  29 |   1 |  31 | 2021-01-29
(5 rows)

-- select day and as
--Testcase 3545:
SELECT day(c2) as day1, day(c3) as day2, day('2021-01-01'::date) as day3, day('1997-01-31 12:00:00'::timestamp) as day4 FROM time_tbl;
ERROR:  stub day(timestamp) is called
CONTEXT:  PL/pgSQL function day(timestamp without time zone) line 3 at RAISE
--Testcase 3546:
DROP FOREIGN TABLE time_tbl;
-- JSON functions
--Testcase 3547:
CREATE FOREIGN TABLE s8(id int, c1 json, c2 int, c3 text) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 's8');
--Testcase 3548:
CREATE FOREIGN TABLE s9(id int, c1 json) SERVER server1 OPTIONS(dbname 'mysql_fdw_regress', table_name 's9');
--Testcase 3549:
SELECT * FROM s8;
 id |                            c1                             | c2 |   c3   
----+-----------------------------------------------------------+----+--------
  0 | [[1, 2], [3, 4], 5]                                       |  1 | This
  1 | []                                                        |  2 | is
  2 | {}                                                        |  3 | text
  3 | {"a": "10", "b": "15", "x": 25}                           |  4 | scalar
  4 | {"a": 1, "b": 2, "c": {"d": 4}}                           |  5 | scalar
  5 | ["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}] |  5 | scalar
(6 rows)

--Testcase 3550:
SELECT * FROM s9;
 id |                                                                                                                                                                        c1                                                                                                                                                                        
----+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  0 | {"id": "http://json-schema.org/geo", "type": "object", "$schema": "http://json-schema.org/draft-04/schema#", "required": ["latitude", "longitude"], "properties": {"latitude": {"type": "number", "maximum": 90, "minimum": -90}, "longitude": {"type": "number", "maximum": 180, "minimum": -180}}, "description": "A geographical coordinate"}
  1 | {"id": "http://json-schema.org/geo", "type": "object", "$schema": "http://json-schema.org/draft-04/schema#", "properties": {"latitude": {"type": "number", "maximum": 9, "minimum": -9}, "longitude": {"type": "number", "maximum": 18, "minimum": -18}}, "description": "A geographical coordinate"}
(2 rows)

-- select json_build_array (builtin function, explain)
--Testcase 3551:
EXPLAIN VERBOSE
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, mysql_pi()) FROM s8;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..150.05 rows=890 width=160)
   Output: json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, mysql_pi())
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_build_array (builtin function, result)
--Testcase 3552:
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, mysql_pi()) FROM s8;
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select json_build_array (builtin function, not pushdown constraints, explain)
--Testcase 3553:
EXPLAIN VERBOSE
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, NULL), json_build_array(c1, TRUE), json_build_array(c1, mysql_pi()) FROM s8 WHERE to_hex(id) = '1';
                                                                           QUERY PLAN                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..123.49 rows=4 width=160)
   Output: json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, NULL::unknown), json_build_array(c1, true), json_build_array(c1, mysql_pi())
   Filter: (to_hex(s8.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_build_array (builtin function, not pushdown constraints, result)
--Testcase 3554:
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, NULL), json_build_array(c1, TRUE), json_build_array(c1, mysql_pi()) FROM s8 WHERE to_hex(id) = '1';
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select json_build_array (builtin function, pushdown constraints, explain)
--Testcase 3555:
EXPLAIN VERBOSE
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, '[true, false]'::json) FROM s8 WHERE id = 1;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..121.26 rows=4 width=160)
   Output: json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, '[true, false]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 1))
(4 rows)

-- select json_build_array (builtin function, pushdown constraints, result)
--Testcase 3556:
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, '[true, false]'::json) FROM s8 WHERE id = 1;
 json_build_array | json_build_array | json_build_array | json_build_array |  json_build_array   
------------------+------------------+------------------+------------------+---------------------
 [[], 2]          | [[], "is"]       | [[], 1]          | [[], "a"]        | [[], [true, false]]
(1 row)

-- select json_build_array (builtin function, builtin in constraints, explain)
--Testcase 3557:
EXPLAIN VERBOSE
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, NULL), json_build_array(c1, TRUE), json_build_array(c1, '[true, false]') FROM s8 WHERE json_length(json_build_array(c1, c2)) > 1;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.23 rows=297 width=160)
   Output: json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, NULL::unknown), json_build_array(c1, true), json_build_array(c1, '[true, false]')
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_array(`c1`, `c2`)) > 1))
(4 rows)

-- select json_build_array (builtin function, builtin in constraints, result)
--Testcase 3558:
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, NULL), json_build_array(c1, TRUE), json_build_array(c1, '[true, false]') FROM s8 WHERE json_length(json_build_array(c1, c2)) > 1;
                        json_build_array                        |                           json_build_array                            |                         json_build_array                          |                         json_build_array                          |                               json_build_array                               
----------------------------------------------------------------+-----------------------------------------------------------------------+-------------------------------------------------------------------+-------------------------------------------------------------------+------------------------------------------------------------------------------
 [[[1, 2], [3, 4], 5], 1]                                       | [[[1, 2], [3, 4], 5], "This"]                                         | [[[1, 2], [3, 4], 5], null]                                       | [[[1, 2], [3, 4], 5], true]                                       | [[[1, 2], [3, 4], 5], "[true, false]"]
 [[], 2]                                                        | [[], "is"]                                                            | [[], null]                                                        | [[], true]                                                        | [[], "[true, false]"]
 [{}, 3]                                                        | [{}, "text"]                                                          | [{}, null]                                                        | [{}, true]                                                        | [{}, "[true, false]"]
 [{"a": "10", "b": "15", "x": 25}, 4]                           | [{"a": "10", "b": "15", "x": 25}, "scalar"]                           | [{"a": "10", "b": "15", "x": 25}, null]                           | [{"a": "10", "b": "15", "x": 25}, true]                           | [{"a": "10", "b": "15", "x": 25}, "[true, false]"]
 [{"a": 1, "b": 2, "c": {"d": 4}}, 5]                           | [{"a": 1, "b": 2, "c": {"d": 4}}, "scalar"]                           | [{"a": 1, "b": 2, "c": {"d": 4}}, null]                           | [{"a": 1, "b": 2, "c": {"d": 4}}, true]                           | [{"a": 1, "b": 2, "c": {"d": 4}}, "[true, false]"]
 [["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}], 5] | [["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}], "scalar"] | [["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}], null] | [["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}], true] | [["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}], "[true, false]"]
(6 rows)

-- select json_build_array (builtin function, builtin in constraints, explain)
--Testcase 3559:
EXPLAIN VERBOSE
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, mysql_pi()) FROM s8 WHERE json_length(json_build_array(c1, c2)) > id;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.97 rows=297 width=160)
   Output: json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, mysql_pi())
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_array(`c1`, `c2`)) > `id`))
(4 rows)

-- select json_build_array (builtin function, builtin in constraints, result)
--Testcase 3560:
SELECT json_build_array(c1, c2), json_build_array(c1, c3), json_build_array(c1, 1), json_build_array(c1, 'a'), json_build_array(c1, mysql_pi()) FROM s8 WHERE json_length(json_build_array(c1, c2)) > id;
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select json_build_array as nest function with agg (pushdown, explain)
--Testcase 3561:
EXPLAIN VERBOSE
SELECT sum(id),json_build_array('["a", ["b", "c"], "d"]',  sum(id)) FROM s8;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_build_array('["a", ["b", "c"], "d"]', sum(id)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_array('["a", ["b", "c"], "d"]', sum(`id`)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_build_array as nest function with agg (pushdown, result)
--Testcase 3562:
SELECT sum(id),json_build_array('["a", ["b", "c"], "d"]',  sum(id)) FROM s8;
 sum |            json_build_array            
-----+----------------------------------------
  15 | ["[\"a\", [\"b\", \"c\"], \"d\"]", 15]
(1 row)

-- select json_build_array with non pushdown func and explicit constant (explain)
--Testcase 3563:
EXPLAIN VERBOSE
SELECT json_build_array(c1, c2), pi(), 4.1 FROM s8;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..154.36 rows=1365 width=72)
   Output: json_build_array(c1, c2), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_build_array with non pushdown func and explicit constant (result)
--Testcase 3564:
SELECT json_build_array(c1, c2), pi(), 4.1 FROM s8;
                        json_build_array                        |        pi         | ?column? 
----------------------------------------------------------------+-------------------+----------
 [[[1, 2], [3, 4], 5], 1]                                       | 3.141592653589793 |      4.1
 [[], 2]                                                        | 3.141592653589793 |      4.1
 [{}, 3]                                                        | 3.141592653589793 |      4.1
 [{"a": "10", "b": "15", "x": 25}, 4]                           | 3.141592653589793 |      4.1
 [{"a": 1, "b": 2, "c": {"d": 4}}, 5]                           | 3.141592653589793 |      4.1
 [["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}], 5] | 3.141592653589793 |      4.1
(6 rows)

-- select json_build_array with order by (explain)
--Testcase 3565:
EXPLAIN VERBOSE
SELECT json_length(json_build_array(c1, c2)) FROM s8 ORDER BY 1;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.15 rows=30 width=4)
   Output: json_length(json_build_array(c1, c2))
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` ORDER BY json_length(json_array(`c1`, `c2`)) IS NULL ASC, json_length(json_array(`c1`, `c2`)) ASC
(4 rows)

-- select json_build_array with order by (result)
--Testcase 3566:
SELECT json_length(json_build_array(c1, c2)) FROM s8 ORDER BY 1;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_build_array with group by (explain)
--Testcase 3567:
EXPLAIN VERBOSE
SELECT json_length(json_build_array('["a", ["b", "c"], "d"]',  id)) FROM s8 GROUP BY 1;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=4)
   Output: (json_length(json_build_array('["a", ["b", "c"], "d"]', id)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_length(json_array('["a", ["b", "c"], "d"]', `id`)) FROM `mysql_fdw_regress`.`s8` GROUP BY 1
(5 rows)

-- select json_build_array with group by (result)
--Testcase 3568:
SELECT json_length(json_build_array('["a", ["b", "c"], "d"]',  id)) FROM s8 GROUP BY 1;
 json_length 
-------------
           2
(1 row)

-- select json_build_array with group by having (explain)
--Testcase 3569:
EXPLAIN VERBOSE
SELECT json_length(json_build_array('["a", ["b", "c"], "d"]',  c2)), c2 FROM s8 GROUP BY 1, 2 HAVING count(c2) > 1;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=8)
   Output: (json_length(json_build_array('["a", ["b", "c"], "d"]', c2))), c2
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_length(json_array('["a", ["b", "c"], "d"]', `c2`)), `c2` FROM `mysql_fdw_regress`.`s8` GROUP BY 1, 2 HAVING ((count(`c2`) > 1))
(5 rows)

-- select json_build_array with group by having (result)
--Testcase 3570:
SELECT json_length(json_build_array('["a", ["b", "c"], "d"]',  c2)), c2 FROM s8 GROUP BY 1, 2 HAVING count(c2) > 1;
 json_length | c2 
-------------+----
           2 |  5
(1 row)

-- select json_build_array and as
--Testcase 3571:
SELECT json_build_array(c1, c2) AS json_build_array1 FROM s8;
                       json_build_array1                        
----------------------------------------------------------------
 [[[1, 2], [3, 4], 5], 1]
 [[], 2]
 [{}, 3]
 [{"a": "10", "b": "15", "x": 25}, 4]
 [{"a": 1, "b": 2, "c": {"d": 4}}, 5]
 [["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}], 5]
(6 rows)

-- json_array_append
-- select json_array_append (stub function, explain)
--Testcase 3572:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''","''$[1]'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_array_append (stub function, result)
--Testcase 3573:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- select json_array_append (stub function, not pushdown constraints, explain)
--Testcase 3574:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], NULL', '$[1], TRUE', '$[1], pi()') FROM s8 WHERE to_hex(id) = '1';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.09 rows=7 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', NULL","''$[1]'', TRUE","''$[1]'', pi()"}'::path_value[])
   Filter: (to_hex(s8.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_array_append (stub function, not pushdown constraints, result)
--Testcase 3575:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], NULL', '$[1], TRUE', '$[1], pi()') FROM s8 WHERE to_hex(id) = '1';
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- select json_array_append (stub function, pushdown constraints, explain)
--Testcase 3576:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.43 rows=7 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''","''$[1]'', CAST(\"[true, false]\" AS JSON)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 1))
(4 rows)

-- select json_array_append (stub function, pushdown constraints, result)
--Testcase 3577:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- select json_array_append (stub function, stub in constraints, explain)
--Testcase 3578:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], NULL', '$[1], TRUE', '$[1], "[true, false]"') FROM s8 WHERE log2(id) > 1;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', NULL","''$[1]'', TRUE","''$[1]'', ''[true, false]''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((log2(`id`) > 1))
(4 rows)

-- select json_array_append (stub function, stub in constraints, result)
--Testcase 3579:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], NULL', '$[1], TRUE', '$[1], "[true, false]"') FROM s8 WHERE log2(id) > 1;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- select json_array_append (stub function, stub in constraints, explain)
--Testcase 3580:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8 WHERE json_depth(json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()')) > 0;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''","''$[1]'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_depth(json_array_append(`c1`, '$[1]', c2, '$[1]', c3, '$[1]', 1, '$[1]', 'a', '$[1]', pi())) > 0))
(4 rows)

-- select json_array_append (stub function, stub in constraints, result)
--Testcase 3581:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8 WHERE json_depth(json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()')) > 0;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- json_array_append with 1 arg explain
--Testcase 3582:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2') FROM s8;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_append with 1 arg result
--Testcase 3583:
SELECT json_array_append(c1, '$[1], c2') FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- json_array_append with 2 args explain
--Testcase 3584:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3') FROM s8;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_append with 2 args result
--Testcase 3585:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3') FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- json_array_append with 3 args explain
--Testcase 3586:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1') FROM s8;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_append with 3 args result
--Testcase 3587:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1') FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- json_array_append with 4 args explain
--Testcase 3588:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"') FROM s8;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_append with 4 args result
--Testcase 3589:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"') FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- json_array_append with 5 args explain
--Testcase 3590:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''","''$[1]'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_append with 5 args result
--Testcase 3591:
SELECT json_array_append(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- select json_array_append as nest function with agg (pushdown, explain)
--Testcase 3592:
EXPLAIN VERBOSE
SELECT sum(id),json_array_append('["a", ["b", "c"], "d"]', '$[1], sum(id)') FROM s8;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_array_append('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$[1]'', sum(id)"}'::path_value[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_array_append(CAST('["a", ["b", "c"], "d"]' AS JSON), '$[1]', sum(id)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_array_append as nest function with agg (pushdown, result)
--Testcase 3593:
SELECT sum(id),json_array_append('["a", ["b", "c"], "d"]', '$[1], sum(id)') FROM s8;
 sum |     json_array_append      
-----+----------------------------
  15 | ["a", ["b", "c", 15], "d"]
(1 row)

-- select json_array_append as nest function with json_build_array (pushdown, explain)
--Testcase 3594:
EXPLAIN VERBOSE
SELECT json_array_append(json_build_array('["a", ["b", "c"], "d"]', c1), '$[1], log2(id)') FROM s8;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=32)
   Output: json_array_append(json_build_array('["a", ["b", "c"], "d"]', c1), VARIADIC '{"''$[1]'', log2(id)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_array_append as nest function with agg (pushdown, result)
--Testcase 3595:
SELECT json_array_append(json_build_array('["a", ["b", "c"], "d"]', c1), '$[1], log2(id)') FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- select json_array_append with non pushdown func and explicit constant (explain)
--Testcase 3596:
EXPLAIN VERBOSE
SELECT json_array_append(c1, '$[1], c2'), pi(), 4.1 FROM s8;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=72)
   Output: json_array_append(c1, VARIADIC '{"''$[1]'', c2"}'::path_value[]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_array_append with non pushdown func and explicit constant (result)
--Testcase 3597:
SELECT json_array_append(c1, '$[1], c2'), pi(), 4.1 FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- select json_array_append with order by (explain)
--Testcase 3598:
EXPLAIN VERBOSE
SELECT json_length(json_array_append(c1, '$[1], c2')) FROM s8 ORDER BY 1;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.15 rows=30 width=4)
   Output: json_length(json_array_append(c1, VARIADIC '{"''$[1]'', c2"}'::path_value[]))
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` ORDER BY json_length(json_array_append(`c1`, '$[1]', c2)) IS NULL ASC, json_length(json_array_append(`c1`, '$[1]', c2)) ASC
(4 rows)

-- select json_array_append with order by (result)
--Testcase 3599:
SELECT json_length(json_array_append(c1, '$[1], c2')) FROM s8 ORDER BY 1;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- select json_array_append with group by (explain)
--Testcase 3600:
EXPLAIN VERBOSE
SELECT json_length(json_array_append('["a", ["b", "c"], "d"]', '$[1], id')) FROM s8 GROUP BY 1;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=3413 width=4)
   Output: (json_length(json_array_append('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$[1]'', id"}'::path_value[])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_length(json_array_append(CAST('["a", ["b", "c"], "d"]' AS JSON), '$[1]', id)) FROM `mysql_fdw_regress`.`s8` GROUP BY 1
(5 rows)

-- select json_array_append with group by (result)
--Testcase 3601:
SELECT json_length(json_array_append('["a", ["b", "c"], "d"]', '$[1], id')) FROM s8 GROUP BY 1;
 json_length 
-------------
           3
(1 row)

-- select json_array_append with group by having (explain)
--Testcase 3602:
EXPLAIN VERBOSE
SELECT json_depth(json_array_append('["a", ["b", "c"], "d"]', '$[1], c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=975 width=8)
   Output: (json_depth(json_array_append('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$[1]'', c2"}'::path_value[]))), c2
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_depth(json_array_append(CAST('["a", ["b", "c"], "d"]' AS JSON), '$[1]', c2)), `c2` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1 HAVING ((count(`c2`) > 1))
(5 rows)

-- select json_array_append with group by having (result)
--Testcase 3603:
SELECT json_depth(json_array_append('["a", ["b", "c"], "d"]', '$[1], c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
 json_depth 
------------
          3
(1 row)

-- select json_array_append and as
--Testcase 3604:
SELECT json_array_append(c1, '$[1], c2') AS json_array_append1 FROM s8;
ERROR:  stub json_array_append(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_append(json,path_value[]) line 3 at RAISE
-- json_array_insert
-- select json_array_insert (stub function, explain)
--Testcase 3605:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''","''$[1]'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_array_insert (stub function, result)
--Testcase 3606:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select json_array_insert (stub function, not pushdown constraints, explain)
--Testcase 3607:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], NULL', '$[1], TRUE', '$[1], pi()') FROM s8 WHERE to_hex(id) = '1';
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.09 rows=7 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', NULL","''$[1]'', TRUE","''$[1]'', pi()"}'::path_value[])
   Filter: (to_hex(s8.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_array_insert (stub function, not pushdown constraints, result)
--Testcase 3608:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], NULL', '$[1], TRUE', '$[1], pi()') FROM s8 WHERE to_hex(id) = '1';
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select json_array_insert (stub function, pushdown constraints, explain)
--Testcase 3609:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.43 rows=7 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''","''$[1]'', CAST(\"[true, false]\" AS JSON)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 1))
(4 rows)

-- select json_array_insert (stub function, pushdown constraints, result)
--Testcase 3610:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select json_array_insert (stub function, stub in constraints, explain)
--Testcase 3611:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], NULL', '$[1], TRUE', '$[1], "[true, false]"') FROM s8 WHERE log2(id) > 1;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', NULL","''$[1]'', TRUE","''$[1]'', ''[true, false]''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((log2(`id`) > 1))
(4 rows)

-- select json_array_insert (stub function, stub in constraints, result)
--Testcase 3612:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], NULL', '$[1], TRUE', '$[1], "[true, false]"') FROM s8 WHERE log2(id) > 1;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select json_array_insert (stub function, stub in constraints, explain)
--Testcase 3613:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8 WHERE json_depth(json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()')) > 0;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''","''$[1]'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_depth(json_array_insert(`c1`, '$[1]', c2, '$[1]', c3, '$[1]', 1, '$[1]', 'a', '$[1]', pi())) > 0))
(4 rows)

-- select json_array_insert (stub function, stub in constraints, result)
--Testcase 3614:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8 WHERE json_depth(json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()')) > 0;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- json_array_insert with 1 arg explain
--Testcase 3615:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2') FROM s8;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_insert with 1 arg result
--Testcase 3616:
SELECT json_array_insert(c1, '$[1], c2') FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- json_array_insert with 2 args explain
--Testcase 3617:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3') FROM s8;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_insert with 2 args result
--Testcase 3618:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3') FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- json_array_insert with 3 args explain
--Testcase 3619:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1') FROM s8;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_insert with 3 args result
--Testcase 3620:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1') FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- json_array_insert with 4 args explain
--Testcase 3621:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"') FROM s8;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_insert with 4 args result
--Testcase 3622:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"') FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- json_array_insert with 5 args explain
--Testcase 3623:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2","''$[1]'', c3","''$[1]'', 1","''$[1]'', ''a''","''$[1]'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_array_insert with 5 args result
--Testcase 3624:
SELECT json_array_insert(c1, '$[1], c2', '$[1], c3', '$[1], 1', '$[1], "a"', '$[1], pi()') FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select json_array_insert as nest function with agg (pushdown, explain)
--Testcase 3625:
EXPLAIN VERBOSE
SELECT sum(id),json_array_insert('["a", ["b", "c"], "d"]', '$[1], sum(id)') FROM s8;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_array_insert('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$[1]'', sum(id)"}'::path_value[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_array_insert(CAST('["a", ["b", "c"], "d"]' AS JSON), '$[1]', sum(id)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_array_insert as nest function with agg (pushdown, result)
--Testcase 3626:
SELECT sum(id),json_array_insert('["a", ["b", "c"], "d"]', '$[1], sum(id)') FROM s8;
 sum |     json_array_insert      
-----+----------------------------
  15 | ["a", 15, ["b", "c"], "d"]
(1 row)

-- select json_array_insert as nest function with json_build_array (pushdown, explain)
--Testcase 3627:
EXPLAIN VERBOSE
SELECT json_array_insert(json_build_array('["a", ["b", "c"], "d"]', c1), '$[1], log2(id)') FROM s8;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=32)
   Output: json_array_insert(json_build_array('["a", ["b", "c"], "d"]', c1), VARIADIC '{"''$[1]'', log2(id)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_array_insert as nest function with agg (pushdown, result)
--Testcase 3628:
SELECT json_array_insert(json_build_array('["a", ["b", "c"], "d"]', c1), '$[1], log2(id)') FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select json_array_insert with non pushdown func and explicit constant (explain)
--Testcase 3629:
EXPLAIN VERBOSE
SELECT json_array_insert(c1, '$[1], c2'), pi(), 4.1 FROM s8;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=72)
   Output: json_array_insert(c1, VARIADIC '{"''$[1]'', c2"}'::path_value[]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_array_insert with non pushdown func and explicit constant (result)
--Testcase 3630:
SELECT json_array_insert(c1, '$[1], c2'), pi(), 4.1 FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select json_array_insert with order by (explain)
--Testcase 3631:
EXPLAIN VERBOSE
SELECT json_length(json_array_insert(c1, '$[1], c2')) FROM s8 ORDER BY 1;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.15 rows=30 width=4)
   Output: json_length(json_array_insert(c1, VARIADIC '{"''$[1]'', c2"}'::path_value[]))
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` ORDER BY json_length(json_array_insert(`c1`, '$[1]', c2)) IS NULL ASC, json_length(json_array_insert(`c1`, '$[1]', c2)) ASC
(4 rows)

-- select json_array_insert with order by (result)
--Testcase 3632:
SELECT json_length(json_array_insert(c1, '$[1], c2')) FROM s8 ORDER BY 1;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select json_array_insert with group by (explain)
--Testcase 3633:
EXPLAIN VERBOSE
SELECT json_length(json_array_insert('["a", ["b", "c"], "d"]', '$[1], id')) FROM s8 GROUP BY id, 1;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2925 width=8)
   Output: (json_length(json_array_insert('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$[1]'', id"}'::path_value[]))), id
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_length(json_array_insert(CAST('["a", ["b", "c"], "d"]' AS JSON), '$[1]', id)), `id` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1
(5 rows)

-- select json_array_insert with group by (result)
--Testcase 3634:
SELECT json_length(json_array_insert('["a", ["b", "c"], "d"]', '$[1], id')) FROM s8 GROUP BY id, 1;
 json_length 
-------------
           4
           4
           4
           4
           4
           4
(6 rows)

-- select json_array_insert with group by having (explain)
--Testcase 3635:
EXPLAIN VERBOSE
SELECT json_depth(json_array_insert('["a", ["b", "c"], "d"]', '$[1], c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
                                                                                      QUERY PLAN                                                                                       
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=975 width=8)
   Output: (json_depth(json_array_insert('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$[1]'', c2"}'::path_value[]))), c2
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_depth(json_array_insert(CAST('["a", ["b", "c"], "d"]' AS JSON), '$[1]', c2)), `c2` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1 HAVING ((count(`c2`) > 1))
(5 rows)

-- select json_array_insert with group by having (result)
--Testcase 3636:
SELECT json_depth(json_array_insert('["a", ["b", "c"], "d"]', '$[1], c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
 json_depth 
------------
          3
(1 row)

-- select json_array_insert and as
--Testcase 3637:
SELECT json_array_insert(c1, '$[1], c2') AS json_array_insert1 FROM s8;
ERROR:  stub json_array_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_array_insert(json,path_value[]) line 3 at RAISE
-- select  json_contains (stub function, explain)
--Testcase 3638:
EXPLAIN VERBOSE
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..172.14 rows=1462 width=20)
   Output: json_contains(c1, '1'::json, '$.a'::text), json_contains(c1, '{"a": 1}'::json, '$.a'::text), json_contains(c1, c1, '$.a'::text), json_contains(c1, '1'::text), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}'::json, '1'::json, '$.a'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select  json_contains (stub function, result)
--Testcase 3639:
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8;
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select  json_contains (stub function, not pushdown constraints, explain)
--Testcase 3640:
EXPLAIN VERBOSE
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.16 rows=7 width=20)
   Output: json_contains(c1, '1'::json, '$.a'::text), json_contains(c1, '{"a": 1}'::json, '$.a'::text), json_contains(c1, c1, '$.a'::text), json_contains(c1, '1'::text), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}'::json, '1'::json, '$.a'::text)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select  json_contains (stub function, not pushdown constraints, result)
--Testcase 3641:
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select  json_contains (stub function, pushdown constraints, explain)
--Testcase 3642:
EXPLAIN VERBOSE
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8 WHERE id != 0;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.56 rows=1455 width=20)
   Output: json_contains(c1, '1'::json, '$.a'::text), json_contains(c1, '{"a": 1}'::json, '$.a'::text), json_contains(c1, c1, '$.a'::text), json_contains(c1, '1'::text), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}'::json, '1'::json, '$.a'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select  json_contains (stub function, pushdown constraints, result)
--Testcase 3643:
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8 WHERE id != 0;
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select  json_contains (stub function, json_contains in constraints, explain)
--Testcase 3644:
EXPLAIN VERBOSE
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8 WHERE json_contains(c1, '1', '$.a') != 1;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..179.22 rows=1455 width=20)
   Output: json_contains(c1, '1'::json, '$.a'::text), json_contains(c1, '{"a": 1}'::json, '$.a'::text), json_contains(c1, c1, '$.a'::text), json_contains(c1, '1'::text), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}'::json, '1'::json, '$.a'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_contains(`c1`, CAST('1' AS JSON), '$.a') <> 1))
(4 rows)

-- select  json_contains (stub function, json_contains in constraints, result)
--Testcase 3645:
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8 WHERE json_contains(c1, '1', '$.a') != 1;
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select  json_contains (stub function, json_contains in constraints, explain)
--Testcase 3646:
EXPLAIN VERBOSE
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8 WHERE json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') = 1;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.16 rows=7 width=20)
   Output: json_contains(c1, '1'::json, '$.a'::text), json_contains(c1, '{"a": 1}'::json, '$.a'::text), json_contains(c1, c1, '$.a'::text), json_contains(c1, '1'::text), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}'::json, '1'::json, '$.a'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_contains(CAST('{"a": 1, "b": 2, "c": {"d": 4}}' AS JSON), CAST('1' AS JSON), '$.a') = 1))
(4 rows)

-- select  json_contains (stub function, json_contains in constraints, result)
--Testcase 3647:
SELECT json_contains(c1, '1', '$.a'), json_contains(c1, '{"a": 1}', '$.a'), json_contains(c1, c1, '$.a'), json_contains(c1,'1'), json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') FROM s8 WHERE json_contains('{"a": 1, "b": 2, "c": {"d": 4}}','1', '$.a') = 1;
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select json_contains as nest function with agg (pushdown, explain)
--Testcase 3648:
EXPLAIN VERBOSE
SELECT sum(id),json_contains('{"a": 1, "b": 2, "c": {"d": 4}}', '1') FROM s8;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (sum(id)), (json_contains('{"a": 1, "b": 2, "c": {"d": 4}}'::json, '1'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_contains(CAST('{"a": 1, "b": 2, "c": {"d": 4}}' AS JSON), '1') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_contains as nest function with agg (pushdown, result)
--Testcase 3649:
SELECT sum(id),json_contains('{"a": 1, "b": 2, "c": {"d": 4}}', '1') FROM s8;
 sum | json_contains 
-----+---------------
  15 |             0
(1 row)

-- select json_contains with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3650:
EXPLAIN VERBOSE
SELECT json_contains(c1, c1, '$.a'), pi(), 4.1 FROM s8;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=44)
   Output: json_contains(c1, c1, '$.a'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_contains with non pushdown func and explicit constant (result)
--Testcase 3651:
SELECT json_contains(c1, c1, '$.a'), pi(), 4.1 FROM s8;
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select json_contains with order by index (result)
--Testcase 3652:
SELECT id,  json_contains(c1, '1', '$.a') FROM s8 ORDER BY 2, 1;
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select json_contains with order by index (result)
--Testcase 3653:
SELECT id,  json_contains(c1, '1', '$.a') FROM s8 ORDER BY 1, 2;
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select json_contains with group by (EXPLAIN)
--Testcase 3654:
EXPLAIN VERBOSE
SELECT count(id), json_contains(c1, '1', '$.a') FROM s8 group by json_contains(c1, '1', '$.a');
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_contains(c1, '1'::json, '$.a'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_contains(`c1`, CAST('1' AS JSON), '$.a') FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_contains with group by (result)
--Testcase 3655:
SELECT count(id), json_contains(c1, '1', '$.a') FROM s8 group by json_contains(c1, '1', '$.a');
 count | json_contains 
-------+---------------
     4 |              
     1 |             0
     1 |             1
(3 rows)

-- select json_contains with group by index (result)
--Testcase 3656:
SELECT id,  json_contains(c1, '1', '$.a') FROM s8 group by 2, 1;
 id | json_contains 
----+---------------
  0 |              
  1 |              
  2 |              
  3 |             0
  4 |             1
  5 |              
(6 rows)

-- select json_contains with group by index (result)
--Testcase 3657:
SELECT id,  json_contains(c1, '1', '$.a') FROM s8 group by 1, 2;
 id | json_contains 
----+---------------
  0 |              
  1 |              
  2 |              
  3 |             0
  4 |             1
  5 |              
(6 rows)

-- select json_contains with group by having (EXPLAIN)
--Testcase 3658:
EXPLAIN VERBOSE
SELECT count(c2), json_contains(c1, '1', '$.a') FROM s8 group by json_contains(c1, '1', '$.a') HAVING count(c2) > 0;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_contains(c1, '1'::json, '$.a'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_contains(`c1`, CAST('1' AS JSON), '$.a') FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_contains with group by having (result)
--Testcase 3659:
SELECT count(c2), json_contains(c1, '1', '$.a') FROM s8 group by json_contains(c1, '1', '$.a') HAVING count(c2) > 0;
 count | json_contains 
-------+---------------
     4 |              
     1 |             0
     1 |             1
(3 rows)

-- select json_contains with group by index having (result)
--Testcase 3660:
SELECT c2,  json_contains(c1, '1', '$.a') FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_contains 
----+---------------
  1 |              
  2 |              
  3 |              
  4 |             0
  5 |             1
  5 |              
(6 rows)

-- select json_contains with group by index having (result)
--Testcase 3661:
SELECT c2,  json_contains(c1, '1', '$.a') FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_contains 
----+---------------
  1 |              
  2 |              
  3 |              
  4 |             0
  5 |             1
  5 |              
(6 rows)

-- select json_contains and as
--Testcase 3662:
SELECT json_contains(c1, c1, '$.a') as json_contains1 FROM s8;
ERROR:  stub json_contains(json, json, text) is called
CONTEXT:  PL/pgSQL function json_contains(json,json,text) line 3 at RAISE
-- select json_contains_path (builtin function, explain)
--Testcase 3663:
EXPLAIN VERBOSE
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8;
                                                                                                                                   QUERY PLAN                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..168.48 rows=1462 width=16)
   Output: json_contains_path(c1, VARIADIC '{one,$.a,$.e}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a,$.x}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a}'::text[]), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}'::json, VARIADIC '{one,$.c.d}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_contains_path (builtin function, result)
--Testcase 3664:
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8;
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_contains_path (builtin function, not pushdown constraints, explain)
--Testcase 3665:
EXPLAIN VERBOSE
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                                   QUERY PLAN                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.14 rows=7 width=16)
   Output: json_contains_path(c1, VARIADIC '{one,$.a,$.e}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a,$.x}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a}'::text[]), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}'::json, VARIADIC '{one,$.c.d}'::text[])
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_contains_path (builtin function, not pushdown constraints, result)
--Testcase 3666:
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_contains_path (builtin function, pushdown constraints, explain)
--Testcase 3667:
EXPLAIN VERBOSE
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8 WHERE id != 0;
                                                                                                                                   QUERY PLAN                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..171.93 rows=1455 width=16)
   Output: json_contains_path(c1, VARIADIC '{one,$.a,$.e}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a,$.x}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a}'::text[]), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}'::json, VARIADIC '{one,$.c.d}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_contains_path (builtin function, pushdown constraints, result)
--Testcase 3668:
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8 WHERE id != 0;
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_contains_path (builtin function, json_contains_path in constraints, explain)
--Testcase 3669:
EXPLAIN VERBOSE
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8 WHERE json_contains_path(c1, 'one', '$.a', '$.e') != 0;
                                                                                                                                   QUERY PLAN                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.58 rows=1455 width=16)
   Output: json_contains_path(c1, VARIADIC '{one,$.a,$.e}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a,$.x}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a}'::text[]), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}'::json, VARIADIC '{one,$.c.d}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_contains_path(`c1`, 'one', '$.a', '$.e') <> 0))
(4 rows)

-- select json_contains_path (builtin function, json_contains_path in constraints, result)
--Testcase 3670:
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8 WHERE json_contains_path(c1, 'one', '$.a', '$.e') != 0;
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_contains_path (builtin function, json_contains_path in constraints, explain)
--Testcase 3671:
EXPLAIN VERBOSE
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8 WHERE json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') = 1;
                                                                                                                                   QUERY PLAN                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.14 rows=7 width=16)
   Output: json_contains_path(c1, VARIADIC '{one,$.a,$.e}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a,$.x}'::text[]), json_contains_path(c1, VARIADIC '{all,$.a}'::text[]), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}'::json, VARIADIC '{one,$.c.d}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_contains_path(CAST('{"a": 1, "b": 2, "c": {"d": 4}}' AS JSON), 'one', '$.c.d') = 1))
(4 rows)

-- select json_contains_path (builtin function, json_contains_path in constraints, result)
--Testcase 3672:
SELECT json_contains_path(c1, 'one', '$.a', '$.e'), json_contains_path(c1, 'all', '$.a', '$.x'), json_contains_path(c1, 'all', '$.a'), json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8 WHERE json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') = 1;
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_contains_path as nest function with agg (pushdown, explain)
--Testcase 3673:
EXPLAIN VERBOSE
SELECT sum(id),json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (sum(id)), (json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}'::json, VARIADIC '{one,$.c.d}'::text[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_contains_path(CAST('{"a": 1, "b": 2, "c": {"d": 4}}' AS JSON), 'one', '$.c.d') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_contains_path as nest function with agg (pushdown, result)
--Testcase 3674:
SELECT sum(id),json_contains_path('{"a": 1, "b": 2, "c": {"d": 4}}', 'one', '$.c.d') FROM s8;
 sum | json_contains_path 
-----+--------------------
  15 |                  1
(1 row)

-- select json_contains_path with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3675:
EXPLAIN VERBOSE
SELECT json_contains_path(c1, 'all', '$.a'), pi(), 4.1 FROM s8;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=44)
   Output: json_contains_path(c1, VARIADIC '{all,$.a}'::text[]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_contains_path with non pushdown func and explicit constant (result)
--Testcase 3676:
SELECT json_contains_path(c1, 'all', '$.a'), pi(), 4.1 FROM s8;
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_contains_path with order by index (result)
--Testcase 3677:
SELECT id,  json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 ORDER BY 2, 1;
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_contains_path with order by index (result)
--Testcase 3678:
SELECT id,  json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 ORDER BY 1, 2;
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_contains_path with group by (EXPLAIN)
--Testcase 3679:
EXPLAIN VERBOSE
SELECT count(id), json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 group by json_contains_path(c1, 'one', '$.a', '$.e');
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_contains_path(c1, VARIADIC '{one,$.a,$.e}'::text[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_contains_path(`c1`, 'one', '$.a', '$.e') FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_contains_path with group by (result)
--Testcase 3680:
SELECT count(id), json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 group by json_contains_path(c1, 'one', '$.a', '$.e');
 count | json_contains_path 
-------+--------------------
     4 |                  0
     2 |                  1
(2 rows)

-- select json_contains_path with group by index (result)
--Testcase 3681:
SELECT id,  json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 group by 2, 1;
 id | json_contains_path 
----+--------------------
  0 |                  0
  1 |                  0
  2 |                  0
  3 |                  1
  4 |                  1
  5 |                  0
(6 rows)

-- select json_contains_path with group by index (result)
--Testcase 3682:
SELECT id,  json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 group by 1, 2;
 id | json_contains_path 
----+--------------------
  0 |                  0
  1 |                  0
  2 |                  0
  3 |                  1
  4 |                  1
  5 |                  0
(6 rows)

-- select json_contains_path with group by having (EXPLAIN)
--Testcase 3683:
EXPLAIN VERBOSE
SELECT count(c2), json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 group by json_contains_path(c1, 'one', '$.a', '$.e') HAVING count(c2) > 0;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_contains_path(c1, VARIADIC '{one,$.a,$.e}'::text[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_contains_path(`c1`, 'one', '$.a', '$.e') FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_contains_path with group by having (result)
--Testcase 3684:
SELECT count(c2), json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 group by json_contains_path(c1, 'one', '$.a', '$.e') HAVING count(c2) > 0;
 count | json_contains_path 
-------+--------------------
     4 |                  0
     2 |                  1
(2 rows)

-- select json_contains_path with group by index having (result)
--Testcase 3685:
SELECT c2,  json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_contains_path 
----+--------------------
  1 |                  0
  2 |                  0
  3 |                  0
  4 |                  1
  5 |                  1
  5 |                  0
(6 rows)

-- select json_contains_path with group by index having (result)
--Testcase 3686:
SELECT c2,  json_contains_path(c1, 'one', '$.a', '$.e') FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_contains_path 
----+--------------------
  1 |                  0
  2 |                  0
  3 |                  0
  4 |                  1
  5 |                  1
  5 |                  0
(6 rows)

-- select json_contains_path and as
--Testcase 3687:
SELECT json_contains_path(c1, 'all', '$.a') as json_contains_path1 FROM s8;
ERROR:  stub json_contains_path(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_contains_path(json,text[]) line 3 at RAISE
-- select json_depth (builtin function, explain)
--Testcase 3688:
EXPLAIN VERBOSE
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..171.43 rows=1365 width=20)
   Output: json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'::json), json_depth('1'::json), json_depth('true'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_depth (builtin function, result)
--Testcase 3689:
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8;
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_depth (builtin function, not pushdown constraints, explain)
--Testcase 3690:
EXPLAIN VERBOSE
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8 WHERE to_hex(id) = '2';
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.72 rows=7 width=20)
   Output: json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'::json), json_depth('1'::json), json_depth('true'::json)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_depth (builtin function, not pushdown constraints, result)
--Testcase 3691:
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_depth (builtin function, pushdown constraints, explain)
--Testcase 3692:
EXPLAIN VERBOSE
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8 WHERE id != 0;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..174.59 rows=1358 width=20)
   Output: json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'::json), json_depth('1'::json), json_depth('true'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_depth (builtin function, pushdown constraints, result)
--Testcase 3693:
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8 WHERE id != 0;
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_depth (builtin function, json_depth in constraints, explain)
--Testcase 3694:
EXPLAIN VERBOSE
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8 WHERE json_depth(c1) != 1;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..178.01 rows=1358 width=20)
   Output: json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'::json), json_depth('1'::json), json_depth('true'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_depth(`c1`) <> 1))
(4 rows)

-- select json_depth (builtin function, json_depth in constraints, result)
--Testcase 3695:
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8 WHERE json_depth(c1) != 1;
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_depth (builtin function, json_depth in constraints, explain)
--Testcase 3696:
EXPLAIN VERBOSE
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8 WHERE json_depth('true') = 1;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.72 rows=7 width=20)
   Output: json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'::json), json_depth('1'::json), json_depth('true'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_depth(CAST('true' AS JSON)) = 1))
(4 rows)

-- select json_depth (builtin function, json_depth in constraints, result)
--Testcase 3697:
SELECT json_depth(c1), json_depth(json_build_array(c1, c2)), json_depth('[10, {"a": 20}]'), json_depth('1'), json_depth('true') FROM s8 WHERE json_depth('true') = 1;
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_depth with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3698:
EXPLAIN VERBOSE
SELECT json_depth('[10, {"a": 20}]'), pi(), 4.1 FROM s8;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..220.92 rows=3413 width=44)
   Output: json_depth('[10, {"a": 20}]'::json), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_depth with non pushdown func and explicit constant (result)
--Testcase 3699:
SELECT json_depth('[10, {"a": 20}]'), pi(), 4.1 FROM s8;
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_depth with order by index (result)
--Testcase 3700:
SELECT id,  json_depth(c1) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_depth with order by index (result)
--Testcase 3701:
SELECT id,  json_depth(c1) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_depth with group by (EXPLAIN)
--Testcase 3702:
EXPLAIN VERBOSE
SELECT count(id), json_depth(c1) FROM s8 group by json_depth(c1);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_depth(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_depth(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_depth with group by (result)
--Testcase 3703:
SELECT count(id), json_depth(c1) FROM s8 group by json_depth(c1);
 count | json_depth 
-------+------------
     2 |          3
     2 |          1
     1 |          2
     1 |          4
(4 rows)

-- select json_depth with group by index (result)
--Testcase 3704:
SELECT id,  json_depth(c1) FROM s8 group by 2, 1;
 id | json_depth 
----+------------
  0 |          3
  1 |          1
  2 |          1
  3 |          2
  4 |          3
  5 |          4
(6 rows)

-- select json_depth with group by index (result)
--Testcase 3705:
SELECT id,  json_depth(c1) FROM s8 group by 1, 2;
 id | json_depth 
----+------------
  0 |          3
  1 |          1
  2 |          1
  3 |          2
  4 |          3
  5 |          4
(6 rows)

-- select json_depth with group by having (EXPLAIN)
--Testcase 3706:
EXPLAIN VERBOSE
SELECT count(c2), json_depth(c1) FROM s8 group by json_depth(c1) HAVING count(c2) > 0;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_depth(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_depth(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_depth with group by having (result)
--Testcase 3707:
SELECT count(c2), json_depth(c1) FROM s8 group by json_depth(c1) HAVING count(c2) > 0;
 count | json_depth 
-------+------------
     2 |          3
     2 |          1
     1 |          2
     1 |          4
(4 rows)

-- select json_depth with group by index having (result)
--Testcase 3708:
SELECT c2,  json_depth(c1) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_depth 
----+------------
  1 |          3
  2 |          1
  3 |          1
  4 |          2
  5 |          3
  5 |          4
(6 rows)

-- select json_depth with group by index having (result)
--Testcase 3709:
SELECT c2,  json_depth(c1) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_depth 
----+------------
  1 |          3
  2 |          1
  3 |          1
  4 |          2
  5 |          3
  5 |          4
(6 rows)

-- select json_depth and as
--Testcase 3710:
SELECT json_depth('[10, {"a": 20}]') as json_depth1 FROM s8;
ERROR:  stub json_depth(json) is called
CONTEXT:  PL/pgSQL function json_depth(json) line 3 at RAISE
-- select json_extract (builtin function, explain)
--Testcase 3711:
EXPLAIN VERBOSE
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8;
                                                                                                                                                                     QUERY PLAN                                                                                                                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..158.83 rows=930 width=160)
   Output: json_extract(c1, VARIADIC '{$[1]}'::text[]), json_extract((json_extract(c1, VARIADIC '{$[1],$[0]}'::text[]))::json, VARIADIC '{$[0]}'::text[]), json_extract(c1, VARIADIC '{$.a}'::text[]), json_extract(json_build_array(c1, c3), VARIADIC '{$[0]}'::text[]), json_extract('{"id": 1, "b": {"c": 30}}'::json, VARIADIC '{$.id}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_extract (builtin function, result)
--Testcase 3712:
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract (builtin function, not pushdown constraints, explain)
--Testcase 3713:
EXPLAIN VERBOSE
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                                                                     QUERY PLAN                                                                                                                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..124.16 rows=5 width=160)
   Output: json_extract(c1, VARIADIC '{$[1]}'::text[]), json_extract((json_extract(c1, VARIADIC '{$[1],$[0]}'::text[]))::json, VARIADIC '{$[0]}'::text[]), json_extract(c1, VARIADIC '{$.a}'::text[]), json_extract(json_build_array(c1, c3), VARIADIC '{$[0]}'::text[]), json_extract('{"id": 1, "b": {"c": 30}}'::json, VARIADIC '{$.id}'::text[])
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c3` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_extract (builtin function, not pushdown constraints, result)
--Testcase 3714:
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract (builtin function, pushdown constraints, explain)
--Testcase 3715:
EXPLAIN VERBOSE
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8 WHERE id != 0;
                                                                                                                                                                     QUERY PLAN                                                                                                                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..160.94 rows=925 width=160)
   Output: json_extract(c1, VARIADIC '{$[1]}'::text[]), json_extract((json_extract(c1, VARIADIC '{$[1],$[0]}'::text[]))::json, VARIADIC '{$[0]}'::text[]), json_extract(c1, VARIADIC '{$.a}'::text[]), json_extract(json_build_array(c1, c3), VARIADIC '{$[0]}'::text[]), json_extract('{"id": 1, "b": {"c": 30}}'::json, VARIADIC '{$.id}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_extract (builtin function, pushdown constraints, result)
--Testcase 3716:
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8 WHERE id != 0;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract (builtin function, json_extract in constraints, explain)
--Testcase 3717:
EXPLAIN VERBOSE
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8 WHERE json_extract(c1, '$[1]')::numeric != 1;
                                                                                                                                                                     QUERY PLAN                                                                                                                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..167.91 rows=925 width=160)
   Output: json_extract(c1, VARIADIC '{$[1]}'::text[]), json_extract((json_extract(c1, VARIADIC '{$[1],$[0]}'::text[]))::json, VARIADIC '{$[0]}'::text[]), json_extract(c1, VARIADIC '{$.a}'::text[]), json_extract(json_build_array(c1, c3), VARIADIC '{$[0]}'::text[]), json_extract('{"id": 1, "b": {"c": 30}}'::json, VARIADIC '{$.id}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_extract(`c1`, '$[1]') <> 1))
(4 rows)

-- select json_extract (builtin function, json_extract in constraints, result)
--Testcase 3718:
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8 WHERE json_extract(c1, '$[1]')::numeric != 1;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract (builtin function, json_extract in constraints, explain)
--Testcase 3719:
EXPLAIN VERBOSE
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8 WHERE json_extract('{"id": 1, "b": {"c": 30}}', '$.id')::numeric = 1;
                                                                                                                                                                     QUERY PLAN                                                                                                                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.81 rows=5 width=160)
   Output: json_extract(c1, VARIADIC '{$[1]}'::text[]), json_extract((json_extract(c1, VARIADIC '{$[1],$[0]}'::text[]))::json, VARIADIC '{$[0]}'::text[]), json_extract(c1, VARIADIC '{$.a}'::text[]), json_extract(json_build_array(c1, c3), VARIADIC '{$[0]}'::text[]), json_extract('{"id": 1, "b": {"c": 30}}'::json, VARIADIC '{$.id}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_extract(CAST('{"id": 1, "b": {"c": 30}}' AS JSON), '$.id') = 1))
(4 rows)

-- select json_extract (builtin function, json_extract in constraints, result)
--Testcase 3720:
SELECT json_extract(c1, '$[1]'), json_extract(json_extract(c1, '$[1]', '$[0]')::json, '$[0]'), json_extract(c1, '$.a'), json_extract(json_build_array(c1, c3), '$[0]'), json_extract('{"id": 1, "b": {"c": 30}}', '$.id') FROM s8 WHERE json_extract('{"id": 1, "b": {"c": 30}}', '$.id')::numeric = 1;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract as nest function with agg (pushdown, explain)
--Testcase 3721:
EXPLAIN VERBOSE
SELECT sum(id),json_extract(json_build_array('{"id": 1, "b": {"c": 30}}', sum(id)), '$.id') FROM s8;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_extract(json_build_array('{"id": 1, "b": {"c": 30}}', sum(id)), VARIADIC '{$.id}'::text[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_extract(json_array('{"id": 1, "b": {"c": 30}}', sum(`id`)), '$.id') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_extract as nest function with agg (pushdown, result)
--Testcase 3722:
SELECT sum(id),json_extract(json_build_array('{"id": 1, "b": {"c": 30}}', sum(id)), '$.id') FROM s8;
 sum | json_extract 
-----+--------------
  15 | 
(1 row)

-- select json_extract with abnormal cast
--Testcase 3723:
SELECT json_extract(c1, '$.a')::int FROM s8;  -- should fail
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract with normal cast
--Testcase 3724:
SELECT json_extract('{"a": "2000-01-01"}', '$.a')::timestamp, json_extract('{"a": "2000-01-01"}', '$.a')::date , json_extract('{"a": 1234}', '$.a')::bigint, json_extract('{"a": "b"}', '$.a')::text FROM s8;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract with normal cast
--Testcase 3725:
SELECT json_extract('{"a": "2000-01-01"}', '$.a')::timestamptz, json_extract('{"a": "12:10:20.123456"}', '$.a')::time , json_extract('{"a": "12:10:20.123456"}', '$.a')::timetz FROM s8;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract with type modifier (explain)
--Testcase 3726:
EXPLAIN VERBOSE
SELECT json_extract('{"a": "2000-01-01 12:02:01.123456"}', '$.a')::timestamp(3), json_extract('{"a": "2000-01-01 12:02:01.123456"}', '$.a')::timestamptz(3), json_extract('{"a": "12:10:20.123456"}', '$.a')::time(3), json_extract('{"a": "12:10:20.123456"}', '$.a')::timetz(3) FROM s8;
                                                                                                                                                                                                                           QUERY PLAN                                                                                                                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..348.91 rows=3413 width=36)
   Output: (json_extract('{"a": "2000-01-01 12:02:01.123456"}'::json, VARIADIC '{$.a}'::text[]))::timestamp(3) without time zone, (json_extract('{"a": "2000-01-01 12:02:01.123456"}'::json, VARIADIC '{$.a}'::text[]))::timestamp(3) with time zone, (json_extract('{"a": "12:10:20.123456"}'::json, VARIADIC '{$.a}'::text[]))::time(3) without time zone, (json_extract('{"a": "12:10:20.123456"}'::json, VARIADIC '{$.a}'::text[]))::time(3) with time zone
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_extract with type modifier (result)
--Testcase 3727:
SELECT json_extract('{"a": "2000-01-01 12:02:01.123456"}', '$.a')::timestamp(3), json_extract('{"a": "2000-01-01 12:02:01.123456"}', '$.a')::timestamptz(3), json_extract('{"a": "12:10:20.123456"}', '$.a')::time(3), json_extract('{"a": "12:10:20.123456"}', '$.a')::timetz(3) FROM s8;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract with type modifier (explain)
--Testcase 3728:
EXPLAIN VERBOSE
SELECT json_extract('{"a": 100}', '$.a')::numeric(10, 2), json_extract('{"a": 100}', '$.a')::decimal(10, 2), json_unquote(json_extract('{"a": "1.123456"}', '$.a'))::numeric(10, 3) FROM s8;
                                                                                                                              QUERY PLAN                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..323.31 rows=3413 width=48)
   Output: (json_extract('{"a": 100}'::json, VARIADIC '{$.a}'::text[]))::numeric(10,2), (json_extract('{"a": 100}'::json, VARIADIC '{$.a}'::text[]))::numeric(10,2), (json_unquote(json_extract('{"a": "1.123456"}'::json, VARIADIC '{$.a}'::text[])))::numeric(10,3)
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_extract with type modifier (result)
--Testcase 3729:
SELECT json_extract('{"a": 100}', '$.a')::numeric(10, 2), json_extract('{"a": 100}', '$.a')::decimal(10, 2), json_unquote(json_extract('{"a": "1.123456"}', '$.a'))::numeric(10, 3) FROM s8;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3730:
EXPLAIN VERBOSE
SELECT json_extract(c1, '$.a'), pi(), 4.1 FROM s8;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=72)
   Output: json_extract(c1, VARIADIC '{$.a}'::text[]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_extract with non pushdown func and explicit constant (result)
--Testcase 3731:
SELECT json_extract(c1, '$.a'), pi(), 4.1 FROM s8;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract with order by index (result)
--Testcase 3732:
SELECT id,  json_extract(c1, '$[1]') FROM s8 ORDER BY 2, 1;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract with order by index (result)
--Testcase 3733:
SELECT id,  json_extract(c1, '$[1]') FROM s8 ORDER BY 1, 2;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- select json_extract with group by (EXPLAIN)
--Testcase 3734:
EXPLAIN VERBOSE
SELECT count(id), json_extract(c1, '$[1]') FROM s8 group by json_extract(c1, '$[1]');
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(id)), (json_extract(c1, VARIADIC '{$[1]}'::text[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_extract(`c1`, '$[1]') FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_extract with group by (result)
--Testcase 3735:
SELECT count(id), json_extract(c1, '$[1]') FROM s8 group by json_extract(c1, '$[1]');
 count |     json_extract     
-------+----------------------
     1 | [3, 4]
     4 | 
     1 | [{"k": "10"}, "def"]
(3 rows)

-- select json_extract with group by index (result)
--Testcase 3736:
SELECT id,  json_extract(c1, '$[1]') FROM s8 group by 2, 1;
 id |     json_extract     
----+----------------------
  0 | [3, 4]
  1 | 
  2 | 
  3 | 
  4 | 
  5 | [{"k": "10"}, "def"]
(6 rows)

-- select json_extract with group by index (result)
--Testcase 3737:
SELECT id,  json_extract(c1, '$[1]') FROM s8 group by 1, 2;
 id |     json_extract     
----+----------------------
  0 | [3, 4]
  1 | 
  2 | 
  3 | 
  4 | 
  5 | [{"k": "10"}, "def"]
(6 rows)

-- select json_extract with group by having (EXPLAIN)
--Testcase 3738:
EXPLAIN VERBOSE
SELECT count(c2), json_extract(c1, '$[1]') FROM s8 group by json_extract(c1, '$[1]') HAVING count(c2) > 0;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=40)
   Output: (count(c2)), (json_extract(c1, VARIADIC '{$[1]}'::text[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_extract(`c1`, '$[1]') FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_extract with group by having (result)
--Testcase 3739:
SELECT count(c2), json_extract(c1, '$[1]') FROM s8 group by json_extract(c1, '$[1]') HAVING count(c2) > 0;
 count |     json_extract     
-------+----------------------
     1 | [3, 4]
     4 | 
     1 | [{"k": "10"}, "def"]
(3 rows)

-- select json_extract with group by index having (result)
--Testcase 3740:
SELECT c2,  json_extract(c1, '$[1]') FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 |     json_extract     
----+----------------------
  1 | [3, 4]
  2 | 
  3 | 
  4 | 
  5 | 
  5 | [{"k": "10"}, "def"]
(6 rows)

-- select json_extract with group by index having (result)
--Testcase 3741:
SELECT c2,  json_extract(c1, '$[1]') FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 |     json_extract     
----+----------------------
  1 | [3, 4]
  2 | 
  3 | 
  4 | 
  5 | 
  5 | [{"k": "10"}, "def"]
(6 rows)

-- select json_extract and as
--Testcase 3742:
SELECT json_extract(c1, '$.a') as json_extract1 FROM s8;
ERROR:  stub json_extract(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_extract(json,text[]) line 3 at RAISE
-- JSON_INSERT()
-- select json_insert (stub function, explain)
--Testcase 3743:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_insert (stub function, result)
--Testcase 3744:
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- select json_insert (stub function, not pushdown constraints, explain)
--Testcase 3745:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, pi()') FROM s8 WHERE to_hex(id) = '1';
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.09 rows=7 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', NULL","''$'', TRUE","''$'', pi()"}'::path_value[])
   Filter: (to_hex(s8.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_insert (stub function, not pushdown constraints, result)
--Testcase 3746:
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, pi()') FROM s8 WHERE to_hex(id) = '1';
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- select json_insert (stub function, pushdown constraints, explain)
--Testcase 3747:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.43 rows=7 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', CAST(\"[true, false]\" AS JSON)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 1))
(4 rows)

-- select json_insert (stub function, pushdown constraints, result)
--Testcase 3748:
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- select json_insert (stub function, stub in constraints, explain)
--Testcase 3749:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, "[true, false]"') FROM s8 WHERE log2(id) > 1;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', NULL","''$'', TRUE","''$'', ''[true, false]''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((log2(`id`) > 1))
(4 rows)

-- select json_insert (stub function, stub in constraints, result)
--Testcase 3750:
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, "[true, false]"') FROM s8 WHERE log2(id) > 1;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- select json_insert (stub function, stub in constraints, explain)
--Testcase 3751:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8 WHERE json_depth(json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()')) > 0;
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_depth(json_insert(`c1`, '$.a', c2, '$.b', c3, '$.c', 1, '$', 'a', '$', pi())) > 0))
(4 rows)

-- select json_insert (stub function, stub in constraints, result)
--Testcase 3752:
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8 WHERE json_depth(json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()')) > 0;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- json_insert with 1 arg explain
--Testcase 3753:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2') FROM s8;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_insert with 1 arg result
--Testcase 3754:
SELECT json_insert(c1, '$.a, c2') FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- json_insert with 2 args explain
--Testcase 3755:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3') FROM s8;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_insert with 2 args result
--Testcase 3756:
SELECT json_insert(c1, '$.a, c2', '$.b, c3') FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- json_insert with 3 args explain
--Testcase 3757:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1') FROM s8;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_insert with 3 args result
--Testcase 3758:
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1') FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- json_insert with 4 args explain
--Testcase 3759:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"') FROM s8;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_insert with 4 args result
--Testcase 3760:
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"') FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- json_insert with 5 args explain
--Testcase 3761:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_insert with 5 args result
--Testcase 3762:
SELECT json_insert(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- select json_insert as nest function with agg (pushdown, explain)
--Testcase 3763:
EXPLAIN VERBOSE
SELECT sum(id),json_insert('["a", ["b", "c"], "d"]', '$, sum(id)') FROM s8;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_insert('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', sum(id)"}'::path_value[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_insert(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', sum(id)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_insert as nest function with agg (pushdown, result)
--Testcase 3764:
SELECT sum(id),json_insert('["a", ["b", "c"], "d"]', '$, sum(id)') FROM s8;
 sum |      json_insert       
-----+------------------------
  15 | ["a", ["b", "c"], "d"]
(1 row)

-- select json_insert as nest function with json_build_array (pushdown, explain)
--Testcase 3765:
EXPLAIN VERBOSE
SELECT json_insert(json_build_array('["a", ["b", "c"], "d"]', c1), '$, log2(id)') FROM s8;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=32)
   Output: json_insert(json_build_array('["a", ["b", "c"], "d"]', c1), VARIADIC '{"''$'', log2(id)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_insert as nest function with agg (pushdown, result)
--Testcase 3766:
SELECT json_insert(json_build_array('["a", ["b", "c"], "d"]', c1), '$, log2(id)') FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- select json_insert with non pushdown func and explicit constant (explain)
--Testcase 3767:
EXPLAIN VERBOSE
SELECT json_insert(c1, '$.a, c2'), pi(), 4.1 FROM s8;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=72)
   Output: json_insert(c1, VARIADIC '{"''$.a'', c2"}'::path_value[]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_insert with non pushdown func and explicit constant (result)
--Testcase 3768:
SELECT json_insert(c1, '$.a, c2'), pi(), 4.1 FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- select json_insert with order by (explain)
--Testcase 3769:
EXPLAIN VERBOSE
SELECT json_length(json_insert(c1, '$.a, c2')) FROM s8 ORDER BY 1;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.15 rows=30 width=4)
   Output: json_length(json_insert(c1, VARIADIC '{"''$.a'', c2"}'::path_value[]))
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` ORDER BY json_length(json_insert(`c1`, '$.a', c2)) IS NULL ASC, json_length(json_insert(`c1`, '$.a', c2)) ASC
(4 rows)

-- select json_insert with order by (result)
--Testcase 3770:
SELECT json_length(json_insert(c1, '$.a, c2')) FROM s8 ORDER BY 1;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- select json_insert with group by (explain)
--Testcase 3771:
EXPLAIN VERBOSE
SELECT json_length(json_insert('["a", ["b", "c"], "d"]', '$, id')) FROM s8 GROUP BY id, 1;
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2925 width=8)
   Output: (json_length(json_insert('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', id"}'::path_value[]))), id
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_length(json_insert(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', id)), `id` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1
(5 rows)

-- select json_insert with group by (result)
--Testcase 3772:
SELECT json_length(json_insert('["a", ["b", "c"], "d"]', '$, id')) FROM s8 GROUP BY id, 1;
 json_length 
-------------
           3
           3
           3
           3
           3
           3
(6 rows)

-- select json_insert with group by having (explain)
--Testcase 3773:
EXPLAIN VERBOSE
SELECT json_depth(json_insert('["a", ["b", "c"], "d"]', '$, c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
                                                                                  QUERY PLAN                                                                                  
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=975 width=8)
   Output: (json_depth(json_insert('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', c2"}'::path_value[]))), c2
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_depth(json_insert(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', c2)), `c2` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1 HAVING ((count(`c2`) > 1))
(5 rows)

-- select json_insert with group by having (result)
--Testcase 3774:
SELECT json_depth(json_insert('["a", ["b", "c"], "d"]', '$, c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
 json_depth 
------------
          3
(1 row)

-- select json_insert and as
--Testcase 3775:
SELECT json_insert(c1, '$.a, c2') AS json_insert1 FROM s8;
ERROR:  stub json_insert(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_insert(json,path_value[]) line 3 at RAISE
-- JSON_KEYS()
-- select json_keys (builtin function, explain)
--Testcase 3776:
EXPLAIN VERBOSE
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.a') FROM s8;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..154.18 rows=930 width=160)
   Output: json_keys(c1), json_keys(c1, '$'::text), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'::text), json_keys('{"a": 1, "b": {"c": 30}}'::json, '$.a'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_keys (builtin function, result)
--Testcase 3777:
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.a') FROM s8;
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_keys (builtin function, not pushdown constraints, explain)
--Testcase 3778:
EXPLAIN VERBOSE
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.a') FROM s8 WHERE to_hex(id) = '2';
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..124.14 rows=5 width=160)
   Output: json_keys(c1), json_keys(c1, '$'::text), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'::text), json_keys('{"a": 1, "b": {"c": 30}}'::json, '$.a'::text)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c3` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_keys (builtin function, not pushdown constraints, result)
--Testcase 3779:
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.a') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_keys (builtin function, pushdown constraints, explain)
--Testcase 3780:
EXPLAIN VERBOSE
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.a') FROM s8 WHERE id != 0;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..156.31 rows=925 width=160)
   Output: json_keys(c1), json_keys(c1, '$'::text), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'::text), json_keys('{"a": 1, "b": {"c": 30}}'::json, '$.a'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_keys (builtin function, pushdown constraints, result)
--Testcase 3781:
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.a') FROM s8 WHERE id != 0;
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_keys (builtin function, json_keys in constraints, explain)
--Testcase 3782:
EXPLAIN VERBOSE
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.b') FROM s8 WHERE json_length(json_keys(c1)) != 1;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..160.96 rows=925 width=160)
   Output: json_keys(c1), json_keys(c1, '$'::text), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'::text), json_keys('{"a": 1, "b": {"c": 30}}'::json, '$.b'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_keys(`c1`)) <> 1))
(4 rows)

-- select json_keys (builtin function, json_keys in constraints, result)
--Testcase 3783:
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.b') FROM s8 WHERE json_length(json_keys(c1)) != 1;
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_keys (builtin function, json_keys in constraints, explain)
--Testcase 3784:
EXPLAIN VERBOSE
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.b') FROM s8 WHERE json_length(json_keys('{"a": 1, "b": {"c": 30}}', '$.b')) = 1;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..126.46 rows=5 width=160)
   Output: json_keys(c1), json_keys(c1, '$'::text), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'::text), json_keys('{"a": 1, "b": {"c": 30}}'::json, '$.b'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_keys(CAST('{"a": 1, "b": {"c": 30}}' AS JSON), '$.b')) = 1))
(4 rows)

-- select json_keys (builtin function, json_keys in constraints, result)
--Testcase 3785:
SELECT json_keys(c1), json_keys(c1, '$'), json_keys(json_build_object('a', c3)), json_keys(json_build_object('a', c3), '$.a'), json_keys('{"a": 1, "b": {"c": 30}}', '$.b') FROM s8 WHERE json_length(json_keys('{"a": 1, "b": {"c": 30}}', '$.b')) = 1;
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_keys as nest function with agg (pushdown, explain)
--Testcase 3786:
EXPLAIN VERBOSE
SELECT sum(id),json_keys('{"a": 1, "b": {"c": 30}}', '$.b') FROM s8;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_keys('{"a": 1, "b": {"c": 30}}'::json, '$.b'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_keys(CAST('{"a": 1, "b": {"c": 30}}' AS JSON), '$.b') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_keys as nest function with agg (pushdown, result)
--Testcase 3787:
SELECT sum(id),json_keys('{"a": 1, "b": {"c": 30}}', '$.b') FROM s8;
 sum | json_keys 
-----+-----------
  15 | ["c"]
(1 row)

-- select json_keys with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3788:
EXPLAIN VERBOSE
SELECT json_keys(json_build_object('a', c3)), pi(), 4.1 FROM s8;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=72)
   Output: json_keys(json_build_object('a', c3)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_keys with non pushdown func and explicit constant (result)
--Testcase 3789:
SELECT json_keys(json_build_object('a', c3)), pi(), 4.1 FROM s8;
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_keys with order by index (result)
--Testcase 3790:
SELECT id,  json_length(json_keys(c1)) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_keys with order by index (result)
--Testcase 3791:
SELECT id,  json_length(json_keys(c1)) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_keys with group by (EXPLAIN)
--Testcase 3792:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_keys(c1)) FROM s8 group by json_length(json_keys(c1));
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(json_keys(c1)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_keys(`c1`)) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_keys with group by (result)
--Testcase 3793:
SELECT count(id), json_length(json_keys(c1)) FROM s8 group by json_length(json_keys(c1));
 count | json_length 
-------+-------------
     3 |            
     1 |           0
     2 |           3
(3 rows)

-- select json_keys with group by index (result)
--Testcase 3794:
SELECT id,  json_length(json_keys(c1)) FROM s8 group by 2, 1;
 id | json_length 
----+-------------
  0 |            
  1 |            
  2 |           0
  3 |           3
  4 |           3
  5 |            
(6 rows)

-- select json_keys with group by index (result)
--Testcase 3795:
SELECT id,  json_length(json_keys(c1)) FROM s8 group by 1, 2;
 id | json_length 
----+-------------
  0 |            
  1 |            
  2 |           0
  3 |           3
  4 |           3
  5 |            
(6 rows)

-- select json_keys with group by having (EXPLAIN)
--Testcase 3796:
EXPLAIN VERBOSE
SELECT count(c2), json_length(json_keys(c1)) FROM s8 group by json_length(json_keys(c1)) HAVING count(c2) > 0;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_length(json_keys(c1)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_length(json_keys(`c1`)) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_keys with group by having (result)
--Testcase 3797:
SELECT count(c2), json_length(json_keys(c1)) FROM s8 group by json_length(json_keys(c1)) HAVING count(c2) > 0;
 count | json_length 
-------+-------------
     3 |            
     1 |           0
     2 |           3
(3 rows)

-- select json_keys with group by index having (result)
--Testcase 3798:
SELECT c2,  json_length(json_keys(c1)) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |            
  2 |            
  3 |           0
  4 |           3
  5 |           3
  5 |            
(6 rows)

-- select json_keys with group by index having (result)
--Testcase 3799:
SELECT c2,  json_length(json_keys(c1)) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |            
  2 |            
  3 |           0
  4 |           3
  5 |           3
  5 |            
(6 rows)

-- select json_keys and as
--Testcase 3800:
SELECT json_keys(json_build_object('a', c3)) as json_keys1 FROM s8;
ERROR:  stub json_keys(json) is called
CONTEXT:  PL/pgSQL function json_keys(json) line 3 at RAISE
-- select json_length (builtin function, explain)
--Testcase 3801:
EXPLAIN VERBOSE
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..164.60 rows=1365 width=12)
   Output: json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_length (builtin function, result)
--Testcase 3802:
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_length (builtin function, not pushdown constraints, explain)
--Testcase 3803:
EXPLAIN VERBOSE
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE to_hex(id) = '2';
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.68 rows=7 width=12)
   Output: json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}'::json)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_length (builtin function, not pushdown constraints, result)
--Testcase 3804:
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_length (builtin function, pushdown constraints, explain)
--Testcase 3805:
EXPLAIN VERBOSE
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE id != 0;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..167.80 rows=1358 width=12)
   Output: json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_length (builtin function, pushdown constraints, result)
--Testcase 3806:
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE id != 0;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_length (builtin function, json_length in constraints, explain)
--Testcase 3807:
EXPLAIN VERBOSE
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_length(c1) != 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..171.22 rows=1358 width=12)
   Output: json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(`c1`) <> 1))
(4 rows)

-- select json_length (builtin function, json_length in constraints, result)
--Testcase 3808:
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_length(c1) != 1;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_length (builtin function, json_length in constraints, explain)
--Testcase 3809:
EXPLAIN VERBOSE
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_length('{"a": 1, "b": {"c": 30}}') = 2;
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.68 rows=7 width=12)
   Output: json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(CAST('{"a": 1, "b": {"c": 30}}' AS JSON)) = 2))
(4 rows)

-- select json_length (builtin function, json_length in constraints, result)
--Testcase 3810:
SELECT json_length(c1), json_length(json_build_array(c1, 'a', c2)), json_length('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_length('{"a": 1, "b": {"c": 30}}') = 2;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_length as nest function with agg (pushdown, explain)
--Testcase 3811:
EXPLAIN VERBOSE
SELECT sum(id),json_length('{"a": 1, "b": {"c": 30}}') FROM s8;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (sum(id)), (json_length('{"a": 1, "b": {"c": 30}}'::json))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_length(CAST('{"a": 1, "b": {"c": 30}}' AS JSON)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_length as nest function with agg (pushdown, result)
--Testcase 3812:
SELECT sum(id),json_length('{"a": 1, "b": {"c": 30}}') FROM s8;
 sum | json_length 
-----+-------------
  15 |           2
(1 row)

-- select json_length with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3813:
EXPLAIN VERBOSE
SELECT json_length(json_build_array(c1, 'a', c2)), pi(), 4.1 FROM s8;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.78 rows=1365 width=44)
   Output: json_length(json_build_array(c1, 'a', c2)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_length with non pushdown func and explicit constant (result)
--Testcase 3814:
SELECT json_length(json_build_array(c1, 'a', c2)), pi(), 4.1 FROM s8;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_length with order by index (result)
--Testcase 3815:
SELECT id, json_length(c1) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_length with order by index (result)
--Testcase 3816:
SELECT id, json_length(c1) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_length with group by (EXPLAIN)
--Testcase 3817:
EXPLAIN VERBOSE
SELECT count(id), json_length(c1) FROM s8 group by json_length(c1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_length with group by (result)
--Testcase 3818:
SELECT count(id), json_length(c1) FROM s8 group by json_length(c1);
 count | json_length 
-------+-------------
     3 |           3
     2 |           0
     1 |           4
(3 rows)

-- select json_length with group by index (result)
--Testcase 3819:
SELECT id, json_length(c1) FROM s8 group by 2, 1;
 id | json_length 
----+-------------
  0 |           3
  1 |           0
  2 |           0
  3 |           3
  4 |           3
  5 |           4
(6 rows)

-- select json_length with group by index (result)
--Testcase 3820:
SELECT id, json_length(c1) FROM s8 group by 1, 2;
 id | json_length 
----+-------------
  0 |           3
  1 |           0
  2 |           0
  3 |           3
  4 |           3
  5 |           4
(6 rows)

-- select json_length with group by having (EXPLAIN)
--Testcase 3821:
EXPLAIN VERBOSE
SELECT count(c2), json_length(c1) FROM s8 group by json_length(c1) HAVING count(c2) > 0;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_length(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_length(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_length with group by having (result)
--Testcase 3822:
SELECT count(c2), json_length(c1) FROM s8 group by json_length(c1) HAVING count(c2) > 0;
 count | json_length 
-------+-------------
     3 |           3
     2 |           0
     1 |           4
(3 rows)

-- select json_length with group by index having (result)
--Testcase 3823:
SELECT c2, json_length(c1) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           3
  2 |           0
  3 |           0
  4 |           3
  5 |           3
  5 |           4
(6 rows)

-- select json_length with group by index having (result)
--Testcase 3824:
SELECT c2, json_length(c1) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           3
  2 |           0
  3 |           0
  4 |           3
  5 |           3
  5 |           4
(6 rows)

-- select json_length and as
--Testcase 3825:
SELECT json_length(json_build_array(c1, 'a', c2)) as json_length1 FROM s8;
ERROR:  stub json_length(json) is called
CONTEXT:  PL/pgSQL function json_length(json) line 3 at RAISE
-- select json_merge (builtin function, explain)
--Testcase 3826:
EXPLAIN VERBOSE
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8;
                                                                                                                                  QUERY PLAN                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..172.14 rows=1462 width=128)
   Output: json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_merge (builtin function, result)
--Testcase 3827:
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8;
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge (builtin function, not pushdown constraints, explain)
--Testcase 3828:
EXPLAIN VERBOSE
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                                  QUERY PLAN                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.16 rows=7 width=128)
   Output: json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_merge (builtin function, not pushdown constraints, result)
--Testcase 3829:
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge (builtin function, pushdown constraints, explain)
--Testcase 3830:
EXPLAIN VERBOSE
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8 WHERE id != 0;
                                                                                                                                  QUERY PLAN                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.56 rows=1455 width=128)
   Output: json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_merge (builtin function, pushdown constraints, result)
--Testcase 3831:
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8 WHERE id != 0;
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge (builtin function, json_merge in constraints, explain)
--Testcase 3832:
EXPLAIN VERBOSE
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge(c1, '[1, 2]')) != 1;
                                                                                                                                  QUERY PLAN                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..182.87 rows=1455 width=128)
   Output: json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_merge(`c1`, CAST('[1, 2]' AS JSON))) <> 1))
(4 rows)

-- select json_merge (builtin function, json_merge in constraints, result)
--Testcase 3833:
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge(c1, '[1, 2]')) != 1;
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge (builtin function, json_merge in constraints, explain)
--Testcase 3834:
EXPLAIN VERBOSE
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge('[1, 2]', '[true, false]')) = 4;
                                                                                                                                  QUERY PLAN                                                                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.81 rows=7 width=128)
   Output: json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_merge(CAST('[1, 2]' AS JSON), CAST('[true, false]' AS JSON))) = 4))
(4 rows)

-- select json_merge (builtin function, json_merge in constraints, result)
--Testcase 3835:
SELECT json_merge(c1, '[1, 2]'), json_merge(c1, '[1, 2]', '[true, false]'), json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge('[1, 2]', '[true, false]')) = 4;
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge as nest function with agg (pushdown, explain)
--Testcase 3836:
EXPLAIN VERBOSE
SELECT sum(id),json_merge('[1, 2]', '[true, false]') FROM s8;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_merge(VARIADIC '{"[1, 2]","[true, false]"}'::json[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_merge(CAST('[1, 2]' AS JSON), CAST('[true, false]' AS JSON)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_merge as nest function with agg (pushdown, result)
--Testcase 3837:
SELECT sum(id),json_merge('[1, 2]', '[true, false]') FROM s8;
 sum |     json_merge      
-----+---------------------
  15 | [1, 2, true, false]
(1 row)

-- select json_merge with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3838:
EXPLAIN VERBOSE
SELECT json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), pi(), 4.1 FROM s8;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=72)
   Output: json_merge(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_merge with non pushdown func and explicit constant (result)
--Testcase 3839:
SELECT json_merge(json_build_array(c1, '[1, 2]'), '[true, false]'), pi(), 4.1 FROM s8;
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge with order by index (result)
--Testcase 3840:
SELECT id, json_length(json_merge(c1, '[1, 2]')) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge with order by index (result)
--Testcase 3841:
SELECT id, json_length(json_merge(c1, '[1, 2]')) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge with group by (EXPLAIN)
--Testcase 3842:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_merge(c1, '[1, 2]')) FROM s8 group by json_length(json_merge(c1, '[1, 2]'));
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_merge(`c1`, CAST('[1, 2]' AS JSON))) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_merge with group by (result)
--Testcase 3843:
SELECT count(id), json_length(json_merge(c1, '[1, 2]')) FROM s8 group by json_length(json_merge(c1, '[1, 2]'));
 count | json_length 
-------+-------------
     1 |           5
     1 |           2
     3 |           3
     1 |           6
(4 rows)

-- select json_merge with group by index (result)
--Testcase 3844:
SELECT id, json_length(json_merge(c1, '[1, 2]')) FROM s8 group by 2, 1;
 id | json_length 
----+-------------
  0 |           5
  1 |           2
  2 |           3
  3 |           3
  4 |           3
  5 |           6
(6 rows)

-- select json_merge with group by index (result)
--Testcase 3845:
SELECT id, json_length(json_merge(c1, '[1, 2]')) FROM s8 group by 1, 2;
 id | json_length 
----+-------------
  0 |           5
  1 |           2
  2 |           3
  3 |           3
  4 |           3
  5 |           6
(6 rows)

-- select json_merge with group by having (EXPLAIN)
--Testcase 3846:
EXPLAIN VERBOSE
SELECT count(c2), json_length(json_merge(c1, '[1, 2]')) FROM s8 group by json_length(json_merge(c1, '[1, 2]')) HAVING count(c2) > 0;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_length(json_merge(VARIADIC ARRAY[c1, '[1, 2]'::json])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_length(json_merge(`c1`, CAST('[1, 2]' AS JSON))) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_merge with group by having (result)
--Testcase 3847:
SELECT count(c2), json_length(json_merge(c1, '[1, 2]')) FROM s8 group by json_length(json_merge(c1, '[1, 2]')) HAVING count(c2) > 0;
 count | json_length 
-------+-------------
     1 |           5
     1 |           2
     3 |           3
     1 |           6
(4 rows)

-- select json_merge with group by index having (result)
--Testcase 3848:
SELECT c2, json_length(json_merge(c1, '[1, 2]')) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           5
  2 |           2
  3 |           3
  4 |           3
  5 |           3
  5 |           6
(6 rows)

-- select json_merge with group by index having (result)
--Testcase 3849:
SELECT c2, json_length(json_merge(c1, '[1, 2]')) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           5
  2 |           2
  3 |           3
  4 |           3
  5 |           3
  5 |           6
(6 rows)

-- select json_merge and as
--Testcase 3850:
SELECT json_merge(json_build_array(c1, '[1, 2]'), '[true, false]') as json_merge1 FROM s8;
ERROR:  stub json_merge(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge(json[]) line 3 at RAISE
-- select json_merge_patch (builtin function, explain)
--Testcase 3851:
EXPLAIN VERBOSE
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8;
                                                                                                                                              QUERY PLAN                                                                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..172.14 rows=1462 width=128)
   Output: json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_patch(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_patch(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_merge_patch (builtin function, result)
--Testcase 3852:
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8;
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_patch (builtin function, not pushdown constraints, explain)
--Testcase 3853:
EXPLAIN VERBOSE
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                                              QUERY PLAN                                                                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.16 rows=7 width=128)
   Output: json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_patch(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_patch(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_merge_patch (builtin function, not pushdown constraints, result)
--Testcase 3854:
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_patch (builtin function, pushdown constraints, explain)
--Testcase 3855:
EXPLAIN VERBOSE
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8 WHERE id != 0;
                                                                                                                                              QUERY PLAN                                                                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.56 rows=1455 width=128)
   Output: json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_patch(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_patch(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_merge_patch (builtin function, pushdown constraints, result)
--Testcase 3856:
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8 WHERE id != 0;
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_patch (builtin function, json_merge_patch in constraints, explain)
--Testcase 3857:
EXPLAIN VERBOSE
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge_patch(c1, '[1, 2]')) != 1;
                                                                                                                                              QUERY PLAN                                                                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..182.87 rows=1455 width=128)
   Output: json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_patch(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_patch(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_merge_patch(`c1`, CAST('[1, 2]' AS JSON))) <> 1))
(4 rows)

-- select json_merge_patch (builtin function, json_merge_patch in constraints, result)
--Testcase 3858:
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge_patch(c1, '[1, 2]')) != 1;
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_patch (builtin function, json_merge_patch in constraints, explain)
--Testcase 3859:
EXPLAIN VERBOSE
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge_patch('[1, 2]', '[true, false]')) = 2;
                                                                                                                                              QUERY PLAN                                                                                                                                               
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.81 rows=7 width=128)
   Output: json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_patch(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_patch(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_merge_patch(CAST('[1, 2]' AS JSON), CAST('[true, false]' AS JSON))) = 2))
(4 rows)

-- select json_merge_patch (builtin function, json_merge_patch in constraints, result)
--Testcase 3860:
SELECT json_merge_patch(c1, '[1, 2]'), json_merge_patch(c1, '[1, 2]', '[true, false]'), json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_patch('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge_patch('[1, 2]', '[true, false]')) = 2;
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_patch as nest function with agg (pushdown, explain)
--Testcase 3861:
EXPLAIN VERBOSE
SELECT sum(id),json_merge_patch('[1, 2]', '[true, false]') FROM s8;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_merge_patch(VARIADIC '{"[1, 2]","[true, false]"}'::json[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_merge_patch(CAST('[1, 2]' AS JSON), CAST('[true, false]' AS JSON)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_merge_patch as nest function with agg (pushdown, result)
--Testcase 3862:
SELECT sum(id),json_merge_patch('[1, 2]', '[true, false]') FROM s8;
 sum | json_merge_patch 
-----+------------------
  15 | [true, false]
(1 row)

-- select json_merge_patch with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3863:
EXPLAIN VERBOSE
SELECT json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), pi(), 4.1 FROM s8;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=72)
   Output: json_merge_patch(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_merge_patch with non pushdown func and explicit constant (result)
--Testcase 3864:
SELECT json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]'), pi(), 4.1 FROM s8;
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_patch with order by index (result)
--Testcase 3865:
SELECT id, json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_patch with order by index (result)
--Testcase 3866:
SELECT id, json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_patch with group by (EXPLAIN)
--Testcase 3867:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 group by json_length(json_merge_patch(c1, '[1, 2]'));
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_merge_patch(`c1`, CAST('[1, 2]' AS JSON))) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_merge_patch with group by (result)
--Testcase 3868:
SELECT count(id), json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 group by json_length(json_merge_patch(c1, '[1, 2]'));
 count | json_length 
-------+-------------
     6 |           2
(1 row)

-- select json_merge_patch with group by index (result)
--Testcase 3869:
SELECT id, json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 group by 2, 1;
 id | json_length 
----+-------------
  0 |           2
  1 |           2
  2 |           2
  3 |           2
  4 |           2
  5 |           2
(6 rows)

-- select json_merge_patch with group by index (result)
--Testcase 3870:
SELECT id, json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 group by 1, 2;
 id | json_length 
----+-------------
  0 |           2
  1 |           2
  2 |           2
  3 |           2
  4 |           2
  5 |           2
(6 rows)

-- select json_merge_patch with group by having (EXPLAIN)
--Testcase 3871:
EXPLAIN VERBOSE
SELECT count(c2), json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 group by json_length(json_merge_patch(c1, '[1, 2]')) HAVING count(c2) > 0;
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_length(json_merge_patch(VARIADIC ARRAY[c1, '[1, 2]'::json])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_length(json_merge_patch(`c1`, CAST('[1, 2]' AS JSON))) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_merge_patch with group by having (result)
--Testcase 3872:
SELECT count(c2), json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 group by json_length(json_merge_patch(c1, '[1, 2]')) HAVING count(c2) > 0;
 count | json_length 
-------+-------------
     6 |           2
(1 row)

-- select json_merge_patch with group by index having (result)
--Testcase 3873:
SELECT c2, json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           2
  2 |           2
  3 |           2
  4 |           2
  5 |           2
(5 rows)

-- select json_merge_patch with group by index having (result)
--Testcase 3874:
SELECT c2, json_length(json_merge_patch(c1, '[1, 2]')) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           2
  2 |           2
  3 |           2
  4 |           2
  5 |           2
(5 rows)

-- select json_merge_patch and as
--Testcase 3875:
SELECT json_merge_patch(json_build_array(c1, '[1, 2]'), '[true, false]') as json_merge_patch1 FROM s8;
ERROR:  stub json_merge_patch(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_patch(json[]) line 3 at RAISE
-- select json_merge_preserve (builtin function, explain)
--Testcase 3876:
EXPLAIN VERBOSE
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8;
                                                                                                                                                    QUERY PLAN                                                                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..172.14 rows=1462 width=128)
   Output: json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_preserve(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_preserve(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_merge_preserve (builtin function, result)
--Testcase 3877:
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8;
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- select json_merge_preserve (builtin function, not pushdown constraints, explain)
--Testcase 3878:
EXPLAIN VERBOSE
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                                                    QUERY PLAN                                                                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.16 rows=7 width=128)
   Output: json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_preserve(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_preserve(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_merge_preserve (builtin function, not pushdown constraints, result)
--Testcase 3879:
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- select json_merge_preserve (builtin function, pushdown constraints, explain)
--Testcase 3880:
EXPLAIN VERBOSE
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8 WHERE id != 0;
                                                                                                                                                    QUERY PLAN                                                                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.56 rows=1455 width=128)
   Output: json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_preserve(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_preserve(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_merge_preserve (builtin function, pushdown constraints, result)
--Testcase 3881:
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8 WHERE id != 0;
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- select json_merge_preserve (builtin function, json_merge_preserve in constraints, explain)
--Testcase 3882:
EXPLAIN VERBOSE
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge_preserve(c1, '[1, 2]')) != 1;
                                                                                                                                                    QUERY PLAN                                                                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..182.87 rows=1455 width=128)
   Output: json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_preserve(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_preserve(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_merge_preserve(`c1`, CAST('[1, 2]' AS JSON))) <> 1))
(4 rows)

-- select json_merge_preserve (builtin function, json_merge_preserve in constraints, result)
--Testcase 3883:
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge_preserve(c1, '[1, 2]')) != 1;
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- select json_merge_preserve (builtin function, json_merge_preserve in constraints, explain)
--Testcase 3884:
EXPLAIN VERBOSE
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge_preserve('[1, 2]', '[true, false]')) = 4;
                                                                                                                                                    QUERY PLAN                                                                                                                                                     
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.81 rows=7 width=128)
   Output: json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json]), json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json, '[true, false]'::json]), json_merge_preserve(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), json_merge_preserve(VARIADIC '{"[1, 2]","[true, false]"}'::json[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_merge_preserve(CAST('[1, 2]' AS JSON), CAST('[true, false]' AS JSON))) = 4))
(4 rows)

-- select json_merge_preserve (builtin function, json_merge_preserve in constraints, result)
--Testcase 3885:
SELECT json_merge_preserve(c1, '[1, 2]'), json_merge_preserve(c1, '[1, 2]', '[true, false]'), json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), json_merge_preserve('[1, 2]', '[true, false]') FROM s8 WHERE json_length(json_merge_preserve('[1, 2]', '[true, false]')) = 4;
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- select json_merge_preserve as nest function with agg (pushdown, explain)
--Testcase 3886:
EXPLAIN VERBOSE
SELECT sum(id),json_merge_preserve('[1, 2]', '[true, false]') FROM s8;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_merge_preserve(VARIADIC '{"[1, 2]","[true, false]"}'::json[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_merge_preserve(CAST('[1, 2]' AS JSON), CAST('[true, false]' AS JSON)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_merge_preserve as nest function with agg (pushdown, result)
--Testcase 3887:
SELECT sum(id),json_merge_preserve('[1, 2]', '[true, false]') FROM s8;
 sum | json_merge_preserve 
-----+---------------------
  15 | [1, 2, true, false]
(1 row)

-- select json_merge_preserve with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3888:
EXPLAIN VERBOSE
SELECT json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), pi(), 4.1 FROM s8;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=72)
   Output: json_merge_preserve(VARIADIC ARRAY[json_build_array(c1, '[1, 2]'), '[true, false]'::json]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_merge_preserve with non pushdown func and explicit constant (result)
--Testcase 3889:
SELECT json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]'), pi(), 4.1 FROM s8;
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- select json_merge_preserve with order by index (result)
--Testcase 3890:
SELECT id, json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- select json_merge_preserve with order by index (result)
--Testcase 3891:
SELECT id, json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- select json_merge_preserve with group by (EXPLAIN)
--Testcase 3892:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 group by json_length(json_merge_preserve(c1, '[1, 2]'));
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_merge_preserve(`c1`, CAST('[1, 2]' AS JSON))) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_merge_preserve with group by (result)
--Testcase 3893:
SELECT count(id), json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 group by json_length(json_merge_preserve(c1, '[1, 2]'));
 count | json_length 
-------+-------------
     1 |           5
     1 |           2
     3 |           3
     1 |           6
(4 rows)

-- select json_merge_preserve with group by index (result)
--Testcase 3894:
SELECT id, json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 group by 2, 1;
 id | json_length 
----+-------------
  0 |           5
  1 |           2
  2 |           3
  3 |           3
  4 |           3
  5 |           6
(6 rows)

-- select json_merge_preserve with group by index (result)
--Testcase 3895:
SELECT id, json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 group by 1, 2;
 id | json_length 
----+-------------
  0 |           5
  1 |           2
  2 |           3
  3 |           3
  4 |           3
  5 |           6
(6 rows)

-- select json_merge_preserve with group by having (EXPLAIN)
--Testcase 3896:
EXPLAIN VERBOSE
SELECT count(c2), json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 group by json_length(json_merge_preserve(c1, '[1, 2]')) HAVING count(c2) > 0;
                                                                               QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_length(json_merge_preserve(VARIADIC ARRAY[c1, '[1, 2]'::json])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_length(json_merge_preserve(`c1`, CAST('[1, 2]' AS JSON))) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_merge_preserve with group by having (result)
--Testcase 3897:
SELECT count(c2), json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 group by json_length(json_merge_preserve(c1, '[1, 2]')) HAVING count(c2) > 0;
 count | json_length 
-------+-------------
     1 |           5
     1 |           2
     3 |           3
     1 |           6
(4 rows)

-- select json_merge_preserve with group by index having (result)
--Testcase 3898:
SELECT c2, json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           5
  2 |           2
  3 |           3
  4 |           3
  5 |           3
  5 |           6
(6 rows)

-- select json_merge_preserve with group by index having (result)
--Testcase 3899:
SELECT c2, json_length(json_merge_preserve(c1, '[1, 2]')) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           5
  2 |           2
  3 |           3
  4 |           3
  5 |           3
  5 |           6
(6 rows)

-- select json_merge_preserve and as
--Testcase 3900:
SELECT json_merge_preserve(json_build_array(c1, '[1, 2]'), '[true, false]') as json_merge_preserve1 FROM s8;
ERROR:  stub json_merge_preserve(variadic json[]) is called
CONTEXT:  PL/pgSQL function json_merge_preserve(json[]) line 3 at RAISE
-- json_build_object --> json_object in mysql
-- select json_build_object (builtin function, explain)
--Testcase 3901:
EXPLAIN VERBOSE
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..141.15 rows=890 width=32)
   Output: json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL::unknown, 'h', true)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_build_object (builtin function, result)
--Testcase 3902:
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8;
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select json_build_object (builtin function, not pushdown constraints, explain)
--Testcase 3903:
EXPLAIN VERBOSE
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8 WHERE to_hex(id) = '1';
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..123.45 rows=4 width=32)
   Output: json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL::unknown, 'h', true)
   Filter: (to_hex(s8.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_build_object (builtin function, not pushdown constraints, result)
--Testcase 3904:
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8 WHERE to_hex(id) = '1';
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select json_build_object (builtin function, pushdown constraints, explain)
--Testcase 3905:
EXPLAIN VERBOSE
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8 WHERE id = 1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..121.23 rows=4 width=32)
   Output: json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL::unknown, 'h', true)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 1))
(4 rows)

-- select json_build_object (builtin function, pushdown constraints, result)
--Testcase 3906:
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8 WHERE id = 1;
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select json_build_object (builtin function, stub in constraints, explain)
--Testcase 3907:
EXPLAIN VERBOSE
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8 WHERE log2(id) > 1;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..133.00 rows=297 width=32)
   Output: json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL::unknown, 'h', true)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((log2(`id`) > 1))
(4 rows)

-- select json_build_object (builtin function, stub in constraints, result)
--Testcase 3908:
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8 WHERE log2(id) > 1;
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select json_build_object (builtin function, stub in constraints, explain)
--Testcase 3909:
EXPLAIN VERBOSE
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8 WHERE json_depth(json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE)) > 0;
                                                                                                      QUERY PLAN                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.23 rows=297 width=32)
   Output: json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL::unknown, 'h', true)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2`, `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_depth(json_object('a', `c1`, 'b', `c2`, 'c', `c3`, 'd', 1, 'e', 'this is ''text'' value', 'f', pi(), 'g', NULL, 'h', true)) > 0))
(4 rows)

-- select json_build_object (builtin function, stub in constraints, result)
--Testcase 3910:
SELECT json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE) FROM s8 WHERE json_depth(json_build_object('a', c1, 'b', c2, 'c', c3, 'd', 1, 'e', 'this is ''text'' value', 'f', mysql_pi(), 'g', NULL, 'h', TRUE)) > 0;
ERROR:  stub mysql_pi() is called
CONTEXT:  PL/pgSQL function mysql_pi() line 3 at RAISE
-- select json_build_object as nest function with agg (pushdown, explain)
--Testcase 3911:
EXPLAIN VERBOSE
SELECT sum(id),json_build_object('sum', sum(id)) FROM s8;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_build_object('sum', sum(id)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_object('sum', sum(`id`)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_build_object as nest function with agg (pushdown, result)
--Testcase 3912:
SELECT sum(id),json_build_object('sum', sum(id)) FROM s8;
 sum | json_build_object 
-----+-------------------
  15 | {"sum": 15}
(1 row)

-- select json_build_object as nest function with stub (pushdown, explain)
--Testcase 3913:
EXPLAIN VERBOSE
SELECT json_build_object('json_val', '{"a": 100}'::json, 'stub_log2', log2(id)) FROM s8;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..219.69 rows=2925 width=32)
   Output: json_build_object('json_val', '{"a": 100}'::json, 'stub_log2', log2((id)::double precision))
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_build_object as nest function with agg (pushdown, result)
--Testcase 3914:
SELECT json_build_object('json_val', '{"a": 100}'::json, 'stub_log2', log2(id)) FROM s8;
ERROR:  stub log2(float8) is called
CONTEXT:  PL/pgSQL function log2(double precision) line 3 at RAISE
-- select json_build_object with non pushdown func and explicit constant (explain)
--Testcase 3915:
EXPLAIN VERBOSE
SELECT json_build_object('val1', '100'), cosd(id), 4.1 FROM s8;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..219.69 rows=2925 width=72)
   Output: json_build_object('val1', '100'), cosd((id)::double precision), 4.1
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_build_object with non pushdown func and explicit constant (result)
--Testcase 3916:
SELECT json_build_object('val1', '100'), cosd(id), 4.1 FROM s8;
 json_build_object |        cosd        | ?column? 
-------------------+--------------------+----------
 {"val1" : "100"}  |                  1 |      4.1
 {"val1" : "100"}  | 0.9998476951563913 |      4.1
 {"val1" : "100"}  | 0.9993908270190958 |      4.1
 {"val1" : "100"}  | 0.9986295347545738 |      4.1
 {"val1" : "100"}  | 0.9975640502598242 |      4.1
 {"val1" : "100"}  | 0.9961946980917455 |      4.1
(6 rows)

-- select json_build_object with order by (explain)
--Testcase 3917:
EXPLAIN VERBOSE
SELECT json_length(json_build_object(c1, '$[1], c2')) FROM s8 ORDER BY 1;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.15 rows=30 width=4)
   Output: json_length(json_build_object(c1, '$[1], c2'))
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` ORDER BY json_length(json_object(`c1`, '$[1], c2')) IS NULL ASC, json_length(json_object(`c1`, '$[1], c2')) ASC
(4 rows)

-- select json_build_object with order by (result)
--Testcase 3918:
SELECT json_length(json_build_object(c1, '$[1], c2')) FROM s8 ORDER BY 1;
ERROR:  key value must be scalar, not array, composite, or json
-- select json_build_object with group by (explain)
--Testcase 3919:
EXPLAIN VERBOSE
SELECT json_length(json_build_object('a', c1, 'b', c2, 'c', c3)) FROM s8 GROUP BY 1;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=4)
   Output: (json_length(json_build_object('a', c1, 'b', c2, 'c', c3)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_length(json_object('a', `c1`, 'b', `c2`, 'c', `c3`)) FROM `mysql_fdw_regress`.`s8` GROUP BY 1
(5 rows)

-- select json_build_object with group by (result)
--Testcase 3920:
SELECT json_length(json_build_object('a', c1, 'b', c2, 'c', c3)) FROM s8 GROUP BY 1;
 json_length 
-------------
           3
(1 row)

-- select json_build_object with group by having (explain)
--Testcase 3921:
EXPLAIN VERBOSE
SELECT json_depth(json_build_object('a', c1, 'b', c2, 'c', c3)) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=8)
   Output: (json_depth(json_build_object('a', c1, 'b', c2, 'c', c3))), c2
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_depth(json_object('a', `c1`, 'b', `c2`, 'c', `c3`)), `c2` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1 HAVING ((count(`c2`) > 1))
(5 rows)

-- select json_build_object with group by having (result)
--Testcase 3922:
SELECT json_depth(json_build_object('a', c1, 'b', c2, 'c', c3)) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
 json_depth 
------------
(0 rows)

-- select json_build_object and as
--Testcase 3923:
SELECT json_build_object('a', c1, 'b', c2, 'c', c3) AS json_build_object1 FROM s8;
                                     json_build_object1                                     
--------------------------------------------------------------------------------------------
 {"a" : [[1, 2], [3, 4], 5], "b" : 1, "c" : "This"}
 {"a" : [], "b" : 2, "c" : "is"}
 {"a" : {}, "b" : 3, "c" : "text"}
 {"a" : {"a": "10", "b": "15", "x": 25}, "b" : 4, "c" : "scalar"}
 {"a" : {"a": 1, "b": 2, "c": {"d": 4}}, "b" : 5, "c" : "scalar"}
 {"a" : ["abc", [{"k": "10"}, "def"], {"x": "abc"}, {"y": "bcd"}], "b" : 5, "c" : "scalar"}
(6 rows)

-- select json_overlaps (builtin function, explain)
--Testcase 3924:
EXPLAIN VERBOSE
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8;
                                                                                                                                          QUERY PLAN                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.79 rows=1462 width=20)
   Output: json_overlaps(c1, '[[1, 2], [3, 4], 5]'::json), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'::json), json_overlaps(c1, c1), json_overlaps('{"a":1,"b":10,"d":10}'::json, '{"c":1,"e":10,"f":1,"d":10}'::json), json_overlaps('[1,3,5,7]'::json, '[2,5,7]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_overlaps (builtin function, result)
--Testcase 3925:
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8;
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_overlaps (builtin function, not pushdown constraints, explain)
--Testcase 3926:
EXPLAIN VERBOSE
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                                          QUERY PLAN                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.17 rows=7 width=20)
   Output: json_overlaps(c1, '[[1, 2], [3, 4], 5]'::json), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'::json), json_overlaps(c1, c1), json_overlaps('{"a":1,"b":10,"d":10}'::json, '{"c":1,"e":10,"f":1,"d":10}'::json), json_overlaps('[1,3,5,7]'::json, '[2,5,7]'::json)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_overlaps (builtin function, not pushdown constraints, result)
--Testcase 3927:
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_overlaps (builtin function, pushdown constraints, explain)
--Testcase 3928:
EXPLAIN VERBOSE
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8 WHERE id != 0;
                                                                                                                                          QUERY PLAN                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..179.20 rows=1455 width=20)
   Output: json_overlaps(c1, '[[1, 2], [3, 4], 5]'::json), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'::json), json_overlaps(c1, c1), json_overlaps('{"a":1,"b":10,"d":10}'::json, '{"c":1,"e":10,"f":1,"d":10}'::json), json_overlaps('[1,3,5,7]'::json, '[2,5,7]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_overlaps (builtin function, pushdown constraints, result)
--Testcase 3929:
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8 WHERE id != 0;
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_overlaps (builtin function, json_overlaps in constraints, explain)
--Testcase 3930:
EXPLAIN VERBOSE
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8 WHERE json_overlaps(c1, '[[1, 2], [3, 4], 5]') != 1;
                                                                                                                                          QUERY PLAN                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..182.86 rows=1455 width=20)
   Output: json_overlaps(c1, '[[1, 2], [3, 4], 5]'::json), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'::json), json_overlaps(c1, c1), json_overlaps('{"a":1,"b":10,"d":10}'::json, '{"c":1,"e":10,"f":1,"d":10}'::json), json_overlaps('[1,3,5,7]'::json, '[2,5,7]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_overlaps(`c1`, CAST('[[1, 2], [3, 4], 5]' AS JSON)) <> 1))
(4 rows)

-- select json_overlaps (builtin function, json_overlaps in constraints, result)
--Testcase 3931:
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8 WHERE json_overlaps(c1, '[[1, 2], [3, 4], 5]') != 1;
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_overlaps (builtin function, json_overlaps in constraints, explain)
--Testcase 3932:
EXPLAIN VERBOSE
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8 WHERE json_overlaps('[1,3,5,7]', '[2,5,7]') = 1;
                                                                                                                                          QUERY PLAN                                                                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.17 rows=7 width=20)
   Output: json_overlaps(c1, '[[1, 2], [3, 4], 5]'::json), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'::json), json_overlaps(c1, c1), json_overlaps('{"a":1,"b":10,"d":10}'::json, '{"c":1,"e":10,"f":1,"d":10}'::json), json_overlaps('[1,3,5,7]'::json, '[2,5,7]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_overlaps(CAST('[1,3,5,7]' AS JSON), CAST('[2,5,7]' AS JSON)) = 1))
(4 rows)

-- select json_overlaps (builtin function, json_overlaps in constraints, result)
--Testcase 3933:
SELECT json_overlaps(c1, '[[1, 2], [3, 4], 5]'), json_overlaps(json_build_array(c1, '1'), '[[1, 2], [3, 4], 5]'), json_overlaps(c1, c1),json_overlaps('{"a":1,"b":10,"d":10}', '{"c":1,"e":10,"f":1,"d":10}'),json_overlaps('[1,3,5,7]', '[2,5,7]') FROM s8 WHERE json_overlaps('[1,3,5,7]', '[2,5,7]') = 1;
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_overlaps with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3934:
EXPLAIN VERBOSE
SELECT json_overlaps(c1, c1), pi(), 4.1 FROM s8;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=44)
   Output: json_overlaps(c1, c1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_overlaps with non pushdown func and explicit constant (result)
--Testcase 3935:
SELECT json_overlaps(c1, c1), pi(), 4.1 FROM s8;
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_overlaps with order by index (result)
--Testcase 3936:
SELECT id,  json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 ORDER BY 2, 1;
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_overlaps with order by index (result)
--Testcase 3937:
SELECT id,  json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 ORDER BY 1, 2;
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_overlaps with group by (EXPLAIN)
--Testcase 3938:
EXPLAIN VERBOSE
SELECT count(id), json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 group by json_overlaps(c1, '[[1, 2], [3, 4], 5]');
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_overlaps(c1, '[[1, 2], [3, 4], 5]'::json))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_overlaps(`c1`, CAST('[[1, 2], [3, 4], 5]' AS JSON)) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_overlaps with group by (result)
--Testcase 3939:
SELECT count(id), json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 group by json_overlaps(c1, '[[1, 2], [3, 4], 5]');
 count | json_overlaps 
-------+---------------
     1 |             1
     5 |             0
(2 rows)

-- select json_overlaps with group by index (result)
--Testcase 3940:
SELECT id,  json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 group by 2, 1;
 id | json_overlaps 
----+---------------
  0 |             1
  1 |             0
  2 |             0
  3 |             0
  4 |             0
  5 |             0
(6 rows)

-- select json_overlaps with group by index (result)
--Testcase 3941:
SELECT id,  json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 group by 1, 2;
 id | json_overlaps 
----+---------------
  0 |             1
  1 |             0
  2 |             0
  3 |             0
  4 |             0
  5 |             0
(6 rows)

-- select json_overlaps with group by having (EXPLAIN)
--Testcase 3942:
EXPLAIN VERBOSE
SELECT count(c2), json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 group by json_overlaps(c1, '[[1, 2], [3, 4], 5]') HAVING count(c2) > 0;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_overlaps(c1, '[[1, 2], [3, 4], 5]'::json))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_overlaps(`c1`, CAST('[[1, 2], [3, 4], 5]' AS JSON)) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_overlaps with group by having (result)
--Testcase 3943:
SELECT count(c2), json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 group by json_overlaps(c1, '[[1, 2], [3, 4], 5]') HAVING count(c2) > 0;
 count | json_overlaps 
-------+---------------
     1 |             1
     5 |             0
(2 rows)

-- select json_overlaps with group by index having (result)
--Testcase 3944:
SELECT c2,  json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_overlaps 
----+---------------
  1 |             1
  2 |             0
  3 |             0
  4 |             0
  5 |             0
(5 rows)

-- select json_overlaps with group by index having (result)
--Testcase 3945:
SELECT c2,  json_overlaps(c1, '[[1, 2], [3, 4], 5]') FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_overlaps 
----+---------------
  1 |             1
  2 |             0
  3 |             0
  4 |             0
  5 |             0
(5 rows)

-- select json_overlaps and as
--Testcase 3946:
SELECT json_overlaps(c1, c1) as json_overlaps1 FROM s8;
ERROR:  stub json_overlaps(json, json) is called
CONTEXT:  PL/pgSQL function json_overlaps(json,json) line 3 at RAISE
-- select json_pretty (builtin function, explain)
--Testcase 3947:
EXPLAIN VERBOSE
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8;
                                                                                              QUERY PLAN                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..172.14 rows=1462 width=128)
   Output: json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'::json), json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_pretty (builtin function, result)
--Testcase 3948:
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8;
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_pretty (builtin function, not pushdown constraints, explain)
--Testcase 3949:
EXPLAIN VERBOSE
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8 WHERE to_hex(id) = '2';
                                                                                              QUERY PLAN                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.16 rows=7 width=128)
   Output: json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'::json), json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]'::json)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_pretty (builtin function, not pushdown constraints, result)
--Testcase 3950:
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_pretty (builtin function, pushdown constraints, explain)
--Testcase 3951:
EXPLAIN VERBOSE
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8 WHERE id != 0;
                                                                                              QUERY PLAN                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.56 rows=1455 width=128)
   Output: json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'::json), json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_pretty (builtin function, pushdown constraints, result)
--Testcase 3952:
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8 WHERE id != 0;
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_pretty (builtin function, json_pretty in constraints, explain)
--Testcase 3953:
EXPLAIN VERBOSE
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8 WHERE json_length(json_pretty(c1)) != 1;
                                                                                              QUERY PLAN                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..182.87 rows=1455 width=128)
   Output: json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'::json), json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_pretty(`c1`)) <> 1))
(4 rows)

-- select json_pretty (builtin function, json_pretty in constraints, result)
--Testcase 3954:
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8 WHERE json_length(json_pretty(c1)) != 1;
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_pretty (builtin function, json_pretty in constraints, explain)
--Testcase 3955:
EXPLAIN VERBOSE
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8 WHERE json_length( json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]')) = 8;
                                                                                              QUERY PLAN                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.81 rows=7 width=128)
   Output: json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'::json), json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_pretty(CAST('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]' AS JSON))) = 8))
(4 rows)

-- select json_pretty (builtin function, json_pretty in constraints, result)
--Testcase 3956:
SELECT json_pretty(c1), json_pretty(json_build_array(c1, 1)), json_pretty('[1,3,5]'),  json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8 WHERE json_length( json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]')) = 8;
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_pretty as nest function with agg (pushdown, explain)
--Testcase 3957:
EXPLAIN VERBOSE
SELECT sum(id), json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]'::json))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_pretty(CAST('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]' AS JSON)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_pretty as nest function with agg (pushdown, result)
--Testcase 3958:
SELECT sum(id), json_pretty('["a",1,{"key1":"value1"},"5","77",{"key2":["value3","valuex","valuey"]},"j","2"]') FROM s8;
 sum |     json_pretty      
-----+----------------------
  15 | [                   +
     |   "a",              +
     |   1,                +
     |   {                 +
     |     "key1": "value1"+
     |   },                +
     |   "5",              +
     |   "77",             +
     |   {                 +
     |     "key2": [       +
     |       "value3",     +
     |       "valuex",     +
     |       "valuey"      +
     |     ]               +
     |   },                +
     |   "j",              +
     |   "2"               +
     | ]
(1 row)

-- select json_pretty with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3959:
EXPLAIN VERBOSE
SELECT json_pretty('[1,3,5]'), pi(), 4.1 FROM s8;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..220.92 rows=3413 width=72)
   Output: json_pretty('[1,3,5]'::json), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_pretty with non pushdown func and explicit constant (result)
--Testcase 3960:
SELECT json_pretty('[1,3,5]'), pi(), 4.1 FROM s8;
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_pretty with order by index (result)
--Testcase 3961:
SELECT id, json_length(json_pretty(c1)) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_pretty with order by index (result)
--Testcase 3962:
SELECT id, json_length(json_pretty(c1)) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_pretty with group by (EXPLAIN)
--Testcase 3963:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_pretty(c1)) FROM s8 group by json_length(json_pretty(c1));
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(json_pretty(c1)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_pretty(`c1`)) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_pretty with group by (result)
--Testcase 3964:
SELECT count(id), json_length(json_pretty(c1)) FROM s8 group by json_length(json_pretty(c1));
 count | json_length 
-------+-------------
     3 |           3
     2 |           0
     1 |           4
(3 rows)

-- select json_pretty with group by index (result)
--Testcase 3965:
SELECT id, json_length(json_pretty(c1)) FROM s8 group by 2, 1;
 id | json_length 
----+-------------
  0 |           3
  1 |           0
  2 |           0
  3 |           3
  4 |           3
  5 |           4
(6 rows)

-- select json_pretty with group by index (result)
--Testcase 3966:
SELECT id, json_length(json_pretty(c1)) FROM s8 group by 1, 2;
 id | json_length 
----+-------------
  0 |           3
  1 |           0
  2 |           0
  3 |           3
  4 |           3
  5 |           4
(6 rows)

-- select json_pretty with group by having (EXPLAIN)
--Testcase 3967:
EXPLAIN VERBOSE
SELECT count(c2), json_length(json_pretty(c1)) FROM s8 group by json_length(json_pretty(c1)) HAVING count(c2) > 0;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_length(json_pretty(c1)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_length(json_pretty(`c1`)) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_pretty with group by having (result)
--Testcase 3968:
SELECT count(c2), json_length(json_pretty(c1)) FROM s8 group by json_length(json_pretty(c1)) HAVING count(c2) > 0;
 count | json_length 
-------+-------------
     3 |           3
     2 |           0
     1 |           4
(3 rows)

-- select json_pretty with group by index having (result)
--Testcase 3969:
SELECT c2, json_length(json_pretty(c1)) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           3
  2 |           0
  3 |           0
  4 |           3
  5 |           3
  5 |           4
(6 rows)

-- select json_pretty with group by index having (result)
--Testcase 3970:
SELECT c2, json_length(json_pretty(c1)) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           3
  2 |           0
  3 |           0
  4 |           3
  5 |           3
  5 |           4
(6 rows)

-- select json_pretty and as
--Testcase 3971:
SELECT json_pretty('[1,3,5]') as json_pretty1 FROM s8;
ERROR:  stub json_pretty(json) is called
CONTEXT:  PL/pgSQL function json_pretty(json) line 3 at RAISE
-- select json_quote (builtin function, explain)
--Testcase 3972:
EXPLAIN VERBOSE
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..168.48 rows=1462 width=128)
   Output: json_quote(c3), json_quote('null'::text), json_quote('"null"'::text), json_quote('[1, 2, 3]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_quote (builtin function, result)
--Testcase 3973:
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_quote (builtin function, not pushdown constraints, explain)
--Testcase 3974:
EXPLAIN VERBOSE
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8 WHERE to_hex(id) = '2';
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.14 rows=7 width=128)
   Output: json_quote(c3), json_quote('null'::text), json_quote('"null"'::text), json_quote('[1, 2, 3]'::text)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_quote (builtin function, not pushdown constraints, result)
--Testcase 3975:
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_quote (builtin function, pushdown constraints, explain)
--Testcase 3976:
EXPLAIN VERBOSE
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8 WHERE id != 0;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..171.93 rows=1455 width=128)
   Output: json_quote(c3), json_quote('null'::text), json_quote('"null"'::text), json_quote('[1, 2, 3]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_quote (builtin function, pushdown constraints, result)
--Testcase 3977:
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8 WHERE id != 0;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_quote (builtin function, json_quote in constraints, explain)
--Testcase 3978:
EXPLAIN VERBOSE
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8 WHERE json_length(json_quote(c3)) != 0;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..179.24 rows=1455 width=128)
   Output: json_quote(c3), json_quote('null'::text), json_quote('"null"'::text), json_quote('[1, 2, 3]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_quote(`c3`)) <> 0))
(4 rows)

-- select json_quote (builtin function, json_quote in constraints, result)
--Testcase 3979:
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8 WHERE json_length(json_quote(c3)) != 0;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_quote (builtin function, json_quote in constraints, explain)
--Testcase 3980:
EXPLAIN VERBOSE
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8 WHERE json_length(json_quote('[1, 2, 3]')) = 1;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.79 rows=7 width=128)
   Output: json_quote(c3), json_quote('null'::text), json_quote('"null"'::text), json_quote('[1, 2, 3]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_quote('[1, 2, 3]')) = 1))
(4 rows)

-- select json_quote (builtin function, json_quote in constraints, result)
--Testcase 3981:
SELECT json_quote(c3), json_quote('null'), json_quote('"null"'), json_quote('[1, 2, 3]') FROM s8 WHERE json_length(json_quote('[1, 2, 3]')) = 1;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_quote as nest function with agg (pushdown, explain)
--Testcase 3982:
EXPLAIN VERBOSE
SELECT sum(id), json_quote('[1, 2, 3]') FROM s8;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_quote('[1, 2, 3]'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_quote('[1, 2, 3]') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_quote as nest function with agg (pushdown, result)
--Testcase 3983:
SELECT sum(id), json_quote('[1, 2, 3]') FROM s8;
 sum | json_quote  
-----+-------------
  15 | "[1, 2, 3]"
(1 row)

-- select json_quote with non pushdown func and explicit constant (EXPLAIN)
--Testcase 3984:
EXPLAIN VERBOSE
SELECT json_quote('null'), pi(), 4.1 FROM s8;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..220.92 rows=3413 width=72)
   Output: json_quote('null'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_quote with non pushdown func and explicit constant (result)
--Testcase 3985:
SELECT json_quote('null'), pi(), 4.1 FROM s8;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_quote with order by index (result)
--Testcase 3986:
SELECT id,  json_length(json_quote(c3)) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_quote with order by index (result)
--Testcase 3987:
SELECT id,  json_length(json_quote(c3)) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_quote with group by (EXPLAIN)
--Testcase 3988:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_quote(c3)) FROM s8 group by json_length(json_quote(c3));
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(json_quote(c3)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_quote(`c3`)) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_quote with group by (result)
--Testcase 3989:
SELECT count(id), json_length(json_quote(c3)) FROM s8 group by json_length(json_quote(c3));
 count | json_length 
-------+-------------
     6 |           1
(1 row)

-- select json_quote with group by index (result)
--Testcase 3990:
SELECT id,  json_length(json_quote(c3)) FROM s8 group by 2, 1;
 id | json_length 
----+-------------
  0 |           1
  1 |           1
  2 |           1
  3 |           1
  4 |           1
  5 |           1
(6 rows)

-- select json_quote with group by index (result)
--Testcase 3991:
SELECT id,  json_length(json_quote(c3)) FROM s8 group by 1, 2;
 id | json_length 
----+-------------
  0 |           1
  1 |           1
  2 |           1
  3 |           1
  4 |           1
  5 |           1
(6 rows)

-- select json_quote with group by having (EXPLAIN)
--Testcase 3992:
EXPLAIN VERBOSE
SELECT count(c2), json_length(json_quote(c3)) FROM s8 group by json_length(json_quote(c3)) HAVING count(c2) > 0;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_length(json_quote(c3)))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_length(json_quote(`c3`)) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_quote with group by having (result)
--Testcase 3993:
SELECT count(c2), json_length(json_quote(c3)) FROM s8 group by json_length(json_quote(c3)) HAVING count(c2) > 0;
 count | json_length 
-------+-------------
     6 |           1
(1 row)

-- select json_quote with group by index having (result)
--Testcase 3994:
SELECT c2,  json_length(json_quote(c3)) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           1
  2 |           1
  3 |           1
  4 |           1
  5 |           1
(5 rows)

-- select json_quote with group by index having (result)
--Testcase 3995:
SELECT c2,  json_length(json_quote(c3)) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           1
  2 |           1
  3 |           1
  4 |           1
  5 |           1
(5 rows)

-- select json_quote and as
--Testcase 3996:
SELECT json_quote('null') as json_quote1 FROM s8;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_remove (builtin function, explain)
--Testcase 3997:
EXPLAIN VERBOSE
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'),json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8;
                                                                                                                                                         QUERY PLAN                                                                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.79 rows=1462 width=160)
   Output: json_remove(c1, VARIADIC '{$[1]}'::text[]), json_remove(c1, VARIADIC '{$[1],$[2]}'::text[]), json_remove(json_build_array(c1, '1'), VARIADIC '{$[1],$[2]}'::text[]), json_remove('{ "a": 1, "b": [2, 3]}'::json, VARIADIC '{$.a}'::text[]), json_remove('["a", ["b", "c"], "d"]'::json, VARIADIC '{$.a}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_remove (builtin function, result)
--Testcase 3998:
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8;
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_remove (builtin function, not pushdown constraints, explain)
--Testcase 3999:
EXPLAIN VERBOSE
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                                                         QUERY PLAN                                                                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.17 rows=7 width=160)
   Output: json_remove(c1, VARIADIC '{$[1]}'::text[]), json_remove(c1, VARIADIC '{$[1],$[2]}'::text[]), json_remove(json_build_array(c1, '1'), VARIADIC '{$[1],$[2]}'::text[]), json_remove('{ "a": 1, "b": [2, 3]}'::json, VARIADIC '{$.a}'::text[]), json_remove('["a", ["b", "c"], "d"]'::json, VARIADIC '{$.a}'::text[])
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_remove (builtin function, not pushdown constraints, result)
--Testcase 4000:
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_remove (builtin function, pushdown constraints, explain)
--Testcase 4001:
EXPLAIN VERBOSE
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8 WHERE id != 0;
                                                                                                                                                         QUERY PLAN                                                                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..179.20 rows=1455 width=160)
   Output: json_remove(c1, VARIADIC '{$[1]}'::text[]), json_remove(c1, VARIADIC '{$[1],$[2]}'::text[]), json_remove(json_build_array(c1, '1'), VARIADIC '{$[1],$[2]}'::text[]), json_remove('{ "a": 1, "b": [2, 3]}'::json, VARIADIC '{$.a}'::text[]), json_remove('["a", ["b", "c"], "d"]'::json, VARIADIC '{$.a}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_remove (builtin function, pushdown constraints, result)
--Testcase 4002:
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8 WHERE id != 0;
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_remove (builtin function, json_remove in constraints, explain)
--Testcase 4003:
EXPLAIN VERBOSE
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8 WHERE json_length(json_remove(c1, '$[1]')) != 1;
                                                                                                                                                         QUERY PLAN                                                                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..186.51 rows=1455 width=160)
   Output: json_remove(c1, VARIADIC '{$[1]}'::text[]), json_remove(c1, VARIADIC '{$[1],$[2]}'::text[]), json_remove(json_build_array(c1, '1'), VARIADIC '{$[1],$[2]}'::text[]), json_remove('{ "a": 1, "b": [2, 3]}'::json, VARIADIC '{$.a}'::text[]), json_remove('["a", ["b", "c"], "d"]'::json, VARIADIC '{$.a}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_remove(`c1`, '$[1]')) <> 1))
(4 rows)

-- select json_remove (builtin function, json_remove in constraints, result)
--Testcase 4004:
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8 WHERE json_length(json_remove(c1, '$[1]')) != 1;
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_remove (builtin function, json_remove in constraints, explain)
--Testcase 4005:
EXPLAIN VERBOSE
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8 WHERE json_length(json_remove('{ "a": 1, "b": [2, 3]}', '$.a')) = 1;
                                                                                                                                                         QUERY PLAN                                                                                                                                                          
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.83 rows=7 width=160)
   Output: json_remove(c1, VARIADIC '{$[1]}'::text[]), json_remove(c1, VARIADIC '{$[1],$[2]}'::text[]), json_remove(json_build_array(c1, '1'), VARIADIC '{$[1],$[2]}'::text[]), json_remove('{ "a": 1, "b": [2, 3]}'::json, VARIADIC '{$.a}'::text[]), json_remove('["a", ["b", "c"], "d"]'::json, VARIADIC '{$.a}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_length(json_remove(CAST('{ "a": 1, "b": [2, 3]}' AS JSON), '$.a')) = 1))
(4 rows)

-- select json_remove (builtin function, json_remove in constraints, result)
--Testcase 4006:
SELECT json_remove(c1, '$[1]'), json_remove(c1, '$[1]', '$[2]'), json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), json_remove('{ "a": 1, "b": [2, 3]}', '$.a'), json_remove('["a", ["b", "c"], "d"]', '$.a') FROM s8 WHERE json_length(json_remove('{ "a": 1, "b": [2, 3]}', '$.a')) = 1;
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_remove as nest function with agg (pushdown, explain)
--Testcase 4007:
EXPLAIN VERBOSE
SELECT sum(id), json_remove('{ "a": 1, "b": [2, 3]}', '$.a') FROM s8;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_remove('{ "a": 1, "b": [2, 3]}'::json, VARIADIC '{$.a}'::text[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_remove(CAST('{ "a": 1, "b": [2, 3]}' AS JSON), '$.a') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_remove as nest function with agg (pushdown, result)
--Testcase 4008:
SELECT sum(id), json_remove('{ "a": 1, "b": [2, 3]}', '$.a') FROM s8;
 sum |  json_remove  
-----+---------------
  15 | {"b": [2, 3]}
(1 row)

-- select json_remove with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4009:
EXPLAIN VERBOSE
SELECT json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), pi(), 4.1 FROM s8;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=72)
   Output: json_remove(json_build_array(c1, '1'), VARIADIC '{$[1],$[2]}'::text[]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_remove with non pushdown func and explicit constant (result)
--Testcase 4010:
SELECT json_remove(json_build_array(c1, '1'), '$[1]', '$[2]'), pi(), 4.1 FROM s8;
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_remove with order by index (result)
--Testcase 4011:
SELECT id,  json_length(json_remove(c1, '$[1]')) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_remove with order by index (result)
--Testcase 4012:
SELECT id,  json_length(json_remove(c1, '$[1]')) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_remove with group by (EXPLAIN)
--Testcase 4013:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_remove(c1, '$[1]')) FROM s8 group by json_length(json_remove(c1, '$[1]'));
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(json_remove(c1, VARIADIC '{$[1]}'::text[])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_remove(`c1`, '$[1]')) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_remove with group by (result)
--Testcase 4014:
SELECT count(id), json_length(json_remove(c1, '$[1]')) FROM s8 group by json_length(json_remove(c1, '$[1]'));
 count | json_length 
-------+-------------
     1 |           2
     2 |           0
     3 |           3
(3 rows)

-- select json_remove with group by index (result)
--Testcase 4015:
SELECT id,  json_length(json_remove(c1, '$[1]')) FROM s8 group by 2, 1;
 id | json_length 
----+-------------
  0 |           2
  1 |           0
  2 |           0
  3 |           3
  4 |           3
  5 |           3
(6 rows)

-- select json_remove with group by index (result)
--Testcase 4016:
SELECT id,  json_length(json_remove(c1, '$[1]')) FROM s8 group by 1, 2;
 id | json_length 
----+-------------
  0 |           2
  1 |           0
  2 |           0
  3 |           3
  4 |           3
  5 |           3
(6 rows)

-- select json_remove with group by having (EXPLAIN)
--Testcase 4017:
EXPLAIN VERBOSE
SELECT count(c2), json_length(json_remove(c1, '$[1]')) FROM s8 group by json_length(json_remove(c1, '$[1]')) HAVING count(c2) > 0;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_length(json_remove(c1, VARIADIC '{$[1]}'::text[])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_length(json_remove(`c1`, '$[1]')) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_remove with group by having (result)
--Testcase 4018:
SELECT count(c2), json_length(json_remove(c1, '$[1]')) FROM s8 group by json_length(json_remove(c1, '$[1]')) HAVING count(c2) > 0;
 count | json_length 
-------+-------------
     1 |           2
     2 |           0
     3 |           3
(3 rows)

-- select json_remove with group by index having (result)
--Testcase 4019:
SELECT c2,  json_length(json_remove(c1, '$[1]')) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           2
  2 |           0
  3 |           0
  4 |           3
  5 |           3
(5 rows)

-- select json_remove with group by index having (result)
--Testcase 4020:
SELECT c2,  json_length(json_remove(c1, '$[1]')) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_length 
----+-------------
  1 |           2
  2 |           0
  3 |           0
  4 |           3
  5 |           3
(5 rows)

-- select json_remove and as
--Testcase 4021:
SELECT json_remove(json_build_array(c1, '1'), '$[1]', '$[2]') as json_remove1 FROM s8;
ERROR:  stub json_remove(json, variadic text[]) is called
CONTEXT:  PL/pgSQL function json_remove(json,text[]) line 3 at RAISE
-- select json_replace (stub function, explain)
--Testcase 4022:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_replace (stub function, result)
--Testcase 4023:
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_replace (stub function, not pushdown constraints, explain)
--Testcase 4024:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, pi()') FROM s8 WHERE to_hex(id) = '1';
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.09 rows=7 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', NULL","''$'', TRUE","''$'', pi()"}'::path_value[])
   Filter: (to_hex(s8.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_replace (stub function, not pushdown constraints, result)
--Testcase 4025:
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, pi()') FROM s8 WHERE to_hex(id) = '1';
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_replace (stub function, pushdown constraints, explain)
--Testcase 4026:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.43 rows=7 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', CAST(\"[true, false]\" AS JSON)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 1))
(4 rows)

-- select json_replace (stub function, pushdown constraints, result)
--Testcase 4027:
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_replace (stub function, stub in constraints, explain)
--Testcase 4028:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, "[true, false]"') FROM s8 WHERE log2(id) > 1;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', NULL","''$'', TRUE","''$'', ''[true, false]''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((log2(`id`) > 1))
(4 rows)

-- select json_replace (stub function, stub in constraints, result)
--Testcase 4029:
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, "[true, false]"') FROM s8 WHERE log2(id) > 1;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_replace (stub function, stub in constraints, explain)
--Testcase 4030:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8 WHERE json_depth(json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()')) > 0;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_depth(json_replace(`c1`, '$.a', c2, '$.b', c3, '$.c', 1, '$', 'a', '$', pi())) > 0))
(4 rows)

-- select json_replace (stub function, stub in constraints, result)
--Testcase 4031:
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8 WHERE json_depth(json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()')) > 0;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- json_replace with 1 arg explain
--Testcase 4032:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2') FROM s8;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_replace with 1 arg result
--Testcase 4033:
SELECT json_replace(c1, '$.a, c2') FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- json_replace with 2 args explain
--Testcase 4034:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3') FROM s8;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_replace with 2 args result
--Testcase 4035:
SELECT json_replace(c1, '$.a, c2', '$.b, c3') FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- json_replace with 3 args explain
--Testcase 4036:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1') FROM s8;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_replace with 3 args result
--Testcase 4037:
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1') FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- json_replace with 4 args explain
--Testcase 4038:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"') FROM s8;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_replace with 4 args result
--Testcase 4039:
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"') FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- json_replace with 5 args explain
--Testcase 4040:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_replace with 5 args result
--Testcase 4041:
SELECT json_replace(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_replace as nest function with agg (pushdown, explain)
--Testcase 4042:
EXPLAIN VERBOSE
SELECT sum(id),json_replace('["a", ["b", "c"], "d"]', '$, sum(id)') FROM s8;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_replace('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', sum(id)"}'::path_value[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_replace(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', sum(id)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_replace as nest function with agg (pushdown, result)
--Testcase 4043:
SELECT sum(id),json_replace('["a", ["b", "c"], "d"]', '$, sum(id)') FROM s8;
 sum | json_replace 
-----+--------------
  15 | 15
(1 row)

-- select json_replace as nest function with json_build_array (pushdown, explain)
--Testcase 4044:
EXPLAIN VERBOSE
SELECT json_replace(json_build_array('["a", ["b", "c"], "d"]', c1), '$, log2(id)') FROM s8;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=32)
   Output: json_replace(json_build_array('["a", ["b", "c"], "d"]', c1), VARIADIC '{"''$'', log2(id)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_replace as nest function with agg (pushdown, result)
--Testcase 4045:
SELECT json_replace(json_build_array('["a", ["b", "c"], "d"]', c1), '$, log2(id)') FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_replace with non pushdown func and explicit constant (explain)
--Testcase 4046:
EXPLAIN VERBOSE
SELECT json_replace(c1, '$.a, c2'), pi(), 4.1 FROM s8;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=72)
   Output: json_replace(c1, VARIADIC '{"''$.a'', c2"}'::path_value[]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_replace with non pushdown func and explicit constant (result)
--Testcase 4047:
SELECT json_replace(c1, '$.a, c2'), pi(), 4.1 FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_replace with order by (explain)
--Testcase 4048:
EXPLAIN VERBOSE
SELECT json_length(json_replace(c1, '$.a, c2')) FROM s8 ORDER BY 1;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.15 rows=30 width=4)
   Output: json_length(json_replace(c1, VARIADIC '{"''$.a'', c2"}'::path_value[]))
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` ORDER BY json_length(json_replace(`c1`, '$.a', c2)) IS NULL ASC, json_length(json_replace(`c1`, '$.a', c2)) ASC
(4 rows)

-- select json_replace with order by (result)
--Testcase 4049:
SELECT json_length(json_replace(c1, '$.a, c2')) FROM s8 ORDER BY 1;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_replace with group by (explain)
--Testcase 4050:
EXPLAIN VERBOSE
SELECT json_length(json_replace('["a", ["b", "c"], "d"]', '$, id')) FROM s8 GROUP BY 1;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=3413 width=4)
   Output: (json_length(json_replace('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', id"}'::path_value[])))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_length(json_replace(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', id)) FROM `mysql_fdw_regress`.`s8` GROUP BY 1
(5 rows)

-- select json_replace with group by (result)
--Testcase 4051:
SELECT json_length(json_replace('["a", ["b", "c"], "d"]', '$, id')) FROM s8 GROUP BY 1;
 json_length 
-------------
           1
(1 row)

-- select json_replace with group by having (explain)
--Testcase 4052:
EXPLAIN VERBOSE
SELECT json_depth(json_replace('["a", ["b", "c"], "d"]', '$, c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=975 width=8)
   Output: (json_depth(json_replace('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', c2"}'::path_value[]))), c2
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_depth(json_replace(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', c2)), `c2` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1 HAVING ((count(`c2`) > 1))
(5 rows)

-- select json_replace with group by having (result)
--Testcase 4053:
SELECT json_depth(json_replace('["a", ["b", "c"], "d"]', '$, c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
 json_depth 
------------
          1
(1 row)

-- select json_replace and as
--Testcase 4054:
SELECT json_replace(c1, '$.a, c2') AS json_replace1 FROM s8;
ERROR:  stub json_replace(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_replace(json,path_value[]) line 3 at RAISE
-- select json_schema_valid (builtin function, explain)
--Testcase 4055:
EXPLAIN VERBOSE
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9;
                                                                                                                                                         QUERY PLAN                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..175.79 rows=1462 width=20)
   Output: json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null'::text)), json_schema_valid(c1, '{}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9`
(4 rows)

-- select json_schema_valid (builtin function, result)
--Testcase 4056:
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9;
ERROR:  stub json_schema_valid(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_valid(json,json) line 3 at RAISE
-- select json_schema_valid (builtin function, not pushdown constraints, explain)
--Testcase 4057:
EXPLAIN VERBOSE
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE to_hex(id) = '1';
                                                                                                                                                         QUERY PLAN                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..132.17 rows=7 width=20)
   Output: json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null'::text)), json_schema_valid(c1, '{}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json)
   Filter: (to_hex(s9.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s9`
(5 rows)

-- select json_schema_valid (builtin function, not pushdown constraints, result)
--Testcase 4058:
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE to_hex(id) = '1';
ERROR:  stub json_schema_valid(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_valid(json,json) line 3 at RAISE
-- select json_schema_valid (builtin function, pushdown constraints, explain)
--Testcase 4059:
EXPLAIN VERBOSE
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE id != 0;
                                                                                                                                                         QUERY PLAN                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..179.20 rows=1455 width=20)
   Output: json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null'::text)), json_schema_valid(c1, '{}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9` WHERE ((`id` <> 0))
(4 rows)

-- select json_schema_valid (builtin function, pushdown constraints, result)
--Testcase 4060:
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE id != 0;
ERROR:  stub json_schema_valid(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_valid(json,json) line 3 at RAISE
-- select json_schema_valid (builtin function, json_schema_valid in constraints, explain)
--Testcase 4061:
EXPLAIN VERBOSE
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) != 0;
                                                                                                                                                         QUERY PLAN                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..182.86 rows=1455 width=20)
   Output: json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null'::text)), json_schema_valid(c1, '{}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9` WHERE ((json_schema_valid(`c1`, CAST('{"latitude": 63.444697,"longitude": 10.445118}' AS JSON)) <> 0))
(4 rows)

-- select json_schema_valid (builtin function, json_schema_valid in constraints, result)
--Testcase 4062:
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) != 0;
ERROR:  stub json_schema_valid(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_valid(json,json) line 3 at RAISE
-- select json_schema_valid (builtin function, json_schema_valid in constraints, explain)
--Testcase 4063:
EXPLAIN VERBOSE
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) = 1;
                                                                                                                                                         QUERY PLAN                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..132.17 rows=7 width=20)
   Output: json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null'::text)), json_schema_valid(c1, '{}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9` WHERE ((json_schema_valid(`c1`, CAST('{"latitude": 63.444697,"longitude": 30}' AS JSON)) = 1))
(4 rows)

-- select json_schema_valid (builtin function, json_schema_valid in constraints, result)
--Testcase 4064:
SELECT json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 9}'::json), json_schema_valid(c1, json_quote('null')), json_schema_valid(c1, '{}'), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 30}'::json) = 1;
ERROR:  stub json_schema_valid(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_valid(json,json) line 3 at RAISE
-- select json_schema_valid as nest function with agg (pushdown, explain)
--Testcase 4065:
EXPLAIN VERBOSE
SELECT sum(id),json_schema_valid(json_build_object('latitude', sum(id), 'longitude', avg(id)), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (sum(id)), (json_schema_valid(json_build_object('latitude', sum(id), 'longitude', avg(id)), '{"latitude": 63.444697,"longitude": 30}'::json))
   Relations: Aggregate on (mysql_fdw_regress.s9)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_schema_valid(json_object('latitude', sum(`id`), 'longitude', avg(`id`)), CAST('{"latitude": 63.444697,"longitude": 30}' AS JSON)) FROM `mysql_fdw_regress`.`s9`
(5 rows)

-- select json_schema_valid as nest function with agg (pushdown, result)
--Testcase 4066:
SELECT sum(id),json_schema_valid(json_build_object('latitude', sum(id), 'longitude', avg(id)), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9;
 sum | json_schema_valid 
-----+-------------------
   1 |                 1
(1 row)

-- select json_schema_valid with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4067:
EXPLAIN VERBOSE
SELECT json_schema_valid(c1, json_quote('null')), pi(), 4.1 FROM s9;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..161.17 rows=1462 width=44)
   Output: json_schema_valid(c1, json_quote('null'::text)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9`
(4 rows)

-- select json_schema_valid with non pushdown func and explicit constant (result)
--Testcase 4068:
SELECT json_schema_valid(c1, json_quote('null')), pi(), 4.1 FROM s9;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_schema_valid with order by index (result)
--Testcase 4069:
SELECT id,  json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 order by 2, 1;
ERROR:  stub json_schema_valid(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_valid(json,json) line 3 at RAISE
-- select json_schema_valid with order by index (result)
--Testcase 4070:
SELECT id,  json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 order by 1, 2;
ERROR:  stub json_schema_valid(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_valid(json,json) line 3 at RAISE
-- select json_schema_valid with group by (EXPLAIN)
--Testcase 4071:
EXPLAIN VERBOSE
SELECT count(id), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 group by json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json);
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json))
   Relations: Aggregate on (mysql_fdw_regress.s9)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_schema_valid(`c1`, CAST('{"latitude": 63.444697,"longitude": 10.445118}' AS JSON)) FROM `mysql_fdw_regress`.`s9` GROUP BY 2
(5 rows)

-- select json_schema_valid with group by (result)
--Testcase 4072:
SELECT count(id), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 group by json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json);
 count | json_schema_valid 
-------+-------------------
     1 |                 1
     1 |                 0
(2 rows)

-- select json_schema_valid with group by index (result)
--Testcase 4073:
SELECT id,  json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 group by 2, 1;
 id | json_schema_valid 
----+-------------------
  0 |                 1
  1 |                 0
(2 rows)

-- select json_schema_valid with group by index (result)
--Testcase 4074:
SELECT id,  json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 group by 1, 2;
 id | json_schema_valid 
----+-------------------
  0 |                 1
  1 |                 0
(2 rows)

-- select json_schema_valid with group by having (EXPLAIN)
--Testcase 4075:
EXPLAIN VERBOSE
SELECT count(id), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 group by json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) HAVING count(id) > 0;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(id)), (json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json))
   Relations: Aggregate on (mysql_fdw_regress.s9)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_schema_valid(`c1`, CAST('{"latitude": 63.444697,"longitude": 10.445118}' AS JSON)) FROM `mysql_fdw_regress`.`s9` GROUP BY 2 HAVING ((count(`id`) > 0))
(5 rows)

-- select json_schema_valid with group by having (result)
--Testcase 4076:
SELECT count(id), json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 group by json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) HAVING count(id) > 0;
 count | json_schema_valid 
-------+-------------------
     1 |                 1
     1 |                 0
(2 rows)

-- select json_schema_valid with group by index having (result)
--Testcase 4077:
SELECT id,  json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 group by 2, 1 HAVING count(id) > 0;
 id | json_schema_valid 
----+-------------------
  0 |                 1
  1 |                 0
(2 rows)

-- select json_schema_valid with group by index having (result)
--Testcase 4078:
SELECT id,  json_schema_valid(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json) FROM s9 group by 1, 2 HAVING count(id) > 0;
 id | json_schema_valid 
----+-------------------
  0 |                 1
  1 |                 0
(2 rows)

-- select json_schema_valid and as
--Testcase 4079:
SELECT json_schema_valid(c1, json_quote('null')) as json_schema_valid1 FROM s9;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_schema_validation_report (builtin function, explain)
--Testcase 4080:
EXPLAIN VERBOSE
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9;
                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..179.45 rows=1462 width=160)
   Output: json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'::json), json_schema_validation_report(c1, json_quote('null'::text)), json_schema_validation_report(c1, '{}'::json), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9`
(4 rows)

-- select json_schema_validation_report (builtin function, result)
--Testcase 4081:
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9;
ERROR:  stub json_schema_validation_report(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_validation_report(json,json) line 3 at RAISE
-- select json_schema_validation_report (builtin function, not pushdown constraints, explain)
--Testcase 4082:
EXPLAIN VERBOSE
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE to_hex(id) = '1';
                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..132.19 rows=7 width=160)
   Output: json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'::json), json_schema_validation_report(c1, json_quote('null'::text)), json_schema_validation_report(c1, '{}'::json), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json)
   Filter: (to_hex(s9.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s9`
(5 rows)

-- select json_schema_validation_report (builtin function, not pushdown constraints, result)
--Testcase 4083:
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE to_hex(id) = '1';
ERROR:  stub json_schema_validation_report(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_validation_report(json,json) line 3 at RAISE
-- select json_schema_validation_report (builtin function, pushdown constraints, explain)
--Testcase 4084:
EXPLAIN VERBOSE
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE id != 0;
                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..182.84 rows=1455 width=160)
   Output: json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'::json), json_schema_validation_report(c1, json_quote('null'::text)), json_schema_validation_report(c1, '{}'::json), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9` WHERE ((`id` <> 0))
(4 rows)

-- select json_schema_validation_report (builtin function, pushdown constraints, result)
--Testcase 4085:
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE id != 0;
ERROR:  stub json_schema_validation_report(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_validation_report(json,json) line 3 at RAISE
-- select json_schema_validation_report (builtin function, json_schema_validation_report in constraints, explain)
--Testcase 4086:
EXPLAIN VERBOSE
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) != 0;
                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..190.15 rows=1455 width=160)
   Output: json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'::json), json_schema_validation_report(c1, json_quote('null'::text)), json_schema_validation_report(c1, '{}'::json), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9` WHERE ((json_length(json_schema_validation_report(`c1`, CAST('{"latitude": 63.444697,"longitude": 10.445118}' AS JSON))) <> 0))
(4 rows)

-- select json_schema_validation_report (builtin function, json_schema_validation_report in constraints, result)
--Testcase 4087:
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) != 0;
ERROR:  stub json_schema_validation_report(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_validation_report(json,json) line 3 at RAISE
-- select json_schema_validation_report (builtin function, json_schema_validation_report in constraints, explain)
--Testcase 4088:
EXPLAIN VERBOSE
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE json_length(json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json)) = 1;
                                                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..139.50 rows=7 width=160)
   Output: json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'::json), json_schema_validation_report(c1, json_quote('null'::text)), json_schema_validation_report(c1, '{}'::json), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9` WHERE ((json_length(json_schema_validation_report(json_object('latitude', 63, 'longitude', 30), CAST('{"latitude": 63.444697,"longitude": 30}' AS JSON))) = 1))
(4 rows)

-- select json_schema_validation_report (builtin function, json_schema_validation_report in constraints, result)
--Testcase 4089:
SELECT json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'), json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.5}'), json_schema_validation_report(c1, json_quote('null')), json_schema_validation_report(c1, '{}'), json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9 WHERE json_length(json_schema_validation_report(json_build_object('latitude', 63, 'longitude', 30), '{"latitude": 63.444697,"longitude": 30}'::json)) = 1;
ERROR:  stub json_schema_validation_report(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_validation_report(json,json) line 3 at RAISE
-- select json_schema_validation_report as nest function with agg (pushdown, explain)
--Testcase 4090:
EXPLAIN VERBOSE
SELECT sum(id),json_schema_validation_report(json_build_object('latitude', 63, 'longitude', sum(id)), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9;
                                                                                                 QUERY PLAN                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_schema_validation_report(json_build_object('latitude', 63, 'longitude', sum(id)), '{"latitude": 63.444697,"longitude": 30}'::json))
   Relations: Aggregate on (mysql_fdw_regress.s9)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_schema_validation_report(json_object('latitude', 63, 'longitude', sum(`id`)), CAST('{"latitude": 63.444697,"longitude": 30}' AS JSON)) FROM `mysql_fdw_regress`.`s9`
(5 rows)

-- select json_schema_validation_report as nest function with agg (pushdown, result)
--Testcase 4091:
SELECT sum(id),json_schema_validation_report(json_build_object('latitude', 63, 'longitude', sum(id)), '{"latitude": 63.444697,"longitude": 30}'::json) FROM s9;
 sum | json_schema_validation_report 
-----+-------------------------------
   1 | {"valid": true}
(1 row)

-- select json_schema_validation_report with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4092:
EXPLAIN VERBOSE
SELECT json_schema_validation_report(c1, json_quote('null')), pi(), 4.1 FROM s9;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..161.17 rows=1462 width=72)
   Output: json_schema_validation_report(c1, json_quote('null'::text)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9`
(4 rows)

-- select json_schema_validation_report with non pushdown func and explicit constant (result)
--Testcase 4093:
SELECT json_schema_validation_report(c1, json_quote('null')), pi(), 4.1 FROM s9;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_schema_validation_report with order by index (result)
--Testcase 4094:
SELECT id,  json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 order by 2, 1;
ERROR:  stub json_schema_validation_report(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_validation_report(json,json) line 3 at RAISE
-- select json_schema_validation_report with order by index (result)
--Testcase 4095:
SELECT id,  json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 order by 1, 2;
ERROR:  stub json_schema_validation_report(json, json) is called
CONTEXT:  PL/pgSQL function json_schema_validation_report(json,json) line 3 at RAISE
-- select json_schema_validation_report with group by (EXPLAIN)
--Testcase 4096:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 group by json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'));
                                                                                          QUERY PLAN                                                                                           
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json)))
   Relations: Aggregate on (mysql_fdw_regress.s9)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_schema_validation_report(`c1`, CAST('{"latitude": 63.444697,"longitude": 10.445118}' AS JSON))) FROM `mysql_fdw_regress`.`s9` GROUP BY 2
(5 rows)

-- select json_schema_validation_report with group by (result)
--Testcase 4097:
SELECT count(id), json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 group by json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'));
 count | json_length 
-------+-------------
     1 |           1
     1 |           5
(2 rows)

-- select json_schema_validation_report with group by index (result)
--Testcase 4098:
SELECT id,  json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 group by 2, 1;
 id | json_length 
----+-------------
  0 |           1
  1 |           5
(2 rows)

-- select json_schema_validation_report with group by index (result)
--Testcase 4099:
SELECT id,  json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 group by 1, 2;
 id | json_length 
----+-------------
  0 |           1
  1 |           5
(2 rows)

-- select json_schema_validation_report with group by having (EXPLAIN)
--Testcase 4100:
EXPLAIN VERBOSE
SELECT count(id), json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 group by json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) HAVING count(id) > 0;
                                                                                                        QUERY PLAN                                                                                                        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(id)), (json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}'::json)))
   Relations: Aggregate on (mysql_fdw_regress.s9)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_length(json_schema_validation_report(`c1`, CAST('{"latitude": 63.444697,"longitude": 10.445118}' AS JSON))) FROM `mysql_fdw_regress`.`s9` GROUP BY 2 HAVING ((count(`id`) > 0))
(5 rows)

-- select json_schema_validation_report with group by having (result)
--Testcase 4101:
SELECT count(id), json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 group by json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) HAVING count(id) > 0;
 count | json_length 
-------+-------------
     1 |           1
     1 |           5
(2 rows)

-- select json_schema_validation_report with group by index having (result)
--Testcase 4102:
SELECT id,  json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 group by 2, 1 HAVING count(id) > 0;
 id | json_length 
----+-------------
  0 |           1
  1 |           5
(2 rows)

-- select json_schema_validation_report with group by index having (result)
--Testcase 4103:
SELECT id,  json_length(json_schema_validation_report(c1, '{"latitude": 63.444697,"longitude": 10.445118}')) FROM s9 group by 1, 2 HAVING count(id) > 0;
 id | json_length 
----+-------------
  0 |           1
  1 |           5
(2 rows)

-- select json_schema_validation_report and as
--Testcase 4104:
SELECT json_schema_validation_report(c1, json_quote('null')) as json_schema_validation_report1 FROM s9;
ERROR:  stub json_quote(text) is called
CONTEXT:  PL/pgSQL function json_quote(text) line 3 at RAISE
-- select json_search (builtin function, explain)
--Testcase 4105:
EXPLAIN VERBOSE
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8;
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.79 rows=1462 width=160)
   Output: json_search(c1, 'one'::text, 'abc'::text), json_search(json_build_array(c1, '1'), 'all'::text, 'abc'::text), json_search(c1, 'one'::text, '%a%'::text), json_search('{"a":1,"b":10,"d":10}'::json, 'all'::text, '%1%'::text), json_search('[1,3,5,7]'::json, 'one'::text, '[2,5,7]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_search (builtin function, result)
--Testcase 4106:
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8;
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- select json_search (builtin function, not pushdown constraints, explain)
--Testcase 4107:
EXPLAIN VERBOSE
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8 WHERE to_hex(id) = '2';
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.17 rows=7 width=160)
   Output: json_search(c1, 'one'::text, 'abc'::text), json_search(json_build_array(c1, '1'), 'all'::text, 'abc'::text), json_search(c1, 'one'::text, '%a%'::text), json_search('{"a":1,"b":10,"d":10}'::json, 'all'::text, '%1%'::text), json_search('[1,3,5,7]'::json, 'one'::text, '[2,5,7]'::text)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_search (builtin function, not pushdown constraints, result)
--Testcase 4108:
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- select json_search (builtin function, pushdown constraints, explain)
--Testcase 4109:
EXPLAIN VERBOSE
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8 WHERE id != 0;
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..179.20 rows=1455 width=160)
   Output: json_search(c1, 'one'::text, 'abc'::text), json_search(json_build_array(c1, '1'), 'all'::text, 'abc'::text), json_search(c1, 'one'::text, '%a%'::text), json_search('{"a":1,"b":10,"d":10}'::json, 'all'::text, '%1%'::text), json_search('[1,3,5,7]'::json, 'one'::text, '[2,5,7]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_search (builtin function, pushdown constraints, result)
--Testcase 4110:
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8 WHERE id != 0;
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- select json_search (builtin function, json_search in constraints, explain)
--Testcase 4111:
EXPLAIN VERBOSE
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8 WHERE json_search(c1, 'one', 'abc') NOT LIKE '$';
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..182.86 rows=1455 width=160)
   Output: json_search(c1, 'one'::text, 'abc'::text), json_search(json_build_array(c1, '1'), 'all'::text, 'abc'::text), json_search(c1, 'one'::text, '%a%'::text), json_search('{"a":1,"b":10,"d":10}'::json, 'all'::text, '%1%'::text), json_search('[1,3,5,7]'::json, 'one'::text, '[2,5,7]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_search(`c1`, 'one', 'abc') NOT LIKE BINARY '$'))
(4 rows)

-- select json_search (builtin function, json_search in constraints, result)
--Testcase 4112:
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8 WHERE json_search(c1, 'one', 'abc') NOT LIKE '$';
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- select json_search (builtin function, json_search in constraints, explain)
--Testcase 4113:
EXPLAIN VERBOSE
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8 where json_search('[1,3,5,7]', 'one', '[2,5,7]') IS NULL;
                                                                                                                                              QUERY PLAN                                                                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.52 rows=7 width=160)
   Output: json_search(c1, 'one'::text, 'abc'::text), json_search(json_build_array(c1, '1'), 'all'::text, 'abc'::text), json_search(c1, 'one'::text, '%a%'::text), json_search('{"a":1,"b":10,"d":10}'::json, 'all'::text, '%1%'::text), json_search('[1,3,5,7]'::json, 'one'::text, '[2,5,7]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_search(CAST('[1,3,5,7]' AS JSON), 'one', '[2,5,7]') IS NULL))
(4 rows)

-- select json_search (builtin function, json_search in constraints, result)
--Testcase 4114:
SELECT json_search(c1, 'one', 'abc'), json_search(json_build_array(c1, '1'), 'all', 'abc'), json_search(c1, 'one', '%a%'),json_search('{"a":1,"b":10,"d":10}', 'all', '%1%'),json_search('[1,3,5,7]', 'one', '[2,5,7]') FROM s8 where json_search('[1,3,5,7]', 'one', '[2,5,7]') IS NULL;
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- select json_search as nest function with agg (pushdown, explain)
--Testcase 4115:
EXPLAIN VERBOSE
SELECT sum(id),json_search(json_build_array('{"a":1,"b":10,"d":10}', sum(id)), 'all', 'a') FROM s8;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_search(json_build_array('{"a":1,"b":10,"d":10}', sum(id)), 'all'::text, 'a'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_search(json_array('{"a":1,"b":10,"d":10}', sum(`id`)), 'all', 'a') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_search as nest function with agg (pushdown, result)
--Testcase 4116:
SELECT sum(id),json_search(json_build_array('{"a":1,"b":10,"d":10}', sum(id)), 'all', 'a') FROM s8;
 sum | json_search 
-----+-------------
  15 | 
(1 row)

-- select json_search with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4117:
EXPLAIN VERBOSE
SELECT json_search(c1, 'one', '%a%'), pi(), 4.1 FROM s8;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=72)
   Output: json_search(c1, 'one'::text, '%a%'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_search with non pushdown func and explicit constant (result)
--Testcase 4118:
SELECT json_search(c1, 'one', '%a%'), pi(), 4.1 FROM s8;
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- select json_search with order by index (result)
--Testcase 4119:
SELECT id, json_search(c1, 'one', 'abc') FROM s8 ORDER BY 2, 1;
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- select json_search with order by index (result)
--Testcase 4120:
SELECT id, json_search(c1, 'one', 'abc') FROM s8 ORDER BY 1, 2;
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- select json_search with group by (EXPLAIN)
--Testcase 4121:
EXPLAIN VERBOSE
SELECT count(id), json_search(c1, 'one', 'abc') FROM s8 group by json_search(c1, 'one', 'abc');
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(id)), (json_search(c1, 'one'::text, 'abc'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_search(`c1`, 'one', 'abc') FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_search with group by (result)
--Testcase 4122:
SELECT count(id), json_search(c1, 'one', 'abc') FROM s8 group by json_search(c1, 'one', 'abc');
 count | json_search 
-------+-------------
     5 | 
     1 | "$[0]"
(2 rows)

-- select json_search with group by index (result)
--Testcase 4123:
SELECT id, json_search(c1, 'one', 'abc') FROM s8 group by 2, 1;
 id | json_search 
----+-------------
  0 | 
  1 | 
  2 | 
  3 | 
  4 | 
  5 | "$[0]"
(6 rows)

-- select json_search with group by index (result)
--Testcase 4124:
SELECT id, json_search(c1, 'one', 'abc') FROM s8 group by 1, 2;
 id | json_search 
----+-------------
  0 | 
  1 | 
  2 | 
  3 | 
  4 | 
  5 | "$[0]"
(6 rows)

-- select json_search with group by having (EXPLAIN)
--Testcase 4125:
EXPLAIN VERBOSE
SELECT count(c2), json_search(c1, 'one', 'abc') FROM s8 group by json_search(c1, 'one', 'abc') HAVING count(c2) > 0;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=40)
   Output: (count(c2)), (json_search(c1, 'one'::text, 'abc'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_search(`c1`, 'one', 'abc') FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_search with group by having (result)
--Testcase 4126:
SELECT count(c2), json_search(c1, 'one', 'abc') FROM s8 group by json_search(c1, 'one', 'abc') HAVING count(c2) > 0;
 count | json_search 
-------+-------------
     5 | 
     1 | "$[0]"
(2 rows)

-- select json_search with group by index having (result)
--Testcase 4127:
SELECT c2, json_search(c1, 'one', 'abc') FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_search 
----+-------------
  1 | 
  2 | 
  3 | 
  4 | 
  5 | 
  5 | "$[0]"
(6 rows)

-- select json_search with group by index having (result)
--Testcase 4128:
SELECT c2, json_search(c1, 'one', 'abc') FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_search 
----+-------------
  1 | 
  2 | 
  3 | 
  4 | 
  5 | 
  5 | "$[0]"
(6 rows)

-- select json_search and as
--Testcase 4129:
SELECT json_search(c1, 'one', '%a%') as json_search1 FROM s8;
ERROR:  stub json_search(json, text, text) is called
CONTEXT:  PL/pgSQL function json_search(json,text,text) line 3 at RAISE
-- JSON_SET()
-- select json_set (stub function, explain)
--Testcase 4130:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_set (stub function, result)
--Testcase 4131:
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- select json_set (stub function, not pushdown constraints, explain)
--Testcase 4132:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, pi()') FROM s8 WHERE to_hex(id) = '1';
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.09 rows=7 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', NULL","''$'', TRUE","''$'', pi()"}'::path_value[])
   Filter: (to_hex(s8.id) = '1'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_set (stub function, not pushdown constraints, result)
--Testcase 4133:
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, pi()') FROM s8 WHERE to_hex(id) = '1';
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- select json_set (stub function, pushdown constraints, explain)
--Testcase 4134:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.43 rows=7 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', CAST(\"[true, false]\" AS JSON)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 1))
(4 rows)

-- select json_set (stub function, pushdown constraints, result)
--Testcase 4135:
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, CAST("[true, false]" AS JSON)') FROM s8 WHERE id = 1;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- select json_set (stub function, stub in constraints, explain)
--Testcase 4136:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, "[true, false]"') FROM s8 WHERE log2(id) > 1;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', NULL","''$'', TRUE","''$'', ''[true, false]''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((log2(`id`) > 1))
(4 rows)

-- select json_set (stub function, stub in constraints, result)
--Testcase 4137:
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, NULL', '$, TRUE', '$, "[true, false]"') FROM s8 WHERE log2(id) > 1;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- select json_set (stub function, stub in constraints, explain)
--Testcase 4138:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8 WHERE json_depth(json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()')) > 0;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..146.54 rows=487 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_depth(json_set(`c1`, '$.a', c2, '$.b', c3, '$.c', 1, '$', 'a', '$', pi())) > 0))
(4 rows)

-- select json_set (stub function, stub in constraints, result)
--Testcase 4139:
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8 WHERE json_depth(json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()')) > 0;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- json_set with 1 arg explain
--Testcase 4140:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2') FROM s8;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_set with 1 arg result
--Testcase 4141:
SELECT json_set(c1, '$.a, c2') FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- json_set with 2 args explain
--Testcase 4142:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3') FROM s8;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_set with 2 args result
--Testcase 4143:
SELECT json_set(c1, '$.a, c2', '$.b, c3') FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- json_set with 3 args explain
--Testcase 4144:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1') FROM s8;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_set with 3 args result
--Testcase 4145:
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1') FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- json_set with 4 args explain
--Testcase 4146:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"') FROM s8;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_set with 4 args result
--Testcase 4147:
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"') FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- json_set with 5 args explain
--Testcase 4148:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=32)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2","''$.b'', c3","''$.c'', 1","''$'', ''a''","''$'', pi()"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- json_set with 5 args result
--Testcase 4149:
SELECT json_set(c1, '$.a, c2', '$.b, c3', '$.c, 1', '$, "a"', '$, pi()') FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- select json_set as nest function with agg (pushdown, explain)
--Testcase 4150:
EXPLAIN VERBOSE
SELECT sum(id),json_set('["a", ["b", "c"], "d"]', '$, sum(id)') FROM s8;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_set('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', sum(id)"}'::path_value[]))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_set(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', sum(id)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_set as nest function with agg (pushdown, result)
--Testcase 4151:
SELECT sum(id),json_set('["a", ["b", "c"], "d"]', '$, sum(id)') FROM s8;
 sum | json_set 
-----+----------
  15 | 15
(1 row)

-- select json_set as nest function with json_build_array (pushdown, explain)
--Testcase 4152:
EXPLAIN VERBOSE
SELECT json_set(json_build_array('["a", ["b", "c"], "d"]', c1), '$, log2(id)') FROM s8;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=32)
   Output: json_set(json_build_array('["a", ["b", "c"], "d"]', c1), VARIADIC '{"''$'', log2(id)"}'::path_value[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_set as nest function with agg (pushdown, result)
--Testcase 4153:
SELECT json_set(json_build_array('["a", ["b", "c"], "d"]', c1), '$, log2(id)') FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- select json_set with non pushdown func and explicit constant (explain)
--Testcase 4154:
EXPLAIN VERBOSE
SELECT json_set(c1, '$.a, c2'), pi(), 4.1 FROM s8;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=72)
   Output: json_set(c1, VARIADIC '{"''$.a'', c2"}'::path_value[]), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_set with non pushdown func and explicit constant (result)
--Testcase 4155:
SELECT json_set(c1, '$.a, c2'), pi(), 4.1 FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- select json_set with order by (explain)
--Testcase 4156:
EXPLAIN VERBOSE
SELECT json_length(json_set(c1, '$.a, c2')) FROM s8 ORDER BY 1;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.15 rows=30 width=4)
   Output: json_length(json_set(c1, VARIADIC '{"''$.a'', c2"}'::path_value[]))
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` ORDER BY json_length(json_set(`c1`, '$.a', c2)) IS NULL ASC, json_length(json_set(`c1`, '$.a', c2)) ASC
(4 rows)

-- select json_set with order by (result)
--Testcase 4157:
SELECT json_length(json_set(c1, '$.a, c2')) FROM s8 ORDER BY 1;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- select json_set with group by (explain)
--Testcase 4158:
EXPLAIN VERBOSE
SELECT json_length(json_set('["a", ["b", "c"], "d"]', '$, id')) FROM s8 GROUP BY id, 1;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=2925 width=8)
   Output: (json_length(json_set('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', id"}'::path_value[]))), id
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_length(json_set(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', id)), `id` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1
(5 rows)

-- select json_set with group by (result)
--Testcase 4159:
SELECT json_length(json_set('["a", ["b", "c"], "d"]', '$, id')) FROM s8 GROUP BY id, 1;
 json_length 
-------------
           1
           1
           1
           1
           1
           1
(6 rows)

-- select json_set with group by having (explain)
--Testcase 4160:
EXPLAIN VERBOSE
SELECT json_depth(json_set('["a", ["b", "c"], "d"]', '$, c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=975 width=8)
   Output: (json_depth(json_set('["a", ["b", "c"], "d"]'::json, VARIADIC '{"''$'', c2"}'::path_value[]))), c2
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT json_depth(json_set(CAST('["a", ["b", "c"], "d"]' AS JSON), '$', c2)), `c2` FROM `mysql_fdw_regress`.`s8` GROUP BY 2, 1 HAVING ((count(`c2`) > 1))
(5 rows)

-- select json_set with group by having (result)
--Testcase 4161:
SELECT json_depth(json_set('["a", ["b", "c"], "d"]', '$, c2')) FROM s8 GROUP BY c2, 1 HAVING count(c2) > 1;
 json_depth 
------------
          1
(1 row)

-- select json_set and as
--Testcase 4162:
SELECT json_set(c1, '$.a, c2') AS json_set1 FROM s8;
ERROR:  stub json_set(json, variadic path_value[]) is called
CONTEXT:  PL/pgSQL function json_set(json,path_value[]) line 3 at RAISE
-- json_storage_free()
-- insert new value for test json_storage_free()
--Testcase 4163:
INSERT INTO s8 VALUES (6, '{"a": 10, "b": "wxyz", "c": "[true, false]"}', 1, 'Text');
-- select json_storage_free (stub function, explain)
--Testcase 4164:
EXPLAIN VERBOSE
SELECT json_storage_free(c1), json_storage_free('{"a": 10, "b": "wxyz", "c": "[true, false]"}') FROM s8 WHERE id = 6;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.45 rows=7 width=8)
   Output: json_storage_free(c1), json_storage_free('{"a": 10, "b": "wxyz", "c": "[true, false]"}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 6))
(4 rows)

-- select json_storage_free (stub function, result)
--Testcase 4165:
SELECT json_storage_free(c1), json_storage_free('{"a": 10, "b": "wxyz", "c": "[true, false]"}') FROM s8 WHERE id = 6;
ERROR:  stub json_storage_free(json) is called
CONTEXT:  PL/pgSQL function json_storage_free(json) line 3 at RAISE
-- update new value for json value of table s8
--Testcase 4166:
UPDATE s8 SET c1 = json_set(c1, '$.a, 10', '$.b, "wx"') WHERE id = 6;
-- select json_storage_free (stub function, explain)
--Testcase 4167:
EXPLAIN VERBOSE
SELECT json_storage_free(c1), json_storage_free('{"a": 10, "b": "wxyz", "c": "[true, false]"}') FROM s8 WHERE id = 6;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..128.45 rows=7 width=8)
   Output: json_storage_free(c1), json_storage_free('{"a": 10, "b": "wxyz", "c": "[true, false]"}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` = 6))
(4 rows)

-- select json_storage_free (stub function, result)
--Testcase 4168:
SELECT json_storage_free(c1), json_storage_free('{"a": 10, "b": "wxyz", "c": "[true, false]"}') FROM s8 WHERE id = 6;
ERROR:  stub json_storage_free(json) is called
CONTEXT:  PL/pgSQL function json_storage_free(json) line 3 at RAISE
-- revert change
--Testcase 4169:
DELETE FROM s8 WHERE id = 6;
-- json_storage_size()
-- select json_storage_size (builtin function, explain)
--Testcase 4170:
EXPLAIN VERBOSE
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..164.60 rows=1365 width=12)
   Output: json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_storage_size (builtin function, result)
--Testcase 4171:
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8;
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size (builtin function, not pushdown constraints, explain)
--Testcase 4172:
EXPLAIN VERBOSE
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE to_hex(id) = '2';
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.68 rows=7 width=12)
   Output: json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}'::json)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_storage_size (builtin function, not pushdown constraints, result)
--Testcase 4173:
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size (builtin function, pushdown constraints, explain)
--Testcase 4174:
EXPLAIN VERBOSE
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE id != 0;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..167.80 rows=1358 width=12)
   Output: json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_storage_size (builtin function, pushdown constraints, result)
--Testcase 4175:
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE id != 0;
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size (builtin function, json_storage_size in constraints, explain)
--Testcase 4176:
EXPLAIN VERBOSE
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_storage_size(c1) != 1;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..171.22 rows=1358 width=12)
   Output: json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_storage_size(`c1`) <> 1))
(4 rows)

-- select json_storage_size (builtin function, json_storage_size in constraints, result)
--Testcase 4177:
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_storage_size(c1) != 1;
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size (builtin function, json_storage_size in constraints, explain)
--Testcase 4178:
EXPLAIN VERBOSE
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_storage_size('{"a": 1, "b": {"c": 30}}') = 33;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.68 rows=7 width=12)
   Output: json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_storage_size(CAST('{"a": 1, "b": {"c": 30}}' AS JSON)) = 33))
(4 rows)

-- select json_storage_size (builtin function, json_storage_size in constraints, result)
--Testcase 4179:
SELECT json_storage_size(c1), json_storage_size(json_build_array(c1, 'a', c2)), json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_storage_size('{"a": 1, "b": {"c": 30}}') = 33;
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size as nest function with agg (pushdown, explain)
--Testcase 4180:
EXPLAIN VERBOSE
SELECT sum(id),json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (sum(id)), (json_storage_size('{"a": 1, "b": {"c": 30}}'::json))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_storage_size(CAST('{"a": 1, "b": {"c": 30}}' AS JSON)) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_storage_size as nest function with agg (pushdown, result)
--Testcase 4181:
SELECT sum(id),json_storage_size('{"a": 1, "b": {"c": 30}}') FROM s8;
 sum | json_storage_size 
-----+-------------------
  15 |                33
(1 row)

-- select json_storage_size with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4182:
EXPLAIN VERBOSE
SELECT json_storage_size(json_build_array(c1, 'a', c2)), pi(), 4.1 FROM s8;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.78 rows=1365 width=44)
   Output: json_storage_size(json_build_array(c1, 'a', c2)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_storage_size with non pushdown func and explicit constant (result)
--Testcase 4183:
SELECT json_storage_size(json_build_array(c1, 'a', c2)), pi(), 4.1 FROM s8;
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size with order by (EXPLAIN)
--Testcase 4184:
EXPLAIN VERBOSE
SELECT id, json_storage_size(c1) FROM s8 ORDER BY json_storage_size(c1);
                                                                QUERY PLAN                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.07 rows=30 width=8)
   Output: id, json_storage_size(c1)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8` ORDER BY json_storage_size(`c1`) IS NULL ASC, json_storage_size(`c1`) ASC
(4 rows)

-- select json_storage_size with order by (result)
--Testcase 4185:
SELECT id, json_storage_size(c1) FROM s8 ORDER BY json_storage_size(c1);
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size with order by index (result)
--Testcase 4186:
SELECT id, json_storage_size(c1) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size with order by index (result)
--Testcase 4187:
SELECT id, json_storage_size(c1) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- select json_storage_size with group by (EXPLAIN)
--Testcase 4188:
EXPLAIN VERBOSE
SELECT count(id), json_storage_size(c1) FROM s8 group by json_storage_size(c1);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_storage_size(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_storage_size(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_storage_size with group by (result)
--Testcase 4189:
SELECT count(id), json_storage_size(c1) FROM s8 group by json_storage_size(c1);
 count | json_storage_size 
-------+-------------------
     1 |                34
     2 |                 5
     1 |                35
     1 |                41
     1 |                82
(5 rows)

-- select json_storage_size with group by index (result)
--Testcase 4190:
SELECT id, json_storage_size(c1) FROM s8 group by 2, 1;
 id | json_storage_size 
----+-------------------
  0 |                34
  1 |                 5
  2 |                 5
  3 |                35
  4 |                41
  5 |                82
(6 rows)

-- select json_storage_size with group by index (result)
--Testcase 4191:
SELECT id, json_storage_size(c1) FROM s8 group by 1, 2;
 id | json_storage_size 
----+-------------------
  0 |                34
  1 |                 5
  2 |                 5
  3 |                35
  4 |                41
  5 |                82
(6 rows)

-- select json_storage_size with group by having (EXPLAIN)
--Testcase 4192:
EXPLAIN VERBOSE
SELECT count(c2), json_storage_size(c1) FROM s8 group by json_storage_size(c1) HAVING count(c2) > 0;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_storage_size(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_storage_size(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_storage_size with group by having (result)
--Testcase 4193:
SELECT count(c2), json_storage_size(c1) FROM s8 group by json_storage_size(c1) HAVING count(c2) > 0;
 count | json_storage_size 
-------+-------------------
     1 |                34
     2 |                 5
     1 |                35
     1 |                41
     1 |                82
(5 rows)

-- select json_storage_size with group by index having (result)
--Testcase 4194:
SELECT c2, json_storage_size(c1) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_storage_size 
----+-------------------
  1 |                34
  2 |                 5
  3 |                 5
  4 |                35
  5 |                41
  5 |                82
(6 rows)

-- select json_storage_size with group by index having (result)
--Testcase 4195:
SELECT c2, json_storage_size(c1) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_storage_size 
----+-------------------
  1 |                34
  2 |                 5
  3 |                 5
  4 |                35
  5 |                41
  5 |                82
(6 rows)

-- select json_storage_size and as
--Testcase 4196:
SELECT json_storage_size(json_build_array(c1, 'a', c2)) as json_storage_size1 FROM s8;
ERROR:  stub json_storage_size(json) is called
CONTEXT:  PL/pgSQL function json_storage_size(json) line 3 at RAISE
-- mysql_json_table
-- select mysql_json_table (explain)
--Testcase 4197:
EXPLAIN VERBOSE
SELECT mysql_json_table(c1,'$',
       ARRAY['id VARCHAR(100) PATH "$.id"', '_type text PATH "$.type"', '_schema text PATH "$.$schema"', '_required json PATH "$.required"', '_properties json PATH "$.properties"', '_description text PATH "$.description"'],
       ARRAY['id', '_type', '_schema', '_required', '_properties', '_description'])
       FROM s9;
                                                                                                                                                                   QUERY PLAN                                                                                                                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..157.52 rows=1462 width=32)
   Output: mysql_json_table(c1, '$'::text, '{"id VARCHAR(100) PATH \"$.id\"","_type text PATH \"$.type\"","_schema text PATH \"$.$schema\"","_required json PATH \"$.required\"","_properties json PATH \"$.properties\"","_description text PATH \"$.description\""}'::text[], '{id,_type,_schema,_required,_properties,_description}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9`
(4 rows)

-- select mysql_json_table (result)
--Testcase 4198:
SELECT mysql_json_table(c1,'$',
       ARRAY['id VARCHAR(100) PATH "$.id"', '_type text PATH "$.type"', '_schema text PATH "$.$schema"', '_required json PATH "$.required"', '_properties json PATH "$.properties"', '_description text PATH "$.description"'],
       ARRAY['id', '_type', '_schema', '_required', '_properties', '_description'])
       FROM s9;
ERROR:  stub mysql_json_table(json, text, text[], text[]) is called
CONTEXT:  PL/pgSQL function mysql_json_table(json,text,text[],text[]) line 3 at RAISE
--Testcase 4199:
CREATE TABLE loc_tbl (
  id text,
  _type text,
  _schema text,
  _required json,
  _properties json,
  _description text
);
-- select mysql_json_table (result, access record)
--Testcase 4200:
SELECT * FROM (
  SELECT (mysql_json_table(c1,'$',
          ARRAY['id VARCHAR(100) PATH "$.id"', '_type text PATH "$.type"', '_schema text PATH "$.$schema"', '_required json PATH "$.required"', '_properties json PATH "$.properties"', '_description text PATH "$.description"'],
          ARRAY['id', '_type', '_schema', '_required', '_properties', '_description'])::loc_tbl).*
          FROM s9
) t;
ERROR:  stub mysql_json_table(json, text, text[], text[]) is called
CONTEXT:  PL/pgSQL function mysql_json_table(json,text,text[],text[]) line 3 at RAISE
--Testcase 4201:
DROP TABLE loc_tbl;
-- select mysql_json_table (pushed down constraints, explain)
--Testcase 4202:
EXPLAIN VERBOSE
SELECT mysql_json_table(c1,'$',
       ARRAY['id VARCHAR(100) PATH "$.id"', '_type text PATH "$.type"', '_schema text PATH "$.$schema"', '_required json PATH "$.required"', '_properties json PATH "$.properties"', '_description text PATH "$.description"'],
       ARRAY['id', '_type', '_schema', '_required', '_properties', '_description'])
       FROM s9 WHERE json_depth(c1) > 1;
                                                                                                                                                                   QUERY PLAN                                                                                                                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..142.89 rows=487 width=32)
   Output: mysql_json_table(c1, '$'::text, '{"id VARCHAR(100) PATH \"$.id\"","_type text PATH \"$.type\"","_schema text PATH \"$.$schema\"","_required json PATH \"$.required\"","_properties json PATH \"$.properties\"","_description text PATH \"$.description\""}'::text[], '{id,_type,_schema,_required,_properties,_description}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9` WHERE ((json_depth(`c1`) > 1))
(4 rows)

-- select mysql_json_table (pushed down constraints, result)
--Testcase 4203:
SELECT mysql_json_table(c1,'$',
       ARRAY['id VARCHAR(100) PATH "$.id"', '_type text PATH "$.type"', '_schema text PATH "$.$schema"', '_required json PATH "$.required"', '_properties json PATH "$.properties"', '_description text PATH "$.description"'],
       ARRAY['id', '_type', '_schema', '_required', '_properties', '_description'])
       FROM s9 WHERE json_depth(c1) > 1;
ERROR:  stub mysql_json_table(json, text, text[], text[]) is called
CONTEXT:  PL/pgSQL function mysql_json_table(json,text,text[],text[]) line 3 at RAISE
--Testcase 4204:
CREATE TABLE loc_tbl (
  id text,
  _type text,
  _schema text,
  _required json,
  _properties json,
  _description text
);
-- select mysql_json_table (pushed down constraints, result, access record)
--Testcase 4205:
SELECT id, _type FROM (
  SELECT (mysql_json_table(c1,'$',
          ARRAY['id VARCHAR(100) PATH "$.id"', '_type text PATH "$.type"', '_schema text PATH "$.$schema"', '_required json PATH "$.required"', '_properties json PATH "$.properties"', '_description text PATH "$.description"'],
          ARRAY['id', '_type', '_schema', '_required', '_properties', '_description'])::loc_tbl).*
          FROM s9 WHERE json_depth(c1) > 1
) t;
ERROR:  stub mysql_json_table(json, text, text[], text[]) is called
CONTEXT:  PL/pgSQL function mysql_json_table(json,text,text[],text[]) line 3 at RAISE
--Testcase 4206:
DROP TABLE loc_tbl;
-- mysql_json_table with nested path (explain)
--Testcase 4207:
EXPLAIN VERBOSE
SELECT mysql_json_table(c1,'$',
       ARRAY['id VARCHAR(100) PATH "$.id"', 'NESTED PATH "$.properties.*" COLUMNS(maximum int PATH "$.maximum", minimum int PATH "$.minimum")'],
       ARRAY['id', 'maximum', 'minimum']), c1
       FROM s9;
                                                                                                             QUERY PLAN                                                                                                              
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..157.52 rows=1462 width=64)
   Output: mysql_json_table(c1, '$'::text, '{"id VARCHAR(100) PATH \"$.id\"","NESTED PATH \"$.properties.*\" COLUMNS(maximum int PATH \"$.maximum\", minimum int PATH \"$.minimum\")"}'::text[], '{id,maximum,minimum}'::text[]), c1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s9`
(4 rows)

-- mysql_json_table with nested path (value)
--Testcase 4208:
SELECT mysql_json_table(c1,'$',
       ARRAY['id VARCHAR(100) PATH "$.id"', 'NESTED PATH "$.properties.*" COLUMNS(maximum int PATH "$.maximum", minimum int PATH "$.minimum")'],
       ARRAY['id', 'maximum', 'minimum']), c1
       FROM s9;
ERROR:  stub mysql_json_table(json, text, text[], text[]) is called
CONTEXT:  PL/pgSQL function mysql_json_table(json,text,text[],text[]) line 3 at RAISE
--Testcase 4209:
CREATE TABLE loc_tbl (
  id text,
  maximum int,
  minimum int
);
-- mysql_json_table with nested path (value, access record)
--Testcase 4210:
SELECT (t1::loc_tbl).*, c1 FROM (
SELECT mysql_json_table(c1,'$',
       ARRAY['id VARCHAR(100) PATH "$.id"', 'NESTED PATH "$.properties.*" COLUMNS(maximum int PATH "$.maximum", minimum int PATH "$.minimum")'],
       ARRAY['id', 'maximum', 'minimum']) AS t1, c1
       FROM s9
) t;
ERROR:  stub mysql_json_table(json, text, text[], text[]) is called
CONTEXT:  PL/pgSQL function mysql_json_table(json,text,text[],text[]) line 3 at RAISE
--Testcase 4211:
DROP TABLE loc_tbl;
-- select mysql_json_table constant argument (explain)
--Testcase 4212:
EXPLAIN VERBOSE
SELECT id, mysql_json_table('[{"x":2,"y":"8"},{"x":"3","y":"7"},{"x":"4","y":6}]','$[*]',
       ARRAY['xval VARCHAR(100) PATH "$.x"', ' yval VARCHAR(100) PATH "$.y"'],
       ARRAY['xval', 'yval'])
       FROM s9 WHERE id = 0;
                                                                                                    QUERY PLAN                                                                                                    
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s9  (cost=100.00..146.90 rows=15 width=36)
   Output: id, mysql_json_table('[{"x":2,"y":"8"},{"x":"3","y":"7"},{"x":"4","y":6}]'::json, '$[*]'::text, '{"xval VARCHAR(100) PATH \"$.x\""," yval VARCHAR(100) PATH \"$.y\""}'::text[], '{xval,yval}'::text[])
   Local server startup cost: 10
   Remote query: SELECT `id` FROM `mysql_fdw_regress`.`s9` WHERE ((`id` = 0))
(4 rows)

-- select mysql_json_table constant argument (result)
--Testcase 4213:
SELECT id, mysql_json_table('[{"x":2,"y":"8"},{"x":"3","y":"7"},{"x":"4","y":6}]','$[*]',
       ARRAY['xval VARCHAR(100) PATH "$.x"', ' yval VARCHAR(100) PATH "$.y"'],
       ARRAY['xval', 'yval'])
       FROM s9 WHERE id = 0;
ERROR:  stub mysql_json_table(json, text, text[], text[]) is called
CONTEXT:  PL/pgSQL function mysql_json_table(json,text,text[],text[]) line 3 at RAISE
--Testcase 4214:
CREATE TABLE loc_tbl (
  xval int,
  yval int
);
-- select mysql_json_table constant argument (result)
--Testcase 4215:
SELECT (t1::loc_tbl).*, id FROM (
SELECT id, mysql_json_table('[{"x":2,"y":"8"},{"x":"3","y":"7"},{"x":"4","y":6}]','$[*]',
       ARRAY['xval VARCHAR(100) PATH "$.x"', ' yval VARCHAR(100) PATH "$.y"'],
       ARRAY['xval', 'yval']) AS t1, c1
       FROM s9 WHERE id = 0
) t;
ERROR:  stub mysql_json_table(json, text, text[], text[]) is called
CONTEXT:  PL/pgSQL function mysql_json_table(json,text,text[],text[]) line 3 at RAISE
--Testcase 4216:
DROP TABLE loc_tbl;
-- JSON_TYPE()
-- select json_type (builtin function, explain)
--Testcase 4217:
EXPLAIN VERBOSE
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..174.84 rows=1365 width=160)
   Output: json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)), json_type('{"a":1,"b":10,"d":10}'::json), json_type('[1,3,5,7]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_type (builtin function, result)
--Testcase 4218:
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8;
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_type (builtin function, not pushdown constraints, explain)
--Testcase 4219:
EXPLAIN VERBOSE
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8 WHERE to_hex(id) = '2';
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.74 rows=7 width=160)
   Output: json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)), json_type('{"a":1,"b":10,"d":10}'::json), json_type('[1,3,5,7]'::json)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_type (builtin function, not pushdown constraints, result)
--Testcase 4220:
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_type (builtin function, pushdown constraints, explain)
--Testcase 4221:
EXPLAIN VERBOSE
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8 WHERE id != 0;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..177.99 rows=1358 width=160)
   Output: json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)), json_type('{"a":1,"b":10,"d":10}'::json), json_type('[1,3,5,7]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_type (builtin function, pushdown constraints, result)
--Testcase 4222:
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8 WHERE id != 0;
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_type (builtin function, json_type in constraints, explain)
--Testcase 4223:
EXPLAIN VERBOSE
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8 WHERE json_type(c1) NOT LIKE '$';
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..181.40 rows=1358 width=160)
   Output: json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)), json_type('{"a":1,"b":10,"d":10}'::json), json_type('[1,3,5,7]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_type(`c1`) NOT LIKE BINARY '$'))
(4 rows)

-- select json_type (builtin function, json_type in constraints, result)
--Testcase 4224:
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8 WHERE json_type(c1) NOT LIKE '$';
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_type (builtin function, json_type in constraints, explain)
--Testcase 4225:
EXPLAIN VERBOSE
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8 where json_type('[1,3,5,7]') LIKE 'ARRAY';
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.74 rows=7 width=160)
   Output: json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)), json_type('{"a":1,"b":10,"d":10}'::json), json_type('[1,3,5,7]'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_type(CAST('[1,3,5,7]' AS JSON)) LIKE BINARY 'ARRAY'))
(4 rows)

-- select json_type (builtin function, json_type in constraints, result)
--Testcase 4226:
SELECT json_type(c1), json_type(json_build_array(c1, '1')), json_type(json_build_object('a', '1', 'b', c2)),json_type('{"a":1,"b":10,"d":10}'),json_type('[1,3,5,7]') FROM s8 where json_type('[1,3,5,7]') LIKE 'ARRAY';
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_type as nest function with agg (pushdown, explain)
--Testcase 4227:
EXPLAIN VERBOSE
SELECT sum(id),json_type(json_build_object('a', '1', 'b',sum(id))) FROM s8;
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_type(json_build_object('a', '1', 'b', sum(id))))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_type(json_object('a', '1', 'b', sum(`id`))) FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_type as nest function with agg (pushdown, result)
--Testcase 4228:
SELECT sum(id),json_type(json_build_object('a', '1', 'b',sum(id))) FROM s8;
 sum | json_type 
-----+-----------
  15 | OBJECT
(1 row)

-- select json_type with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4229:
EXPLAIN VERBOSE
SELECT json_type(json_build_object('a', '1', 'b', c2)), pi(), 4.1 FROM s8;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..212.38 rows=2925 width=72)
   Output: json_type(json_build_object('a', '1', 'b', c2)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_type with non pushdown func and explicit constant (result)
--Testcase 4230:
SELECT json_type(json_build_object('a', '1', 'b', c2)), pi(), 4.1 FROM s8;
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_type with order by index (result)
--Testcase 4231:
SELECT id, json_type(c1) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_type with order by index (result)
--Testcase 4232:
SELECT id, json_type(c1) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_type with group by (EXPLAIN)
--Testcase 4233:
EXPLAIN VERBOSE
SELECT count(id), json_type(c1) FROM s8 group by json_type(c1);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(id)), (json_type(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_type(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_type with group by (result)
--Testcase 4234:
SELECT count(id), json_type(c1) FROM s8 group by json_type(c1);
 count | json_type 
-------+-----------
     3 | ARRAY
     3 | OBJECT
(2 rows)

-- select json_type with group by index (result)
--Testcase 4235:
SELECT id, json_type(c1) FROM s8 group by 2, 1;
 id | json_type 
----+-----------
  0 | ARRAY
  1 | ARRAY
  2 | OBJECT
  3 | OBJECT
  4 | OBJECT
  5 | ARRAY
(6 rows)

-- select json_type with group by index (result)
--Testcase 4236:
SELECT id, json_type(c1) FROM s8 group by 1, 2;
 id | json_type 
----+-----------
  0 | ARRAY
  1 | ARRAY
  2 | OBJECT
  3 | OBJECT
  4 | OBJECT
  5 | ARRAY
(6 rows)

-- select json_type with group by having (EXPLAIN)
--Testcase 4237:
EXPLAIN VERBOSE
SELECT count(c2), json_type(c1) FROM s8 group by json_type(c1) HAVING count(c2) > 0;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=40)
   Output: (count(c2)), (json_type(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_type(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_type with group by having (result)
--Testcase 4238:
SELECT count(c2), json_type(c1) FROM s8 group by json_type(c1) HAVING count(c2) > 0;
 count | json_type 
-------+-----------
     3 | ARRAY
     3 | OBJECT
(2 rows)

-- select json_type with group by index having (result)
--Testcase 4239:
SELECT c2, json_type(c1) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_type 
----+-----------
  1 | ARRAY
  2 | ARRAY
  3 | OBJECT
  4 | OBJECT
  5 | OBJECT
  5 | ARRAY
(6 rows)

-- select json_type with group by index having (result)
--Testcase 4240:
SELECT c2, json_type(c1) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_type 
----+-----------
  1 | ARRAY
  2 | ARRAY
  3 | OBJECT
  4 | OBJECT
  5 | OBJECT
  5 | ARRAY
(6 rows)

-- select json_type and as
--Testcase 4241:
SELECT json_type(json_build_object('a', '1', 'b', c2)) as json_type1 FROM s8;
ERROR:  stub json_type(json) is called
CONTEXT:  PL/pgSQL function json_type(json) line 3 at RAISE
-- select json_unquote (builtin function, explain)
--Testcase 4242:
EXPLAIN VERBOSE
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..168.48 rows=1462 width=128)
   Output: json_unquote(c3), json_unquote('null'::text), json_unquote('"null"'::text), json_unquote('[1, 2, 3]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_unquote (builtin function, result)
--Testcase 4243:
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8;
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote (builtin function, not pushdown constraints, explain)
--Testcase 4244:
EXPLAIN VERBOSE
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8 WHERE to_hex(id) = '2';
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.14 rows=7 width=128)
   Output: json_unquote(c3), json_unquote('null'::text), json_unquote('"null"'::text), json_unquote('[1, 2, 3]'::text)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_unquote (builtin function, not pushdown constraints, result)
--Testcase 4245:
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote (builtin function, pushdown constraints, explain)
--Testcase 4246:
EXPLAIN VERBOSE
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8 WHERE id != 0;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..171.93 rows=1455 width=128)
   Output: json_unquote(c3), json_unquote('null'::text), json_unquote('"null"'::text), json_unquote('[1, 2, 3]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_unquote (builtin function, pushdown constraints, result)
--Testcase 4247:
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8 WHERE id != 0;
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote (builtin function, json_unquote in constraints, explain)
--Testcase 4248:
EXPLAIN VERBOSE
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8 WHERE json_unquote(c3) NOT LIKE 'text';
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.58 rows=1455 width=128)
   Output: json_unquote(c3), json_unquote('null'::text), json_unquote('"null"'::text), json_unquote('[1, 2, 3]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_unquote(`c3`) NOT LIKE BINARY 'text'))
(4 rows)

-- select json_unquote (builtin function, json_unquote in constraints, result)
--Testcase 4249:
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8 WHERE json_unquote(c3) NOT LIKE 'text';
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote (builtin function, json_unquote in constraints, explain)
--Testcase 4250:
EXPLAIN VERBOSE
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8 WHERE json_unquote('[1, 2, 3]') LIKE '[1, 2, 3]';
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.14 rows=7 width=128)
   Output: json_unquote(c3), json_unquote('null'::text), json_unquote('"null"'::text), json_unquote('[1, 2, 3]'::text)
   Local server startup cost: 10
   Remote query: SELECT `c3` FROM `mysql_fdw_regress`.`s8` WHERE ((json_unquote('[1, 2, 3]') LIKE BINARY '[1, 2, 3]'))
(4 rows)

-- select json_unquote (builtin function, json_unquote in constraints, result)
--Testcase 4251:
SELECT json_unquote(c3), json_unquote('null'), json_unquote('"null"'), json_unquote('[1, 2, 3]') FROM s8 WHERE json_unquote('[1, 2, 3]') LIKE '[1, 2, 3]';
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote as nest function with agg (pushdown, explain)
--Testcase 4252:
EXPLAIN VERBOSE
SELECT sum(id), json_unquote('[1, 2, 3]') FROM s8;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=40)
   Output: (sum(id)), (json_unquote('[1, 2, 3]'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_unquote('[1, 2, 3]') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_unquote as nest function with agg (pushdown, result)
--Testcase 4253:
SELECT sum(id), json_unquote('[1, 2, 3]') FROM s8;
 sum | json_unquote 
-----+--------------
  15 | [1, 2, 3]
(1 row)

-- select json_unquote with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4254:
EXPLAIN VERBOSE
SELECT json_unquote('null'), pi(), 4.1 FROM s8;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..220.92 rows=3413 width=72)
   Output: json_unquote('null'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_unquote with non pushdown func and explicit constant (result)
--Testcase 4255:
SELECT json_unquote('null'), pi(), 4.1 FROM s8;
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote with order by (EXPLAIN)
--Testcase 4256:
EXPLAIN VERBOSE
SELECT id,  json_unquote(c3) FROM s8 ORDER BY json_unquote(c3);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=30.00..30.07 rows=30 width=36)
   Output: id, json_unquote(c3)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c3` FROM `mysql_fdw_regress`.`s8` ORDER BY json_unquote(`c3`) IS NULL ASC, json_unquote(`c3`) ASC
(4 rows)

-- select json_unquote with order by (result)
--Testcase 4257:
SELECT id,  json_unquote(c3) FROM s8 ORDER BY json_unquote(c3);
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote with order by index (result)
--Testcase 4258:
SELECT id,  json_unquote(c3) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote with order by index (result)
--Testcase 4259:
SELECT id,  json_unquote(c3) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_unquote with group by (EXPLAIN)
--Testcase 4260:
EXPLAIN VERBOSE
SELECT count(id), json_unquote(c3) FROM s8 group by json_unquote(c3);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(id)), (json_unquote(c3))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_unquote(`c3`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_unquote with group by (result)
--Testcase 4261:
SELECT count(id), json_unquote(c3) FROM s8 group by json_unquote(c3);
 count | json_unquote 
-------+--------------
     1 | This
     1 | is
     1 | text
     3 | scalar
(4 rows)

-- select json_unquote with group by index (result)
--Testcase 4262:
SELECT id,  json_unquote(c3) FROM s8 group by 2, 1;
 id | json_unquote 
----+--------------
  0 | This
  1 | is
  2 | text
  3 | scalar
  4 | scalar
  5 | scalar
(6 rows)

-- select json_unquote with group by index (result)
--Testcase 4263:
SELECT id,  json_unquote(c3) FROM s8 group by 1, 2;
 id | json_unquote 
----+--------------
  0 | This
  1 | is
  2 | text
  3 | scalar
  4 | scalar
  5 | scalar
(6 rows)

-- select json_unquote with group by having (EXPLAIN)
--Testcase 4264:
EXPLAIN VERBOSE
SELECT count(c2), json_unquote(c3) FROM s8 group by json_unquote(c3) HAVING count(c2) > 0;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=40)
   Output: (count(c2)), (json_unquote(c3))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_unquote(`c3`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_unquote with group by having (result)
--Testcase 4265:
SELECT count(c2), json_unquote(c3) FROM s8 group by json_unquote(c3) HAVING count(c2) > 0;
 count | json_unquote 
-------+--------------
     1 | This
     1 | is
     1 | text
     3 | scalar
(4 rows)

-- select json_unquote with group by index having (result)
--Testcase 4266:
SELECT c2,  json_unquote(c3) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_unquote 
----+--------------
  1 | This
  2 | is
  3 | text
  4 | scalar
  5 | scalar
(5 rows)

-- select json_unquote with group by index having (result)
--Testcase 4267:
SELECT c2,  json_unquote(c3) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_unquote 
----+--------------
  1 | This
  2 | is
  3 | text
  4 | scalar
  5 | scalar
(5 rows)

-- select json_unquote and as
--Testcase 4268:
SELECT json_unquote('null') as json_unquote1 FROM s8;
ERROR:  stub json_unquote(text) is called
CONTEXT:  PL/pgSQL function json_unquote(text) line 3 at RAISE
-- select json_valid (builtin function, explain)
--Testcase 4269:
EXPLAIN VERBOSE
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..164.60 rows=1365 width=12)
   Output: json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_valid (builtin function, result)
--Testcase 4270:
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8;
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select json_valid (builtin function, not pushdown constraints, explain)
--Testcase 4271:
EXPLAIN VERBOSE
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE to_hex(id) = '2';
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.68 rows=7 width=12)
   Output: json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}'::text)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_valid (builtin function, not pushdown constraints, result)
--Testcase 4272:
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select json_valid (builtin function, pushdown constraints, explain)
--Testcase 4273:
EXPLAIN VERBOSE
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE id != 0;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..167.80 rows=1358 width=12)
   Output: json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select json_valid (builtin function, pushdown constraints, result)
--Testcase 4274:
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE id != 0;
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select json_valid (builtin function, json_valid in constraints, explain)
--Testcase 4275:
EXPLAIN VERBOSE
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_valid(c1) != 0;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..171.22 rows=1358 width=12)
   Output: json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_valid(`c1`) <> 0))
(4 rows)

-- select json_valid (builtin function, json_valid in constraints, result)
--Testcase 4276:
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_valid(c1) != 0;
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select json_valid (builtin function, json_valid in constraints, explain)
--Testcase 4277:
EXPLAIN VERBOSE
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_valid('{"a": 1, "b": {"c": 30}}') = 1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..130.68 rows=7 width=12)
   Output: json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}'::text)
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8` WHERE ((json_valid('{"a": 1, "b": {"c": 30}}') = 1))
(4 rows)

-- select json_valid (builtin function, json_valid in constraints, result)
--Testcase 4278:
SELECT json_valid(c1), json_valid(json_build_array(c1, 'a', c2)), json_valid('{"a": 1, "b": {"c": 30}}') FROM s8 WHERE json_valid('{"a": 1, "b": {"c": 30}}') = 1;
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select json_valid as nest function with agg (pushdown, explain)
--Testcase 4279:
EXPLAIN VERBOSE
SELECT sum(id),json_valid('{"a": 1, "b": {"c": 30}}') FROM s8;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (sum(id)), (json_valid('{"a": 1, "b": {"c": 30}}'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_valid('{"a": 1, "b": {"c": 30}}') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select json_valid as nest function with agg (pushdown, result)
--Testcase 4280:
SELECT sum(id),json_valid('{"a": 1, "b": {"c": 30}}') FROM s8;
 sum | json_valid 
-----+------------
  15 |          1
(1 row)

-- select json_valid with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4281:
EXPLAIN VERBOSE
SELECT json_valid(json_build_array(c1, 'a', c2)), pi(), 4.1 FROM s8;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.78 rows=1365 width=44)
   Output: json_valid(json_build_array(c1, 'a', c2)), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1`, `c2` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_valid with non pushdown func and explicit constant (result)
--Testcase 4282:
SELECT json_valid(json_build_array(c1, 'a', c2)), pi(), 4.1 FROM s8;
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select json_valid with order by index (result)
--Testcase 4283:
SELECT id, json_valid(c1) FROM s8 ORDER BY 2, 1;
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select json_valid with order by index (result)
--Testcase 4284:
SELECT id, json_valid(c1) FROM s8 ORDER BY 1, 2;
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select json_valid with group by (EXPLAIN)
--Testcase 4285:
EXPLAIN VERBOSE
SELECT count(id), json_valid(c1) FROM s8 group by json_valid(c1);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (json_valid(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_valid(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select json_valid with group by (result)
--Testcase 4286:
SELECT count(id), json_valid(c1) FROM s8 group by json_valid(c1);
 count | json_valid 
-------+------------
     6 |          1
(1 row)

-- select json_valid with group by index (result)
--Testcase 4287:
SELECT id, json_valid(c1) FROM s8 group by 2, 1;
 id | json_valid 
----+------------
  0 |          1
  1 |          1
  2 |          1
  3 |          1
  4 |          1
  5 |          1
(6 rows)

-- select json_valid with group by index (result)
--Testcase 4288:
SELECT id, json_valid(c1) FROM s8 group by 1, 2;
 id | json_valid 
----+------------
  0 |          1
  1 |          1
  2 |          1
  3 |          1
  4 |          1
  5 |          1
(6 rows)

-- select json_valid with group by having (EXPLAIN)
--Testcase 4289:
EXPLAIN VERBOSE
SELECT count(c2), json_valid(c1) FROM s8 group by json_valid(c1) HAVING count(c2) > 0;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (json_valid(c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_valid(`c1`) FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select json_valid with group by having (result)
--Testcase 4290:
SELECT count(c2), json_valid(c1) FROM s8 group by json_valid(c1) HAVING count(c2) > 0;
 count | json_valid 
-------+------------
     6 |          1
(1 row)

-- select json_valid with group by index having (result)
--Testcase 4291:
SELECT c2, json_valid(c1) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | json_valid 
----+------------
  1 |          1
  2 |          1
  3 |          1
  4 |          1
  5 |          1
(5 rows)

-- select json_valid with group by index having (result)
--Testcase 4292:
SELECT c2, json_valid(c1) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | json_valid 
----+------------
  1 |          1
  2 |          1
  3 |          1
  4 |          1
  5 |          1
(5 rows)

-- select json_valid and as
--Testcase 4293:
SELECT json_valid(json_build_array(c1, 'a', c2)) as json_valid1 FROM s8;
ERROR:  stub json_valid(json) is called
CONTEXT:  PL/pgSQL function json_valid(json) line 3 at RAISE
-- select mysql_json_value (stub function, explain)
--Testcase 4294:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..172.14 rows=1462 width=96)
   Output: mysql_json_value(c1, '$.a'::text), mysql_json_value(c1, '$[1]'::text), (mysql_json_value('{"item": "shoes", "price": "49.95"}'::json, '$.price'::text, 'returning decimal(10, 1)'::text))::numeric
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select json_value (stub function, result)
--Testcase 4295:
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value (stub function, not pushdown constraints, explain)
--Testcase 4296:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8 WHERE to_hex(id) = '2';
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.16 rows=7 width=96)
   Output: mysql_json_value(c1, '$.a'::text), mysql_json_value(c1, '$[1]'::text), (mysql_json_value('{"item": "shoes", "price": "49.95"}'::json, '$.price'::text, 'returning decimal(10, 1)'::text))::numeric
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select mysql_json_value (stub function, not pushdown constraints, result)
--Testcase 4297:
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value (stub function, pushdown constraints, explain)
--Testcase 4298:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8 WHERE id != 0;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.56 rows=1455 width=96)
   Output: mysql_json_value(c1, '$.a'::text), mysql_json_value(c1, '$[1]'::text), (mysql_json_value('{"item": "shoes", "price": "49.95"}'::json, '$.price'::text, 'returning decimal(10, 1)'::text))::numeric
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select mysql_json_value (stub function, pushdown constraints, result)
--Testcase 4299:
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8 WHERE id != 0;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value (stub function, mysql_json_value in constraints, explain)
--Testcase 4300:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8 WHERE mysql_json_value(c1, '$.a', 'default 0 on empty')::int > 1;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..155.07 rows=487 width=96)
   Output: mysql_json_value(c1, '$.a'::text), mysql_json_value(c1, '$[1]'::text), (mysql_json_value('{"item": "shoes", "price": "49.95"}'::json, '$.price'::text, 'returning decimal(10, 1)'::text))::numeric
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_value(`c1`, '$.a' default 0 on empty) > 1))
(4 rows)

-- select mysql_json_value (stub function, mysql_json_value in constraints, result)
--Testcase 4301:
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8 WHERE mysql_json_value(c1, '$.a', 'default 0 on empty')::int > 1;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value (stub function, mysql_json_value in constraints, explain)
--Testcase 4302:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8 WHERE mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 2)')::decimal = 49.95;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..139.47 rows=7 width=96)
   Output: mysql_json_value(c1, '$.a'::text), mysql_json_value(c1, '$[1]'::text), (mysql_json_value('{"item": "shoes", "price": "49.95"}'::json, '$.price'::text, 'returning decimal(10, 1)'::text))::numeric
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_value(CAST('{"item": "shoes", "price": "49.95"}' AS JSON), '$.price' returning decimal(10, 2)) = 49.95))
(4 rows)

-- select mysql_json_value (stub function, mysql_json_value in constraints, result)
--Testcase 4303:
SELECT mysql_json_value(c1, '$.a'), mysql_json_value(c1, '$[1]'), mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 1)')::numeric FROM s8 WHERE mysql_json_value('{"item": "shoes", "price": "49.95"}', '$.price', 'returning decimal(10, 2)')::decimal = 49.95;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value (stub function, abnormal cast, explain)
--Testcase 4304:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$.a')::date FROM s8;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..164.83 rows=1462 width=4)
   Output: (mysql_json_value(c1, '$.a'::text))::date
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select mysql_json_value (stub function, abnormal cast, result)
--Testcase 4305:
SELECT mysql_json_value(c1, '$.a')::date FROM s8; -- should fail
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value (stub function, abnormal cast, explain)
--Testcase 4306:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$.a', 'returning date')::date FROM s8;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..164.83 rows=1462 width=4)
   Output: (mysql_json_value(c1, '$.a'::text, 'returning date'::text))::date
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select mysql_json_value (stub function, abnormal cast, result)
--Testcase 4307:
SELECT mysql_json_value(c1, '$.a', 'returning date')::date FROM s8; --empty result
ERROR:  stub mysql_json_value(json, text, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text,text) line 3 at RAISE
-- select mysql_json_value (stub function, abnormal cast, explain)
--Testcase 4308:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$.a', 'returning date', 'error on error')::date FROM s8;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..164.83 rows=1462 width=4)
   Output: (mysql_json_value(c1, '$.a'::text, 'returning date'::text, 'error on error'::text))::date
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select mysql_json_value (stub function, abnormal cast, result)
--Testcase 4309:
SELECT mysql_json_value(c1, '$.a', 'returning date', 'error on error')::date FROM s8; -- should fail
ERROR:  stub mysql_json_value(json, text, text, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text,text,text) line 3 at RAISE
-- select mysql_json_value with normal cast
--Testcase 4310:
SELECT mysql_json_value('{"a": "2000-01-01"}', '$.a')::timestamp, mysql_json_value('{"a": "2000-01-01"}', '$.a')::date , mysql_json_value('{"a": 1234}', '$.a')::bigint, mysql_json_value('{"a": "b"}', '$.a')::text FROM s8;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value with normal cast
--Testcase 4311:
SELECT mysql_json_value('{"a": "2000-01-01"}', '$.a')::timestamptz, mysql_json_value('{"a": "12:10:20.123456"}', '$.a')::time , mysql_json_value('{"a": "12:10:20.123456"}', '$.a')::timetz FROM s8;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value with type modifier (explain)
--Testcase 4312:
EXPLAIN VERBOSE
SELECT mysql_json_value('{"a": "2000-01-01 12:02:01.123456"}', '$.a')::timestamp(3), mysql_json_value('{"a": "2000-01-01 12:02:01.123456"}', '$.a')::timestamptz(3), mysql_json_value('{"a": "12:10:20.123456"}', '$.a')::time(3), mysql_json_value('{"a": "12:10:20.123456"}', '$.a')::timetz(3) FROM s8;
                                                                                                                                                                                                         QUERY PLAN                                                                                                                                                                                                         
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..348.91 rows=3413 width=36)
   Output: (mysql_json_value('{"a": "2000-01-01 12:02:01.123456"}'::json, '$.a'::text))::timestamp(3) without time zone, (mysql_json_value('{"a": "2000-01-01 12:02:01.123456"}'::json, '$.a'::text))::timestamp(3) with time zone, (mysql_json_value('{"a": "12:10:20.123456"}'::json, '$.a'::text))::time(3) without time zone, (mysql_json_value('{"a": "12:10:20.123456"}'::json, '$.a'::text))::time(3) with time zone
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select mysql_json_value with type modifier (result)
--Testcase 4313:
SELECT mysql_json_value('{"a": "2000-01-01 12:02:01.123456"}', '$.a')::timestamp(3), mysql_json_value('{"a": "2000-01-01 12:02:01.123456"}', '$.a')::timestamptz(3), mysql_json_value('{"a": "12:10:20.123456"}', '$.a')::time(3), mysql_json_value('{"a": "12:10:20.123456"}', '$.a')::timetz(3) FROM s8;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value with type modifier (explain)
--Testcase 4314:
EXPLAIN VERBOSE
SELECT mysql_json_value('{"a": 100}', '$.a')::numeric(10, 2), mysql_json_value('{"a": 100}', '$.a')::decimal(10, 2), json_unquote(mysql_json_value('{"a": "1.123456"}', '$.a'))::numeric(10, 3) FROM s8;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..323.31 rows=3413 width=48)
   Output: (mysql_json_value('{"a": 100}'::json, '$.a'::text))::numeric(10,2), (mysql_json_value('{"a": 100}'::json, '$.a'::text))::numeric(10,2), (json_unquote(mysql_json_value('{"a": "1.123456"}'::json, '$.a'::text)))::numeric(10,3)
   Local server startup cost: 10
   Remote query: SELECT NULL FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select mysql_json_value with type modifier (result)
--Testcase 4315:
SELECT mysql_json_value('{"a": 100}', '$.a')::numeric(10, 2), mysql_json_value('{"a": 100}', '$.a')::decimal(10, 2), json_unquote(mysql_json_value('{"a": "1.123456"}', '$.a'))::numeric(10, 3) FROM s8;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value as nest function with agg (pushdown, explain)
--Testcase 4316:
EXPLAIN VERBOSE
SELECT sum(id), mysql_json_value(json_build_object('item', 'shoe', 'price', sum(id)), '$.price')::int FROM s8;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (sum(id)), ((mysql_json_value(json_build_object('item', 'shoe', 'price', sum(id)), '$.price'::text))::integer)
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_value(json_object('item', 'shoe', 'price', sum(`id`)), '$.price') FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select mysql_json_value as nest function with agg (pushdown, result)
--Testcase 4317:
SELECT sum(id), mysql_json_value(json_build_object('item', 'shoe', 'price', sum(id)), '$.price')::int FROM s8;
 sum | mysql_json_value 
-----+------------------
  15 |               15
(1 row)

-- select mysql_json_value with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4318:
EXPLAIN VERBOSE
SELECT mysql_json_value(c1, '$[1]'), pi(), 4.1 FROM s8;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..157.52 rows=1462 width=72)
   Output: mysql_json_value(c1, '$[1]'::text), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select mysql_json_value with non pushdown func and explicit constant (result)
--Testcase 4319:
SELECT mysql_json_value(c1, '$[1]'), pi(), 4.1 FROM s8;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value with order by index (result)
--Testcase 4320:
SELECT id, mysql_json_value(c1, '$.a') FROM s8 ORDER BY 2, 1;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value with order by index (result)
--Testcase 4321:
SELECT id, mysql_json_value(c1, '$.a') FROM s8 ORDER BY 1, 2;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select mysql_json_value with group by (EXPLAIN)
--Testcase 4322:
EXPLAIN VERBOSE
SELECT count(id), mysql_json_value(c1, '$.a') FROM s8 group by mysql_json_value(c1, '$.a');
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=40)
   Output: (count(id)), (mysql_json_value(c1, '$.a'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), json_value(`c1`, '$.a') FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select mysql_json_value with group by (result)
--Testcase 4323:
SELECT count(id), mysql_json_value(c1, '$.a') FROM s8 group by mysql_json_value(c1, '$.a');
 count | mysql_json_value 
-------+------------------
     4 | 
     1 | 10
     1 | 1
(3 rows)

-- select mysql_json_value with group by index (result)
--Testcase 4324:
SELECT id, mysql_json_value(c1, '$.a') FROM s8 group by 2, 1;
 id | mysql_json_value 
----+------------------
  0 | 
  1 | 
  2 | 
  3 | 10
  4 | 1
  5 | 
(6 rows)

-- select mysql_json_value with group by index (result)
--Testcase 4325:
SELECT id, mysql_json_value(c1, '$.a') FROM s8 group by 1, 2;
 id | mysql_json_value 
----+------------------
  0 | 
  1 | 
  2 | 
  3 | 10
  4 | 1
  5 | 
(6 rows)

-- select mysql_json_value with group by having (EXPLAIN)
--Testcase 4326:
EXPLAIN VERBOSE
SELECT count(c2), mysql_json_value(c1, '$.a') FROM s8 group by mysql_json_value(c1, '$.a') HAVING count(c2) > 0;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=40)
   Output: (count(c2)), (mysql_json_value(c1, '$.a'::text))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), json_value(`c1`, '$.a') FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select mysql_json_value with group by having (result)
--Testcase 4327:
SELECT count(c2), mysql_json_value(c1, '$.a') FROM s8 group by mysql_json_value(c1, '$.a') HAVING count(c2) > 0;
 count | mysql_json_value 
-------+------------------
     4 | 
     1 | 10
     1 | 1
(3 rows)

-- select mysql_json_value with group by index having (result)
--Testcase 4328:
SELECT c2, mysql_json_value(c1, '$.a') FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | mysql_json_value 
----+------------------
  1 | 
  2 | 
  3 | 
  4 | 10
  5 | 1
  5 | 
(6 rows)

-- select mysql_json_value with group by index having (result)
--Testcase 4329:
SELECT c2, mysql_json_value(c1, '$.a') FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | mysql_json_value 
----+------------------
  1 | 
  2 | 
  3 | 
  4 | 10
  5 | 1
  5 | 
(6 rows)

-- select mysql_json_value and as
--Testcase 4330:
SELECT mysql_json_value(c1, '$[1]') as json_value1 FROM s8;
ERROR:  stub mysql_json_value(json, text) is called
CONTEXT:  PL/pgSQL function mysql_json_value(json,text) line 3 at RAISE
-- select member_of (builtin function, explain)
--Testcase 4331:
EXPLAIN VERBOSE
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8;
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..172.14 rows=1462 width=16)
   Output: member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select member_of (builtin function, result)
--Testcase 4332:
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8;
ERROR:  stub member_of(anyelement, json) is called
CONTEXT:  PL/pgSQL function member_of(anyelement,json) line 3 at RAISE
-- select member_of (builtin function, not pushdown constraints, explain)
--Testcase 4333:
EXPLAIN VERBOSE
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8 WHERE to_hex(id) = '2';
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..132.16 rows=7 width=16)
   Output: member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}'::json)
   Filter: (to_hex(s8.id) = '2'::text)
   Local server startup cost: 10
   Remote query: SELECT `id`, `c1` FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select member_of (builtin function, not pushdown constraints, result)
--Testcase 4334:
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8 WHERE to_hex(id) = '2';
ERROR:  stub member_of(anyelement, json) is called
CONTEXT:  PL/pgSQL function member_of(anyelement,json) line 3 at RAISE
-- select member_of (builtin function, pushdown constraints, explain)
--Testcase 4335:
EXPLAIN VERBOSE
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8 WHERE id != 0;
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..175.56 rows=1455 width=16)
   Output: member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((`id` <> 0))
(4 rows)

-- select member_of (builtin function, pushdown constraints, result)
--Testcase 4336:
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8 WHERE id != 0;
ERROR:  stub member_of(anyelement, json) is called
CONTEXT:  PL/pgSQL function member_of(anyelement,json) line 3 at RAISE
-- select member_of (builtin function, member_of in constraints, explain)
--Testcase 4337:
EXPLAIN VERBOSE
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8 WHERE member_of(5, c1) != 0;
                                                                                   QUERY PLAN                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..179.22 rows=1455 width=16)
   Output: member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((5 MEMBER OF(`c1`)  <> 0))
(4 rows)

-- select member_of (builtin function, member_of in constraints, result)
--Testcase 4338:
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8 WHERE member_of(5, c1) != 0;
ERROR:  stub member_of(anyelement, json) is called
CONTEXT:  PL/pgSQL function member_of(anyelement,json) line 3 at RAISE
-- select member_of (builtin function, member_of in constraints, explain)
--Testcase 4339:
EXPLAIN VERBOSE
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8 WHERE member_of(json_build_object('item', 'shoes', 'price', '49.95'), '{"item": "shoes", "price": "49.95"}') = 1;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..135.81 rows=7 width=16)
   Output: member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}'::json)
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8` WHERE ((json_object('item', 'shoes', 'price', '49.95') MEMBER OF(CAST('{"item": "shoes", "price": "49.95"}' AS JSON))  = 1))
(4 rows)

-- select member_of (builtin function, member_of in constraints, result)
--Testcase 4340:
SELECT member_of(5, c1), member_of('ab'::text, c1), member_of('[3,4]'::json, c1), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8 WHERE member_of(json_build_object('item', 'shoes', 'price', '49.95'), '{"item": "shoes", "price": "49.95"}') = 1;
ERROR:  stub member_of(anyelement, json) is called
CONTEXT:  PL/pgSQL function member_of(anyelement,json) line 3 at RAISE
-- select member_of as nest function with agg (pushdown, explain)
--Testcase 4341:
EXPLAIN VERBOSE
SELECT sum(id), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=1 width=12)
   Output: (sum(id)), (member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}'::json))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT sum(`id`), json_object('item', 'shoes') MEMBER OF(CAST('{"item": "shoes", "price": "49.95"}' AS JSON))  FROM `mysql_fdw_regress`.`s8`
(5 rows)

-- select member_of as nest function with agg (pushdown, result)
--Testcase 4342:
SELECT sum(id), member_of(json_build_object('item', 'shoes'), '{"item": "shoes", "price": "49.95"}') FROM s8;
 sum | member_of 
-----+-----------
  15 |         0
(1 row)

-- select member_of with non pushdown func and explicit constant (EXPLAIN)
--Testcase 4343:
EXPLAIN VERBOSE
SELECT member_of('ab'::text, c1), member_of('[3,4]'::json, c1), pi(), 4.1 FROM s8;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.s8  (cost=100.00..161.17 rows=1462 width=48)
   Output: member_of('ab'::text, c1), member_of('[3,4]'::json, c1), '3.141592653589793'::double precision, 4.1
   Local server startup cost: 10
   Remote query: SELECT `c1` FROM `mysql_fdw_regress`.`s8`
(4 rows)

-- select member_of with non pushdown func and explicit constant (result)
--Testcase 4344:
SELECT member_of('ab'::text, c1), member_of('[3,4]'::json, c1), pi(), 4.1 FROM s8;
ERROR:  stub member_of(text, json) is called
CONTEXT:  PL/pgSQL function member_of(text,json) line 3 at RAISE
-- select member_of with order by index (result)
--Testcase 4345:
SELECT id, member_of(5, c1) FROM s8 ORDER BY 2, 1;
ERROR:  stub member_of(anyelement, json) is called
CONTEXT:  PL/pgSQL function member_of(anyelement,json) line 3 at RAISE
-- select member_of with order by index (result)
--Testcase 4346:
SELECT id, member_of(5, c1) FROM s8 ORDER BY 1, 2;
ERROR:  stub member_of(anyelement, json) is called
CONTEXT:  PL/pgSQL function member_of(anyelement,json) line 3 at RAISE
-- select member_of with group by (EXPLAIN)
--Testcase 4347:
EXPLAIN VERBOSE
SELECT count(id), member_of(5, c1) FROM s8 group by member_of(5, c1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=200 width=12)
   Output: (count(id)), (member_of(5, c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`id`), 5 MEMBER OF(`c1`)  FROM `mysql_fdw_regress`.`s8` GROUP BY 2
(5 rows)

-- select member_of with group by (result)
--Testcase 4348:
SELECT count(id), member_of(5, c1) FROM s8 group by member_of(5, c1);
 count | member_of 
-------+-----------
     1 |         1
     5 |         0
(2 rows)

-- select member_of with group by index (result)
--Testcase 4349:
SELECT id, member_of(5, c1) FROM s8 group by 2, 1;
 id | member_of 
----+-----------
  0 |         1
  1 |         0
  2 |         0
  3 |         0
  4 |         0
  5 |         0
(6 rows)

-- select member_of with group by index (result)
--Testcase 4350:
SELECT id, member_of(5, c1) FROM s8 group by 1, 2;
 id | member_of 
----+-----------
  0 |         1
  1 |         0
  2 |         0
  3 |         0
  4 |         0
  5 |         0
(6 rows)

-- select member_of with group by having (EXPLAIN)
--Testcase 4351:
EXPLAIN VERBOSE
SELECT count(c2), member_of(5, c1) FROM s8 group by member_of(5, c1) HAVING count(c2) > 0;
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Foreign Scan  (cost=0.00..0.00 rows=67 width=12)
   Output: (count(c2)), (member_of(5, c1))
   Relations: Aggregate on (mysql_fdw_regress.s8)
   Local server startup cost: 10
   Remote query: SELECT count(`c2`), 5 MEMBER OF(`c1`)  FROM `mysql_fdw_regress`.`s8` GROUP BY 2 HAVING ((count(`c2`) > 0))
(5 rows)

-- select member_of with group by having (result)
--Testcase 4352:
SELECT count(c2), member_of(5, c1) FROM s8 group by member_of(5, c1) HAVING count(c2) > 0;
 count | member_of 
-------+-----------
     1 |         1
     5 |         0
(2 rows)

-- select member_of with group by index having (result)
--Testcase 4353:
SELECT c2, member_of(5, c1) FROM s8 group by 2, 1 HAVING count(c2) > 0;
 c2 | member_of 
----+-----------
  1 |         1
  2 |         0
  3 |         0
  4 |         0
  5 |         0
(5 rows)

-- select member_of with group by index having (result)
--Testcase 4354:
SELECT c2, member_of(5, c1) FROM s8 group by 1, 2 HAVING count(c2) > 0;
 c2 | member_of 
----+-----------
  1 |         1
  2 |         0
  3 |         0
  4 |         0
  5 |         0
(5 rows)

-- select member_of and as
--Testcase 4355:
SELECT member_of('ab'::text, c1), member_of('[3,4]'::json, c1) as member_of1 FROM s8;
ERROR:  stub member_of(text, json) is called
CONTEXT:  PL/pgSQL function member_of(text,json) line 3 at RAISE
--Testcase 4356:
DROP FOREIGN TABLE s8;
--Testcase 4357:
DROP FOREIGN TABLE s9;
--Testcase 4358:
DROP USER MAPPING FOR CURRENT_USER SERVER server1;
--Testcase 4359:
DROP SERVER server1;
--Testcase 4360:
DROP EXTENSION mysql_fdw;
